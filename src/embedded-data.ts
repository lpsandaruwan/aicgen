// AUTO-GENERATED - DO NOT EDIT
// Generated by scripts/embed-data.ts
// Contains all guideline mappings and content embedded for binary distribution

export interface GuidelineMapping {
  path: string;
  category?: string;
  languages?: string[];
  levels?: string[];
  architectures?: string[];
  tags?: string[];
}

export interface EmbeddedData {
  mappings: Record<string, GuidelineMapping>;
  guidelines: Record<string, string>;
}

export const EMBEDDED_DATA: EmbeddedData = {
  "mappings": {
    "typescript-basics": {
      "path": "language/typescript/basics.md",
      "languages": [
        "typescript"
      ],
      "levels": [
        "basic",
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "typescript",
        "fundamentals",
        "types"
      ],
      "category": "Language"
    },
    "typescript-async": {
      "path": "language/typescript/async.md",
      "languages": [
        "typescript"
      ],
      "levels": [
        "basic",
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "typescript",
        "async",
        "promises"
      ],
      "category": "Language"
    },
    "typescript-interfaces-types": {
      "path": "language/typescript/interfaces-types.md",
      "languages": [
        "typescript"
      ],
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "typescript",
        "interfaces",
        "types",
        "utility-types"
      ],
      "category": "Language"
    },
    "typescript-generics": {
      "path": "language/typescript/generics.md",
      "languages": [
        "typescript"
      ],
      "levels": [
        "expert",
        "full"
      ],
      "tags": [
        "typescript",
        "generics",
        "advanced"
      ],
      "category": "Language"
    },
    "typescript-error-handling": {
      "path": "language/typescript/error-handling.md",
      "languages": [
        "typescript"
      ],
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "typescript",
        "errors",
        "exceptions"
      ],
      "category": "Language"
    },
    "typescript-testing": {
      "path": "language/typescript/testing.md",
      "languages": [
        "typescript"
      ],
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "typescript",
        "testing",
        "jest"
      ],
      "category": "Language"
    },
    "typescript-config": {
      "path": "language/typescript/config.md",
      "languages": [
        "typescript"
      ],
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "typescript",
        "tsconfig",
        "configuration"
      ],
      "category": "Language"
    },
    "typescript-performance": {
      "path": "language/typescript/performance.md",
      "languages": [
        "typescript"
      ],
      "levels": [
        "expert",
        "full"
      ],
      "tags": [
        "typescript",
        "performance",
        "optimization"
      ],
      "category": "Language"
    },
    "python-basics": {
      "path": "language/python/basics.md",
      "languages": [
        "python"
      ],
      "levels": [
        "basic",
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "python",
        "fundamentals",
        "pep8"
      ],
      "category": "Language"
    },
    "python-types": {
      "path": "language/python/types.md",
      "languages": [
        "python"
      ],
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "python",
        "types",
        "type-hints",
        "mypy"
      ],
      "category": "Language"
    },
    "python-async": {
      "path": "language/python/async.md",
      "languages": [
        "python"
      ],
      "levels": [
        "expert",
        "full"
      ],
      "tags": [
        "python",
        "async",
        "asyncio"
      ],
      "category": "Language"
    },
    "python-testing": {
      "path": "language/python/testing.md",
      "languages": [
        "python"
      ],
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "python",
        "testing",
        "pytest"
      ],
      "category": "Language"
    },
    "microservices-boundaries": {
      "path": "architecture/microservices/boundaries.md",
      "architectures": [
        "microservices"
      ],
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "microservices",
        "boundaries",
        "ddd"
      ],
      "category": "Architecture"
    },
    "microservices-communication": {
      "path": "architecture/microservices/communication.md",
      "architectures": [
        "microservices"
      ],
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "microservices",
        "communication",
        "messaging",
        "events"
      ],
      "category": "Architecture"
    },
    "microservices-data": {
      "path": "architecture/microservices/data.md",
      "architectures": [
        "microservices"
      ],
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "microservices",
        "data",
        "consistency",
        "saga"
      ],
      "category": "Architecture"
    },
    "microservices-resilience": {
      "path": "architecture/microservices/resilience.md",
      "architectures": [
        "microservices"
      ],
      "levels": [
        "expert",
        "full"
      ],
      "tags": [
        "microservices",
        "resilience",
        "circuit-breaker",
        "retry"
      ],
      "category": "Architecture"
    },
    "modular-monolith-structure": {
      "path": "architecture/modular-monolith/structure.md",
      "architectures": [
        "modular-monolith"
      ],
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "modular-monolith",
        "structure",
        "modules"
      ],
      "category": "Architecture"
    },
    "modular-monolith-boundaries": {
      "path": "architecture/modular-monolith/boundaries.md",
      "architectures": [
        "modular-monolith"
      ],
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "modular-monolith",
        "boundaries",
        "coupling",
        "events"
      ],
      "category": "Architecture"
    },
    "testing-unit-fundamentals": {
      "path": "testing/unit-fundamentals.md",
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "testing",
        "unit-tests",
        "aaa-pattern"
      ],
      "category": "Testing"
    },
    "testing-unit-mocking": {
      "path": "testing/unit-mocking.md",
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "testing",
        "mocking",
        "test-doubles",
        "stubs"
      ],
      "category": "Testing"
    },
    "testing-integration": {
      "path": "testing/integration.md",
      "levels": [
        "expert",
        "full"
      ],
      "tags": [
        "testing",
        "integration",
        "database",
        "api"
      ],
      "category": "Testing"
    },
    "security-injection": {
      "path": "security/injection.md",
      "levels": [
        "basic",
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "security",
        "owasp",
        "sql-injection",
        "xss"
      ],
      "category": "Security"
    },
    "security-auth-jwt": {
      "path": "security/auth-jwt.md",
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "security",
        "auth",
        "jwt",
        "session",
        "password"
      ],
      "category": "Security"
    },
    "security-secrets": {
      "path": "security/secrets.md",
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "security",
        "secrets",
        "env",
        "configuration"
      ],
      "category": "Security"
    },
    "security-headers": {
      "path": "security/headers.md",
      "levels": [
        "expert",
        "full"
      ],
      "tags": [
        "security",
        "headers",
        "cors",
        "csp",
        "https"
      ],
      "category": "Security"
    },
    "performance-caching": {
      "path": "performance/caching.md",
      "levels": [
        "expert",
        "full"
      ],
      "tags": [
        "performance",
        "caching",
        "redis",
        "memoization"
      ],
      "category": "Performance"
    },
    "performance-async": {
      "path": "performance/async.md",
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "performance",
        "async",
        "parallel",
        "batching"
      ],
      "category": "Performance"
    },
    "database-schema": {
      "path": "database/schema.md",
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "database",
        "schema",
        "design",
        "normalization"
      ],
      "category": "Database"
    },
    "database-indexing": {
      "path": "database/indexing.md",
      "levels": [
        "expert",
        "full"
      ],
      "tags": [
        "database",
        "indexing",
        "performance",
        "queries"
      ],
      "category": "Database"
    },
    "api-rest": {
      "path": "api/rest.md",
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "api",
        "rest",
        "http",
        "design"
      ],
      "category": "API Design"
    },
    "api-pagination": {
      "path": "api/pagination.md",
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "api",
        "pagination",
        "cursor",
        "offset"
      ],
      "category": "API Design"
    },
    "code-style-naming": {
      "path": "style/naming.md",
      "levels": [
        "basic",
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "style",
        "naming",
        "conventions"
      ],
      "category": "Code Style"
    },
    "code-style-organization": {
      "path": "style/organization.md",
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "style",
        "organization",
        "structure",
        "srp"
      ],
      "category": "Code Style"
    },
    "error-handling-strategy": {
      "path": "error-handling/strategy.md",
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "errors",
        "exceptions",
        "resilience",
        "retry"
      ],
      "category": "Error Handling"
    },
    "solid-principles": {
      "path": "architecture/solid/principles.md",
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "solid",
        "srp",
        "ocp",
        "lsp",
        "isp",
        "dip",
        "design-principles"
      ],
      "category": "Architecture"
    },
    "clean-architecture-layers": {
      "path": "architecture/clean-architecture/layers.md",
      "architectures": [
        "clean-architecture"
      ],
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "clean-architecture",
        "layers",
        "dependency-rule",
        "use-cases"
      ],
      "category": "Architecture"
    },
    "ddd-tactical": {
      "path": "architecture/ddd/tactical.md",
      "architectures": [
        "ddd"
      ],
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "ddd",
        "entities",
        "value-objects",
        "aggregates",
        "domain-events"
      ],
      "category": "Architecture"
    },
    "ddd-strategic": {
      "path": "architecture/ddd/strategic.md",
      "architectures": [
        "ddd"
      ],
      "levels": [
        "expert",
        "full"
      ],
      "tags": [
        "ddd",
        "bounded-context",
        "ubiquitous-language",
        "context-mapping"
      ],
      "category": "Architecture"
    },
    "event-driven-patterns": {
      "path": "architecture/event-driven/patterns.md",
      "architectures": [
        "event-driven"
      ],
      "levels": [
        "expert",
        "full"
      ],
      "tags": [
        "event-sourcing",
        "cqrs",
        "saga",
        "event-driven"
      ],
      "category": "Architecture"
    },
    "layered-architecture": {
      "path": "architecture/layered/layers.md",
      "architectures": [
        "layered"
      ],
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "layered",
        "presentation",
        "domain",
        "data-access"
      ],
      "category": "Architecture"
    },
    "serverless-patterns": {
      "path": "architecture/serverless/patterns.md",
      "architectures": [
        "serverless"
      ],
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "serverless",
        "faas",
        "lambda",
        "cold-start"
      ],
      "category": "Architecture"
    },
    "gui-architecture": {
      "path": "architecture/gui/patterns.md",
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "gui",
        "mvc",
        "mvp",
        "mvvm",
        "component-architecture"
      ],
      "category": "Architecture"
    },
    "feature-toggles": {
      "path": "architecture/feature-toggles/patterns.md",
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "feature-flags",
        "release-toggles",
        "ab-testing"
      ],
      "category": "Architecture"
    },
    "devops-ci-cd": {
      "path": "devops/ci-cd.md",
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "devops",
        "ci",
        "cd",
        "deployment",
        "pipelines"
      ],
      "category": "DevOps"
    },
    "devops-practices": {
      "path": "devops/practices.md",
      "levels": [
        "expert",
        "full"
      ],
      "tags": [
        "devops",
        "infrastructure",
        "observability",
        "containers"
      ],
      "category": "DevOps"
    },
    "practices-planning": {
      "path": "practices/planning.md",
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "planning",
        "phases",
        "communication",
        "requirements",
        "approval"
      ],
      "category": "Best Practices"
    },
    "practices-documentation": {
      "path": "practices/documentation.md",
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "documentation",
        "organization",
        "memory-lane",
        "context",
        "structure"
      ],
      "category": "Best Practices"
    },
    "practices-code-review": {
      "path": "practices/code-review.md",
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "code-review",
        "pr",
        "feedback",
        "collaboration"
      ],
      "category": "Best Practices"
    },
    "practices-refactoring": {
      "path": "practices/refactoring.md",
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "refactoring",
        "code-smells",
        "clean-code"
      ],
      "category": "Best Practices"
    },
    "practices-version-control": {
      "path": "practices/version-control.md",
      "levels": [
        "basic",
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "git",
        "branching",
        "commits",
        "version-control"
      ],
      "category": "Best Practices"
    },
    "api-versioning": {
      "path": "api/versioning.md",
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "api",
        "versioning",
        "deprecation",
        "backwards-compatibility"
      ],
      "category": "API Design"
    },
    "performance-caching-strategies": {
      "path": "performance/caching-strategies.md",
      "levels": [
        "expert",
        "full"
      ],
      "tags": [
        "caching",
        "cache-aside",
        "write-through",
        "invalidation"
      ],
      "category": "Performance"
    },
    "database-design-patterns": {
      "path": "database/design-patterns.md",
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "database",
        "normalization",
        "denormalization",
        "soft-deletes"
      ],
      "category": "Database"
    },
    "patterns-base": {
      "path": "patterns/base-patterns.md",
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "value-object",
        "money",
        "special-case",
        "registry",
        "plugin"
      ],
      "category": "Design Patterns"
    },
    "patterns-concurrency": {
      "path": "patterns/concurrency.md",
      "levels": [
        "expert",
        "full"
      ],
      "tags": [
        "concurrency",
        "optimistic-lock",
        "pessimistic-lock",
        "locking"
      ],
      "category": "Design Patterns"
    },
    "patterns-data-access": {
      "path": "patterns/data-access.md",
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "repository",
        "data-mapper",
        "active-record",
        "unit-of-work"
      ],
      "category": "Design Patterns"
    },
    "patterns-distribution": {
      "path": "patterns/distribution.md",
      "levels": [
        "expert",
        "full"
      ],
      "tags": [
        "remote-facade",
        "dto",
        "gateway",
        "service-stub"
      ],
      "category": "Design Patterns"
    },
    "patterns-domain-logic": {
      "path": "patterns/domain-logic.md",
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "transaction-script",
        "domain-model",
        "service-layer"
      ],
      "category": "Design Patterns"
    },
    "patterns-gof": {
      "path": "patterns/gof.md",
      "levels": [
        "standard",
        "expert",
        "full"
      ],
      "tags": [
        "gang-of-four",
        "factory",
        "strategy",
        "observer",
        "decorator"
      ],
      "category": "Design Patterns"
    }
  },
  "guidelines": {
    "api/index.md": "# API Design Guidelines\n\nThis directory contains REST API design patterns.\n\n## Available Chunks\n\n- **rest.md** - Resource-oriented design, HTTP methods, status codes\n- **pagination.md** - Offset-based, cursor-based, HATEOAS links\n",
    "api/pagination.md": "# API Pagination\n\n## Always Paginate Collections\n\n```typescript\n// ✅ Paginated endpoint\napp.get('/api/v1/books', async (req, res) => {\n  const page = parseInt(req.query.page as string) || 1;\n  const limit = Math.min(parseInt(req.query.limit as string) || 20, 100);\n\n  const { data, total } = await bookService.findAll({ page, limit });\n\n  res.json({\n    data,\n    pagination: {\n      page,\n      limit,\n      total,\n      totalPages: Math.ceil(total / limit),\n      hasNext: page * limit < total,\n      hasPrevious: page > 1\n    }\n  });\n});\n```\n\n## Offset-Based Pagination\n\n```typescript\n// Simple but has issues with large datasets\nGET /api/v1/books?page=1&limit=20\nGET /api/v1/books?page=2&limit=20\n\n// Implementation\nconst getBooks = async (page: number, limit: number) => {\n  const offset = (page - 1) * limit;\n\n  const [data, total] = await Promise.all([\n    db.query('SELECT * FROM books ORDER BY id LIMIT ? OFFSET ?', [limit, offset]),\n    db.query('SELECT COUNT(*) FROM books')\n  ]);\n\n  return { data, total };\n};\n```\n\n## Cursor-Based Pagination\n\n```typescript\n// Better for large datasets and real-time data\nGET /api/v1/books?cursor=eyJpZCI6MTIzfQ&limit=20\n\n// Response includes next cursor\n{\n  \"data\": [...],\n  \"pagination\": {\n    \"nextCursor\": \"eyJpZCI6MTQzfQ\",\n    \"hasMore\": true\n  }\n}\n\n// Implementation\nconst getBooks = async (cursor: string | null, limit: number) => {\n  let query = 'SELECT * FROM books';\n\n  if (cursor) {\n    const { id } = decodeCursor(cursor);\n    query += ` WHERE id > ${id}`;\n  }\n\n  query += ` ORDER BY id LIMIT ${limit + 1}`;\n  const data = await db.query(query);\n\n  const hasMore = data.length > limit;\n  const items = hasMore ? data.slice(0, limit) : data;\n\n  return {\n    data: items,\n    pagination: {\n      nextCursor: hasMore ? encodeCursor({ id: items[items.length - 1].id }) : null,\n      hasMore\n    }\n  };\n};\n```\n\n## Keyset Pagination\n\n```sql\n-- Most efficient for large tables\n-- First page\nSELECT * FROM products\nORDER BY created_at DESC, id DESC\nLIMIT 20;\n\n-- Next page (using last item's values)\nSELECT * FROM products\nWHERE (created_at, id) < ('2024-01-15 10:00:00', 12345)\nORDER BY created_at DESC, id DESC\nLIMIT 20;\n```\n\n## HATEOAS Links\n\n```typescript\n// Include navigation links\n{\n  \"data\": [...],\n  \"pagination\": {\n    \"page\": 2,\n    \"limit\": 20,\n    \"total\": 150\n  },\n  \"links\": {\n    \"self\": \"/api/v1/books?page=2&limit=20\",\n    \"first\": \"/api/v1/books?page=1&limit=20\",\n    \"prev\": \"/api/v1/books?page=1&limit=20\",\n    \"next\": \"/api/v1/books?page=3&limit=20\",\n    \"last\": \"/api/v1/books?page=8&limit=20\"\n  }\n}\n```\n\n## Pagination Best Practices\n\n```typescript\n// ✅ Set reasonable defaults and limits\nconst page = parseInt(req.query.page) || 1;\nconst limit = Math.min(parseInt(req.query.limit) || 20, 100);\n\n// ✅ Include total count (when practical)\nconst total = await db.count('books');\n\n// ✅ Use consistent response structure\n{\n  \"data\": [],\n  \"pagination\": { ... }\n}\n\n// ❌ Don't return unlimited results\n// ❌ Don't allow page < 1 or limit < 1\n```\n",
    "api/rest.md": "# REST API Design\n\n## Resource-Oriented URLs\n\n```\n✅ Good (nouns, plural)\nGET    /api/v1/books           # List books\nGET    /api/v1/books/123       # Get book\nPOST   /api/v1/books           # Create book\nPUT    /api/v1/books/123       # Replace book\nPATCH  /api/v1/books/123       # Update book\nDELETE /api/v1/books/123       # Delete book\n\n❌ Bad (verbs, actions)\nPOST /api/v1/createBook\nGET  /api/v1/getBookById/123\nPOST /api/v1/updateBook/123\n```\n\n## HTTP Methods\n\n```typescript\n// GET - Read (safe, idempotent)\napp.get('/api/v1/users/:id', async (req, res) => {\n  const user = await userService.findById(req.params.id);\n  res.json({ data: user });\n});\n\n// POST - Create (not idempotent)\napp.post('/api/v1/users', async (req, res) => {\n  const user = await userService.create(req.body);\n  res.status(201)\n    .location(`/api/v1/users/${user.id}`)\n    .json({ data: user });\n});\n\n// PUT - Replace entire resource (idempotent)\napp.put('/api/v1/users/:id', async (req, res) => {\n  const user = await userService.replace(req.params.id, req.body);\n  res.json({ data: user });\n});\n\n// PATCH - Partial update (idempotent)\napp.patch('/api/v1/users/:id', async (req, res) => {\n  const user = await userService.update(req.params.id, req.body);\n  res.json({ data: user });\n});\n\n// DELETE - Remove (idempotent)\napp.delete('/api/v1/users/:id', async (req, res) => {\n  await userService.delete(req.params.id);\n  res.status(204).end();\n});\n```\n\n## Status Codes\n\n```typescript\n// Success\n200 OK           // GET, PUT, PATCH succeeded\n201 Created      // POST succeeded\n204 No Content   // DELETE succeeded\n\n// Client errors\n400 Bad Request  // Validation failed\n401 Unauthorized // Not authenticated\n403 Forbidden    // Authenticated but not allowed\n404 Not Found    // Resource doesn't exist\n409 Conflict     // Duplicate, version conflict\n422 Unprocessable // Business rule violation\n\n// Server errors\n500 Internal Server Error\n```\n\n## Response Format\n\n```typescript\n// Single resource\n{\n  \"data\": {\n    \"id\": 123,\n    \"name\": \"John Doe\",\n    \"email\": \"john@example.com\"\n  }\n}\n\n// Collection with pagination\n{\n  \"data\": [\n    { \"id\": 1, \"name\": \"Item 1\" },\n    { \"id\": 2, \"name\": \"Item 2\" }\n  ],\n  \"pagination\": {\n    \"page\": 1,\n    \"limit\": 20,\n    \"total\": 150,\n    \"totalPages\": 8\n  }\n}\n\n// Error response\n{\n  \"error\": {\n    \"code\": \"VALIDATION_ERROR\",\n    \"message\": \"The request contains invalid data\",\n    \"details\": [\n      { \"field\": \"email\", \"message\": \"Invalid email format\" }\n    ]\n  }\n}\n```\n\n## Hierarchical Resources\n\n```\n✅ Limit nesting to 2-3 levels\nGET /api/v1/authors/456/books       # Books by author\nGET /api/v1/orders/789/items        # Items in order\n\n❌ Too deep\nGET /api/v1/publishers/1/authors/2/books/3/reviews/4\n\n✅ Use query parameters instead\nGET /api/v1/reviews?bookId=3\n```\n\n## API Versioning\n\n```\n✅ Always version from the start\n/api/v1/books\n/api/v2/books\n\n❌ No version\n/api/books\n```\n",
    "api/versioning.md": "# API Versioning\n\n## Versioning Strategies\n\n### URL Path Versioning\n```\nGET /api/v1/users\nGET /api/v2/users\n```\n\n### Header Versioning\n```\nGET /api/users\nAccept: application/vnd.api+json; version=2\n```\n\n### Query Parameter\n```\nGET /api/users?version=2\n```\n\n## Implementation\n\n```typescript\n// URL path versioning\napp.use('/api/v1', v1Router);\napp.use('/api/v2', v2Router);\n\n// Header versioning middleware\nfunction versionMiddleware(req, res, next) {\n  const version = req.headers['api-version'] || '1';\n  req.apiVersion = parseInt(version);\n  next();\n}\n\napp.get('/users', versionMiddleware, (req, res) => {\n  if (req.apiVersion >= 2) {\n    return handleV2(req, res);\n  }\n  return handleV1(req, res);\n});\n```\n\n## Deprecation Strategy\n\n```typescript\n// Add deprecation headers\nres.setHeader('Deprecation', 'true');\nres.setHeader('Sunset', 'Sat, 01 Jan 2025 00:00:00 GMT');\nres.setHeader('Link', '</api/v2/users>; rel=\"successor-version\"');\n```\n\n## Best Practices\n\n- Version from the start\n- Support at least N-1 versions\n- Document deprecation timeline\n- Provide migration guides\n- Use semantic versioning for breaking changes\n- Consider backwards-compatible changes first\n",
    "architecture/clean-architecture/index.md": "# Clean Architecture\n\nThis directory contains Clean Architecture patterns.\n\n## Available Chunks\n\n- **layers.md** - Dependency rule, layers, use cases, adapters\n",
    "architecture/clean-architecture/layers.md": "# Clean Architecture\n\n## Core Principle\n\nDependencies point inward. Inner layers know nothing about outer layers.\n\n```\n┌─────────────────────────────────────────────┐\n│            Frameworks & Drivers             │\n│  ┌─────────────────────────────────────┐    │\n│  │       Interface Adapters            │    │\n│  │  ┌─────────────────────────────┐    │    │\n│  │  │     Application Business    │    │    │\n│  │  │  ┌─────────────────────┐    │    │    │\n│  │  │  │  Enterprise Business│    │    │    │\n│  │  │  │     (Entities)      │    │    │    │\n│  │  │  └─────────────────────┘    │    │    │\n│  │  │       (Use Cases)           │    │    │\n│  │  └─────────────────────────────┘    │    │\n│  │    (Controllers, Gateways)          │    │\n│  └─────────────────────────────────────┘    │\n│      (Web, DB, External APIs)               │\n└─────────────────────────────────────────────┘\n```\n\n## The Dependency Rule\n\nSource code dependencies only point inward.\n\n## Layer Structure\n\n### Entities (Enterprise Business Rules)\n\n```typescript\nclass Order {\n  constructor(\n    public readonly id: string,\n    private items: OrderItem[],\n    private status: OrderStatus\n  ) {}\n\n  calculateTotal(): Money {\n    return this.items.reduce(\n      (sum, item) => sum.add(item.subtotal()),\n      Money.zero()\n    );\n  }\n\n  canBeCancelled(): boolean {\n    return this.status === OrderStatus.Pending;\n  }\n}\n```\n\n### Use Cases (Application Business Rules)\n\n```typescript\nclass CreateOrderUseCase {\n  constructor(\n    private orderRepository: OrderRepository,\n    private productRepository: ProductRepository\n  ) {}\n\n  async execute(request: CreateOrderRequest): Promise<CreateOrderResponse> {\n    const products = await this.productRepository.findByIds(request.productIds);\n    const order = new Order(generateId(), this.createItems(products));\n    await this.orderRepository.save(order);\n    return { orderId: order.id };\n  }\n}\n```\n\n### Interface Adapters\n\n```typescript\n// Controller (adapts HTTP to use case)\nclass OrderController {\n  constructor(private createOrder: CreateOrderUseCase) {}\n\n  async create(req: Request, res: Response) {\n    const result = await this.createOrder.execute(req.body);\n    res.json(result);\n  }\n}\n\n// Repository Implementation (adapts use case to database)\nclass PostgreSQLOrderRepository implements OrderRepository {\n  async save(order: Order): Promise<void> {\n    await this.db.query('INSERT INTO orders...');\n  }\n}\n```\n\n### Frameworks & Drivers\n\n```typescript\n// Express setup\nconst app = express();\napp.post('/orders', (req, res) => orderController.create(req, res));\n\n// Database connection\nconst db = new Pool({ connectionString: process.env.DATABASE_URL });\n```\n\n## Best Practices\n\n- Keep entities pure with no framework dependencies\n- Use cases orchestrate domain logic\n- Interfaces defined in inner layers, implemented in outer layers\n- Cross boundaries with simple data structures\n- Test use cases independently of frameworks\n",
    "architecture/ddd/index.md": "# Domain-Driven Design\n\nThis directory contains DDD patterns.\n\n## Available Chunks\n\n- **tactical.md** - Entities, Value Objects, Aggregates, Domain Events\n- **strategic.md** - Bounded Contexts, Ubiquitous Language, Context Mapping\n",
    "architecture/ddd/strategic.md": "# DDD Strategic Patterns\n\n## Ubiquitous Language\n\nUse the same terminology in code, documentation, and conversations.\n\n```typescript\n// Domain experts say \"place an order\"\nclass Order {\n  place(): void { /* not submit(), not create() */ }\n}\n\n// Domain experts say \"items are added to cart\"\nclass ShoppingCart {\n  addItem(product: Product): void { /* not insert(), not push() */ }\n}\n```\n\n## Bounded Contexts\n\nExplicit boundaries where a model applies consistently.\n\n```\n┌─────────────────┐    ┌─────────────────┐\n│    Sales        │    │   Warehouse     │\n│    Context      │    │    Context      │\n├─────────────────┤    ├─────────────────┤\n│ Order           │    │ Order           │\n│ - customerId    │    │ - shipmentId    │\n│ - items[]       │    │ - pickingList   │\n│ - total         │    │ - status        │\n└─────────────────┘    └─────────────────┘\n   Same term, different model\n```\n\n## Context Mapping Patterns\n\n### Shared Kernel\nTwo contexts share a subset of the model.\n\n### Customer/Supplier\nUpstream context provides what downstream needs.\n\n### Conformist\nDownstream adopts upstream's model entirely.\n\n### Anti-Corruption Layer\nTranslate between contexts to protect domain model.\n\n```typescript\nclass InventoryAntiCorruptionLayer {\n  constructor(private legacyInventorySystem: LegacyInventory) {}\n\n  checkAvailability(productId: ProductId): Promise<boolean> {\n    // Translate from legacy format to domain model\n    const legacyResult = await this.legacyInventorySystem.getStock(\n      productId.toString()\n    );\n    return legacyResult.qty > 0;\n  }\n}\n```\n\n## Module Organization\n\n```\nsrc/\n├── sales/                    # Sales bounded context\n│   ├── domain/\n│   │   ├── order.ts\n│   │   └── customer.ts\n│   ├── application/\n│   │   └── place-order.ts\n│   └── infrastructure/\n│       └── order-repository.ts\n├── warehouse/                # Warehouse bounded context\n│   ├── domain/\n│   │   └── shipment.ts\n│   └── ...\n└── shared/                   # Shared kernel\n    └── money.ts\n```\n\n## Best Practices\n\n- Define context boundaries based on team structure and business capabilities\n- Use ubiquitous language within each context\n- Communicate between contexts via events or explicit APIs\n- Protect domain model with anti-corruption layers when integrating legacy systems\n",
    "architecture/ddd/tactical.md": "# DDD Tactical Patterns\n\n## Entities\n\nObjects with identity that persists through state changes.\n\n```typescript\nclass User {\n  constructor(\n    public readonly id: UserId,\n    private email: Email,\n    private name: string\n  ) {}\n\n  changeEmail(newEmail: Email): void {\n    this.email = newEmail;\n  }\n\n  equals(other: User): boolean {\n    return this.id.equals(other.id);\n  }\n}\n```\n\n## Value Objects\n\nImmutable objects defined by their attributes.\n\n```typescript\nclass Email {\n  private readonly value: string;\n\n  constructor(email: string) {\n    if (!this.isValid(email)) {\n      throw new InvalidEmailError(email);\n    }\n    this.value = email.toLowerCase();\n  }\n\n  equals(other: Email): boolean {\n    return this.value === other.value;\n  }\n}\n\nclass Money {\n  constructor(\n    public readonly amount: number,\n    public readonly currency: Currency\n  ) {\n    Object.freeze(this);\n  }\n\n  add(other: Money): Money {\n    this.assertSameCurrency(other);\n    return new Money(this.amount + other.amount, this.currency);\n  }\n}\n```\n\n## Aggregates\n\nCluster of entities and value objects with a root entity.\n\n```typescript\nclass Order {\n  private items: OrderItem[] = [];\n\n  constructor(\n    public readonly id: OrderId,\n    private customerId: CustomerId\n  ) {}\n\n  addItem(product: Product, quantity: number): void {\n    const item = new OrderItem(product.id, product.price, quantity);\n    this.items.push(item);\n  }\n\n  // All modifications go through aggregate root\n  removeItem(productId: ProductId): void {\n    this.items = this.items.filter(item => !item.productId.equals(productId));\n  }\n}\n```\n\n## Domain Events\n\nCapture something that happened in the domain.\n\n```typescript\nclass OrderPlaced implements DomainEvent {\n  constructor(\n    public readonly orderId: OrderId,\n    public readonly customerId: CustomerId,\n    public readonly occurredOn: Date = new Date()\n  ) {}\n}\n\nclass Order {\n  private events: DomainEvent[] = [];\n\n  place(): void {\n    this.status = OrderStatus.Placed;\n    this.events.push(new OrderPlaced(this.id, this.customerId));\n  }\n\n  pullEvents(): DomainEvent[] {\n    const events = [...this.events];\n    this.events = [];\n    return events;\n  }\n}\n```\n\n## Repositories\n\nAbstract persistence for aggregates.\n\n```typescript\ninterface OrderRepository {\n  findById(id: OrderId): Promise<Order | null>;\n  save(order: Order): Promise<void>;\n  nextId(): OrderId;\n}\n```\n\n## Best Practices\n\n- One repository per aggregate root\n- Aggregates should be small\n- Reference other aggregates by ID\n- Publish domain events for cross-aggregate communication\n- Keep value objects immutable\n",
    "architecture/event-driven/index.md": "# Event-Driven Architecture\n\nThis directory contains event-driven architecture patterns.\n\n## Available Chunks\n\n- **patterns.md** - Event Sourcing, CQRS, Sagas, Event Versioning\n",
    "architecture/event-driven/patterns.md": "# Event-Driven Architecture\n\n## Event Sourcing\n\nStore state as a sequence of events.\n\n```typescript\ninterface Event {\n  id: string;\n  aggregateId: string;\n  type: string;\n  data: unknown;\n  timestamp: Date;\n  version: number;\n}\n\nclass Account {\n  private balance = 0;\n  private version = 0;\n\n  static fromEvents(events: Event[]): Account {\n    const account = new Account();\n    events.forEach(event => account.apply(event));\n    return account;\n  }\n\n  private apply(event: Event): void {\n    switch (event.type) {\n      case 'MoneyDeposited':\n        this.balance += (event.data as { amount: number }).amount;\n        break;\n      case 'MoneyWithdrawn':\n        this.balance -= (event.data as { amount: number }).amount;\n        break;\n    }\n    this.version = event.version;\n  }\n}\n```\n\n## CQRS (Command Query Responsibility Segregation)\n\nSeparate read and write models.\n\n```typescript\n// Write Model (Commands)\nclass OrderCommandHandler {\n  async handle(cmd: PlaceOrderCommand): Promise<void> {\n    const order = new Order(cmd.orderId, cmd.items);\n    await this.eventStore.save(order.changes());\n  }\n}\n\n// Read Model (Queries)\nclass OrderQueryService {\n  async getOrderSummary(orderId: string): Promise<OrderSummaryDTO> {\n    return this.readDb.query('SELECT * FROM order_summaries WHERE id = $1', [orderId]);\n  }\n}\n\n// Projection updates read model from events\nclass OrderProjection {\n  async handle(event: OrderPlaced): Promise<void> {\n    await this.readDb.insert('order_summaries', {\n      id: event.orderId,\n      status: 'placed',\n      total: event.total\n    });\n  }\n}\n```\n\n## Saga Pattern\n\nManage long-running transactions across services.\n\n```typescript\nclass OrderSaga {\n  async execute(orderId: string): Promise<void> {\n    try {\n      await this.paymentService.charge(orderId);\n      await this.inventoryService.reserve(orderId);\n      await this.shippingService.schedule(orderId);\n    } catch (error) {\n      await this.compensate(orderId, error);\n    }\n  }\n\n  private async compensate(orderId: string, error: Error): Promise<void> {\n    await this.shippingService.cancel(orderId);\n    await this.inventoryService.release(orderId);\n    await this.paymentService.refund(orderId);\n  }\n}\n```\n\n## Event Versioning\n\nHandle schema changes gracefully.\n\n```typescript\ninterface EventUpgrader {\n  upgrade(event: Event): Event;\n}\n\nclass OrderPlacedV1ToV2 implements EventUpgrader {\n  upgrade(event: Event): Event {\n    const oldData = event.data as OrderPlacedV1Data;\n    return {\n      ...event,\n      type: 'OrderPlaced',\n      version: 2,\n      data: {\n        ...oldData,\n        currency: 'USD' // New field with default\n      }\n    };\n  }\n}\n```\n\n## Best Practices\n\n- Events are immutable facts\n- Include enough context in events for consumers\n- Version events from the start\n- Use idempotent event handlers\n- Design for eventual consistency\n- Consider snapshots for aggregates with many events\n",
    "architecture/feature-toggles/index.md": "# Feature Toggles\n\nThis directory contains feature toggle patterns.\n\n## Available Chunks\n\n- **patterns.md** - Release toggles, experiment toggles, ops toggles\n",
    "architecture/feature-toggles/patterns.md": "# Feature Toggles\n\n## Toggle Types\n\n### Release Toggles\nHide incomplete features in production.\n\n```typescript\nif (featureFlags.isEnabled('new-checkout')) {\n  return <NewCheckout />;\n}\nreturn <LegacyCheckout />;\n```\n\n### Experiment Toggles\nA/B testing and gradual rollouts.\n\n```typescript\nconst variant = featureFlags.getVariant('pricing-experiment', userId);\nif (variant === 'new-pricing') {\n  return calculateNewPricing(cart);\n}\nreturn calculateLegacyPricing(cart);\n```\n\n### Ops Toggles\nRuntime operational control.\n\n```typescript\nif (featureFlags.isEnabled('enable-caching')) {\n  return cache.get(key) || fetchFromDatabase(key);\n}\nreturn fetchFromDatabase(key);\n```\n\n## Implementation\n\n```typescript\ninterface FeatureFlags {\n  isEnabled(flag: string, context?: Context): boolean;\n  getVariant(flag: string, userId: string): string;\n}\n\nclass FeatureFlagService implements FeatureFlags {\n  constructor(private config: Map<string, FlagConfig>) {}\n\n  isEnabled(flag: string, context?: Context): boolean {\n    const config = this.config.get(flag);\n    if (!config) return false;\n\n    if (config.percentage) {\n      return this.isInPercentage(context?.userId, config.percentage);\n    }\n\n    return config.enabled;\n  }\n\n  private isInPercentage(userId: string | undefined, percentage: number): boolean {\n    if (!userId) return false;\n    const hash = this.hashUserId(userId);\n    return (hash % 100) < percentage;\n  }\n}\n```\n\n## Best Practices\n\n- Remove toggles after feature is stable\n- Use clear naming conventions\n- Log toggle decisions for debugging\n- Test both toggle states\n- Limit number of active toggles\n- Document toggle purpose and expiration\n",
    "architecture/gui/index.md": "# GUI Architecture Patterns\n\nThis directory contains GUI architecture patterns.\n\n## Available Chunks\n\n- **patterns.md** - MVC, MVP, MVVM, Component Architecture\n",
    "architecture/gui/patterns.md": "# GUI Architecture Patterns\n\n## MVC (Model-View-Controller)\n\n```typescript\n// Model - data and business logic\nclass UserModel {\n  private users: User[] = [];\n\n  getUsers(): User[] { return this.users; }\n  addUser(user: User): void { this.users.push(user); }\n}\n\n// View - presentation\nclass UserView {\n  render(users: User[]): void {\n    console.log('Users:', users);\n  }\n}\n\n// Controller - handles input, coordinates\nclass UserController {\n  constructor(\n    private model: UserModel,\n    private view: UserView\n  ) {}\n\n  handleAddUser(userData: UserData): void {\n    const user = new User(userData);\n    this.model.addUser(user);\n    this.view.render(this.model.getUsers());\n  }\n}\n```\n\n## MVP (Model-View-Presenter)\n\n```typescript\n// View interface - defines what presenter can call\ninterface UserView {\n  showUsers(users: User[]): void;\n  showError(message: string): void;\n}\n\n// Presenter - all presentation logic\nclass UserPresenter {\n  constructor(\n    private view: UserView,\n    private model: UserModel\n  ) {}\n\n  loadUsers(): void {\n    try {\n      const users = this.model.getUsers();\n      this.view.showUsers(users);\n    } catch (error) {\n      this.view.showError('Failed to load users');\n    }\n  }\n}\n\n// View implementation - passive, no logic\nclass UserListView implements UserView {\n  showUsers(users: User[]): void { /* render list */ }\n  showError(message: string): void { /* show error */ }\n}\n```\n\n## MVVM (Model-View-ViewModel)\n\n```typescript\n// ViewModel - exposes observable state\nclass UserViewModel {\n  users = observable<User[]>([]);\n  isLoading = observable(false);\n\n  async loadUsers(): Promise<void> {\n    this.isLoading.set(true);\n    const users = await this.userService.getUsers();\n    this.users.set(users);\n    this.isLoading.set(false);\n  }\n}\n\n// View binds to ViewModel\nconst UserList = observer(({ viewModel }: { viewModel: UserViewModel }) => (\n  <div>\n    {viewModel.isLoading.get() ? (\n      <Spinner />\n    ) : (\n      viewModel.users.get().map(user => <UserItem key={user.id} user={user} />)\n    )}\n  </div>\n));\n```\n\n## Component Architecture (React/Vue)\n\n```typescript\n// Presentational component - no state, just props\nconst UserCard = ({ user, onDelete }: UserCardProps) => (\n  <div className=\"user-card\">\n    <h3>{user.name}</h3>\n    <button onClick={() => onDelete(user.id)}>Delete</button>\n  </div>\n);\n\n// Container component - manages state\nconst UserListContainer = () => {\n  const [users, setUsers] = useState<User[]>([]);\n\n  useEffect(() => {\n    userService.getUsers().then(setUsers);\n  }, []);\n\n  const handleDelete = (id: string) => {\n    userService.deleteUser(id).then(() => {\n      setUsers(users.filter(u => u.id !== id));\n    });\n  };\n\n  return <UserList users={users} onDelete={handleDelete} />;\n};\n```\n\n## Best Practices\n\n- Separate UI logic from business logic\n- Keep views as simple as possible\n- Use unidirectional data flow when possible\n- Make components reusable and testable\n- Choose pattern based on framework and team familiarity\n",
    "architecture/index.md": "# Architecture Patterns\n\nArchitecture-specific guidelines and best practices.\n\n## Available Architectures\n\n- `microservices/` - Microservices architecture\n- `modular-monolith/` - Modular monolith patterns\n- `event-driven/` - Event-driven architecture\n- `layered/` - Layered architecture\n- `hexagonal/` - Hexagonal (Ports & Adapters) architecture\n- `refactor/` - Refactoring strategies\n",
    "architecture/layered/index.md": "# Layered Architecture\n\nThis directory contains layered architecture patterns.\n\n## Available Chunks\n\n- **layers.md** - Presentation, Domain, Data Access layers\n",
    "architecture/layered/layers.md": "# Layered Architecture\n\n## Layer Structure\n\n```\n┌─────────────────────────────────────┐\n│        Presentation Layer           │\n│    (Controllers, Views, APIs)       │\n└───────────────┬─────────────────────┘\n                │\n┌───────────────▼─────────────────────┐\n│          Domain Layer               │\n│    (Business Logic, Services)       │\n└───────────────┬─────────────────────┘\n                │\n┌───────────────▼─────────────────────┐\n│       Data Access Layer             │\n│    (Repositories, ORM, DAOs)        │\n└─────────────────────────────────────┘\n```\n\n## Presentation Layer\n\nHandles user interaction and HTTP requests.\n\n```typescript\nclass OrderController {\n  constructor(private orderService: OrderService) {}\n\n  async createOrder(req: Request, res: Response): Promise<void> {\n    const dto = req.body as CreateOrderDTO;\n    const result = await this.orderService.createOrder(dto);\n    res.status(201).json(result);\n  }\n}\n```\n\n## Domain Layer\n\nContains business logic and rules.\n\n```typescript\nclass OrderService {\n  constructor(\n    private orderRepository: OrderRepository,\n    private productRepository: ProductRepository\n  ) {}\n\n  async createOrder(dto: CreateOrderDTO): Promise<Order> {\n    const products = await this.productRepository.findByIds(dto.productIds);\n\n    if (products.length !== dto.productIds.length) {\n      throw new ProductNotFoundError();\n    }\n\n    const order = new Order(dto.customerId, products);\n    order.calculateTotal();\n\n    await this.orderRepository.save(order);\n    return order;\n  }\n}\n```\n\n## Data Access Layer\n\nHandles persistence operations.\n\n```typescript\nclass OrderRepository {\n  constructor(private db: Database) {}\n\n  async save(order: Order): Promise<void> {\n    await this.db.query(\n      'INSERT INTO orders (id, customer_id, total) VALUES ($1, $2, $3)',\n      [order.id, order.customerId, order.total]\n    );\n  }\n\n  async findById(id: string): Promise<Order | null> {\n    const row = await this.db.queryOne('SELECT * FROM orders WHERE id = $1', [id]);\n    return row ? this.mapToOrder(row) : null;\n  }\n}\n```\n\n## Layer Rules\n\n1. Upper layers depend on lower layers\n2. Never skip layers\n3. Each layer exposes interfaces to the layer above\n4. Domain layer should not depend on data access implementation\n\n## Best Practices\n\n- Keep layers focused on their responsibility\n- Use DTOs to transfer data between layers\n- Define interfaces in domain layer, implement in data access\n- Avoid business logic in presentation or data access layers\n- Consider dependency inversion for testability\n",
    "architecture/microservices/boundaries.md": "# Service Boundaries\n\n## Defining Service Boundaries\n\nEach service should own a specific business capability:\n\n```\n✅ Good Boundaries:\n- User Service: Authentication, profiles, preferences\n- Order Service: Order processing, fulfillment\n- Payment Service: Payment processing, billing\n- Notification Service: Emails, SMS, push notifications\n\n❌ Bad Boundaries:\n- Data Access Service (technical, not business)\n- Utility Service (too generic)\n- God Service (does everything)\n```\n\n## Bounded Contexts\n\nUse Domain-Driven Design to identify boundaries:\n\n- Each service represents a bounded context\n- Services are organized around business domains\n- Clear ownership of data and logic\n- Services should be independently deployable\n\n## Ownership Rules\n\n**Each service:**\n- Owns its own database (no shared databases)\n- Owns its domain logic\n- Exposes well-defined APIs\n- Can be developed by autonomous teams\n\n## Communication Rules\n\n**Avoid:**\n- Direct database access between services\n- Chatty communication (N+1 service calls)\n- Tight coupling through shared libraries\n\n**Prefer:**\n- API-based communication\n- Event-driven for data synchronization\n- Async messaging where possible\n\n## Data Ownership\n\n```typescript\n// ✅ Good - Service owns its data\nclass OrderService {\n  private orderRepository: OrderRepository;\n\n  async createOrder(data: CreateOrderDTO): Promise<Order> {\n    // Order service owns order data\n    const order = await this.orderRepository.save(data);\n\n    // Publish event for other services\n    await this.eventBus.publish('order.created', {\n      orderId: order.id,\n      userId: order.userId,\n      total: order.total\n    });\n\n    return order;\n  }\n}\n\n// ❌ Bad - Direct access to another service's database\nclass OrderService {\n  async createOrder(data: CreateOrderDTO): Promise<Order> {\n    // Don't do this!\n    const user = await userDatabase.users.findOne({ id: data.userId });\n  }\n}\n```\n\n## Sizing Guidelines\n\nKeep services:\n- Small enough to be maintained by a small team (2-3 developers)\n- Large enough to provide business value\n- Focused on a single bounded context\n- Independently deployable and scalable\n",
    "architecture/microservices/communication.md": "# Microservices Communication\n\n## Synchronous vs Asynchronous\n\n```typescript\n// ⚠️ Synchronous creates coupling and multiplicative downtime\n// If Service A calls B calls C, any failure breaks the chain\n\n// ✅ Prefer asynchronous messaging for most inter-service communication\n// Limit synchronous calls to one per user request\n\n// Async messaging example\nawait eventBus.publish('order.created', {\n  orderId: order.id,\n  userId: order.userId,\n  items: order.items\n});\n\n// Other services subscribe and process independently\neventBus.subscribe('order.created', async (event) => {\n  await inventoryService.reserveItems(event.items);\n});\n```\n\n## API-Based Communication\n\n```typescript\n// ✅ Well-defined REST APIs between services\n// Order Service calling User Service\nclass UserServiceClient {\n  async getUser(userId: string): Promise<User> {\n    const response = await this.http.get(`${this.baseUrl}/users/${userId}`);\n    return response.data;\n  }\n}\n\n// ✅ Use circuit breaker for resilience\nconst userBreaker = new CircuitBreaker({ threshold: 5, timeout: 60000 });\n\nasync function getUserSafe(userId: string): Promise<User | null> {\n  try {\n    return await userBreaker.execute(() => userClient.getUser(userId));\n  } catch (error) {\n    return getCachedUser(userId); // Fallback\n  }\n}\n```\n\n## Event-Driven Integration\n\n```typescript\n// ✅ Publish events for state changes\nclass OrderService {\n  async createOrder(data: CreateOrderDTO): Promise<Order> {\n    const order = await this.orderRepository.save(data);\n\n    // Publish event - other services react asynchronously\n    await this.eventBus.publish('order.created', {\n      orderId: order.id,\n      userId: order.userId,\n      total: order.total,\n      timestamp: new Date()\n    });\n\n    return order;\n  }\n}\n\n// ✅ Consumers handle events independently\nclass NotificationService {\n  @EventHandler('order.created')\n  async handleOrderCreated(event: OrderCreatedEvent) {\n    await this.sendOrderConfirmation(event.userId, event.orderId);\n  }\n}\n\nclass InventoryService {\n  @EventHandler('order.created')\n  async handleOrderCreated(event: OrderCreatedEvent) {\n    await this.reserveInventory(event.orderId);\n  }\n}\n```\n\n## Tolerant Reader Pattern\n\n```typescript\n// ✅ Don't fail on unknown fields - enables independent evolution\ninterface UserResponse {\n  id: string;\n  name: string;\n  // Ignore additional fields from newer API versions\n  [key: string]: unknown;\n}\n\n// ✅ Use sensible defaults for missing optional fields\nfunction parseUser(data: unknown): User {\n  return {\n    id: data.id,\n    name: data.name,\n    role: data.role ?? 'user', // Default if missing\n    avatar: data.avatar ?? null\n  };\n}\n```\n\n## Anti-Patterns\n\n```typescript\n// ❌ Chatty communication (N+1 service calls)\nfor (const orderId of orderIds) {\n  const order = await orderService.getOrder(orderId); // N calls\n}\n\n// ✅ Batch requests\nconst orders = await orderService.getOrders(orderIds); // 1 call\n\n// ❌ Tight coupling via shared databases\n// Service A directly queries Service B's tables\n\n// ✅ API-based communication\nconst userData = await userServiceClient.getUser(userId);\n```\n",
    "architecture/microservices/data.md": "# Microservices Data Management\n\n## Database Per Service\n\n```\nEach service owns its database:\n\n✅ Order Service → order_db (PostgreSQL)\n✅ User Service → user_db (PostgreSQL)\n✅ Catalog Service → catalog_db (MongoDB)\n✅ Search Service → search_index (Elasticsearch)\n\n❌ Never share databases between services\n❌ Never query another service's tables directly\n```\n\n## Polyglot Persistence\n\n```typescript\n// Each service uses the best database for its needs\n\n// User Service - relational data, ACID transactions\nclass UserRepository {\n  constructor(private postgres: PostgresClient) {}\n\n  async create(user: User): Promise<User> {\n    return this.postgres.query('INSERT INTO users...');\n  }\n}\n\n// Catalog Service - flexible document structure\nclass ProductRepository {\n  constructor(private mongo: MongoClient) {}\n\n  async create(product: Product): Promise<Product> {\n    return this.mongo.collection('products').insertOne(product);\n  }\n}\n\n// Analytics Service - time-series data\nclass MetricsRepository {\n  constructor(private influx: InfluxDBClient) {}\n\n  async record(metric: Metric): Promise<void> {\n    await this.influx.writePoints([metric]);\n  }\n}\n```\n\n## Eventual Consistency\n\n```typescript\n// ✅ Embrace eventual consistency for cross-service data\n\n// Order created - publish event\nawait orderRepository.save(order);\nawait eventBus.publish('order.created', order);\n\n// Inventory service processes asynchronously\n// Data may be temporarily inconsistent - that's OK\n\n// ✅ Use compensating actions for failures\nasync function processOrder(order: Order): Promise<void> {\n  try {\n    await inventoryService.reserve(order.items);\n    await paymentService.charge(order.total);\n  } catch (error) {\n    // Compensate: release reserved inventory\n    await inventoryService.release(order.items);\n    throw error;\n  }\n}\n```\n\n## Data Synchronization Patterns\n\n```typescript\n// Pattern: Event Sourcing for cross-service data\nclass OrderProjector {\n  @EventHandler('product.updated')\n  async handleProductUpdate(event: ProductUpdatedEvent) {\n    // Update local cache of product data\n    await this.productCache.set(event.productId, {\n      name: event.name,\n      price: event.price\n    });\n  }\n}\n\n// Pattern: Saga for distributed transactions\nclass OrderSaga {\n  async execute(order: Order): Promise<void> {\n    const saga = new Saga();\n\n    saga.addStep({\n      action: () => inventoryService.reserve(order.items),\n      compensate: () => inventoryService.release(order.items)\n    });\n\n    saga.addStep({\n      action: () => paymentService.charge(order.total),\n      compensate: () => paymentService.refund(order.paymentId)\n    });\n\n    await saga.run();\n  }\n}\n```\n\n## Data Ownership\n\n```typescript\n// ✅ Each service is the source of truth for its data\nclass UserService {\n  // Only User Service can create/update users\n  async updateEmail(userId: string, email: string): Promise<User> {\n    const user = await this.userRepository.update(userId, { email });\n\n    // Notify other services of the change\n    await this.eventBus.publish('user.email.changed', {\n      userId,\n      newEmail: email\n    });\n\n    return user;\n  }\n}\n\n// Other services maintain their own copies (projections)\nclass OrderService {\n  @EventHandler('user.email.changed')\n  async syncUserEmail(event: UserEmailChangedEvent) {\n    // Update local cache, not the source data\n    await this.userCache.set(event.userId, { email: event.newEmail });\n  }\n}\n```\n",
    "architecture/microservices/index.md": "# Microservices Architecture\n\nGuidelines for building microservices.\n\n## Chunks\n\n- `boundaries.md` - Defining service boundaries\n- `communication.md` - Inter-service communication\n- `data.md` - Data management and consistency\n- `deployment.md` - Deployment strategies\n- `resilience.md` - Resilience patterns\n",
    "architecture/microservices/resilience.md": "# Microservices Resilience\n\n## Circuit Breaker Pattern\n\n```typescript\nenum CircuitState {\n  CLOSED = 'CLOSED',     // Normal operation\n  OPEN = 'OPEN',         // Failing, reject calls\n  HALF_OPEN = 'HALF_OPEN' // Testing recovery\n}\n\nclass CircuitBreaker {\n  private state = CircuitState.CLOSED;\n  private failures = 0;\n  private nextRetry = 0;\n\n  async execute<T>(operation: () => Promise<T>): Promise<T> {\n    if (this.state === CircuitState.OPEN) {\n      if (Date.now() < this.nextRetry) {\n        throw new Error('Circuit breaker OPEN');\n      }\n      this.state = CircuitState.HALF_OPEN;\n    }\n\n    try {\n      const result = await operation();\n      this.onSuccess();\n      return result;\n    } catch (error) {\n      this.onFailure();\n      throw error;\n    }\n  }\n\n  private onSuccess() {\n    this.failures = 0;\n    this.state = CircuitState.CLOSED;\n  }\n\n  private onFailure() {\n    this.failures++;\n    if (this.failures >= 5) {\n      this.state = CircuitState.OPEN;\n      this.nextRetry = Date.now() + 60000;\n    }\n  }\n}\n```\n\n## Retry with Exponential Backoff\n\n```typescript\nasync function retry<T>(\n  operation: () => Promise<T>,\n  maxAttempts: number = 3,\n  baseDelay: number = 1000\n): Promise<T> {\n  for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n    try {\n      return await operation();\n    } catch (error) {\n      if (attempt === maxAttempts) throw error;\n\n      const delay = baseDelay * Math.pow(2, attempt - 1);\n      const jitter = Math.random() * 1000;\n      await sleep(delay + jitter);\n    }\n  }\n  throw new Error('Max retries exceeded');\n}\n```\n\n## Bulkhead Pattern\n\n```typescript\n// Isolate resources to prevent cascading failures\nclass Bulkhead {\n  private active = 0;\n\n  constructor(private maxConcurrent: number) {}\n\n  async execute<T>(operation: () => Promise<T>): Promise<T> {\n    if (this.active >= this.maxConcurrent) {\n      throw new Error('Bulkhead limit reached');\n    }\n\n    this.active++;\n    try {\n      return await operation();\n    } finally {\n      this.active--;\n    }\n  }\n}\n\n// Separate bulkheads per dependency\nconst paymentBulkhead = new Bulkhead(5);\nconst emailBulkhead = new Bulkhead(10);\n```\n\n## Timeouts\n\n```typescript\nasync function withTimeout<T>(\n  promise: Promise<T>,\n  timeoutMs: number\n): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<T>((_, reject) =>\n      setTimeout(() => reject(new Error('Timeout')), timeoutMs)\n    )\n  ]);\n}\n\n// Always set timeouts for external calls\nconst user = await withTimeout(userService.getUser(id), 5000);\n```\n\n## Graceful Degradation\n\n```typescript\nasync function getProductRecommendations(userId: string) {\n  try {\n    return await recommendationService.getPersonalized(userId);\n  } catch (error) {\n    // Fallback to cached popular items\n    console.warn('Recommendation service unavailable');\n    return await getPopularProducts();\n  }\n}\n\n// Partial responses instead of complete failure\nasync function getDashboard(userId: string) {\n  const [user, orders, stats] = await Promise.allSettled([\n    getUser(userId),\n    getOrders(userId),\n    getStats(userId)\n  ]);\n\n  return {\n    user: user.status === 'fulfilled' ? user.value : null,\n    orders: orders.status === 'fulfilled' ? orders.value : [],\n    stats: stats.status === 'fulfilled' ? stats.value : null\n  };\n}\n```\n\n## Health Checks\n\n```typescript\napp.get('/health', async (req, res) => {\n  const checks = await Promise.allSettled([\n    checkDatabase(),\n    checkRedis(),\n    checkExternalAPI()\n  ]);\n\n  const healthy = checks.every(c => c.status === 'fulfilled');\n\n  res.status(healthy ? 200 : 503).json({\n    status: healthy ? 'healthy' : 'degraded',\n    checks: {\n      database: checks[0].status,\n      redis: checks[1].status,\n      externalAPI: checks[2].status\n    }\n  });\n});\n```\n",
    "architecture/modular-monolith/boundaries.md": "# Modular Monolith Boundaries\n\n## High Cohesion, Low Coupling\n\n```typescript\n// ❌ Bad: Tight coupling - direct repository access\n@Injectable()\nexport class OrderService {\n  constructor(private userRepo: UserRepository) {} // Crosses module boundary\n\n  async createOrder(userId: string) {\n    const user = await this.userRepo.findById(userId); // Direct access\n  }\n}\n\n// ✅ Good: Loose coupling via service\n@Injectable()\nexport class OrderService {\n  constructor(private userService: UserService) {} // Service dependency\n\n  async createOrder(userId: string) {\n    const user = await this.userService.findById(userId); // Through public API\n  }\n}\n```\n\n## No Direct Cross-Module Database Access\n\n```typescript\n// ❌ Never query another module's tables directly\nclass BookingService {\n  async createBooking(data: CreateBookingDto) {\n    const user = await this.prisma.user.findUnique({ where: { id: data.userId } });\n    // This bypasses the User module!\n  }\n}\n\n// ✅ Use the module's public service API\nclass BookingService {\n  constructor(private userService: UserService) {}\n\n  async createBooking(data: CreateBookingDto) {\n    const user = await this.userService.findById(data.userId);\n    // Properly goes through User module\n  }\n}\n```\n\n## Separated Interface Pattern\n\n```typescript\n// Define interface in consuming module\n// modules/order/interfaces/user-provider.interface.ts\nexport interface UserProvider {\n  findById(id: string): Promise<User>;\n  validateUser(id: string): Promise<boolean>;\n}\n\n// Implement in providing module\n// modules/user/user.service.ts\n@Injectable()\nexport class UserService implements UserProvider {\n  async findById(id: string): Promise<User> {\n    return this.userRepo.findById(id);\n  }\n\n  async validateUser(id: string): Promise<boolean> {\n    const user = await this.findById(id);\n    return user && user.isActive;\n  }\n}\n```\n\n## Domain Events for Loose Coupling\n\n```typescript\n// ✅ Publish events instead of direct calls\n@Injectable()\nexport class UserService {\n  constructor(private eventEmitter: EventEmitter2) {}\n\n  async createUser(dto: CreateUserDto): Promise<User> {\n    const user = await this.userRepo.create(dto);\n\n    this.eventEmitter.emit('user.created', new UserCreatedEvent(user.id, user.email));\n\n    return user;\n  }\n}\n\n// Other modules subscribe to events\n@Injectable()\nexport class NotificationListener {\n  @OnEvent('user.created')\n  async handleUserCreated(event: UserCreatedEvent) {\n    await this.notificationService.sendWelcomeEmail(event.email);\n  }\n}\n```\n\n## Handling Circular Dependencies\n\n```typescript\n// Use forwardRef() when modules depend on each other\n@Module({\n  imports: [\n    forwardRef(() => AuthModule), // Break circular dependency\n    UserModule,\n  ],\n})\nexport class UserModule {}\n\n@Module({\n  imports: [\n    forwardRef(() => UserModule),\n  ],\n})\nexport class AuthModule {}\n```\n\n## Export Only What's Necessary\n\n```typescript\n@Module({\n  providers: [\n    UserService,        // Public service\n    UserRepository,     // Internal\n    PasswordHasher,     // Internal\n  ],\n  exports: [UserService], // Only export the service, not internals\n})\nexport class UserModule {}\n```\n",
    "architecture/modular-monolith/structure.md": "# Modular Monolith Structure\n\n## Project Organization\n\n```\nproject-root/\n├── apps/\n│   └── api/\n│       ├── src/\n│       │   ├── app/              # Application bootstrap\n│       │   ├── modules/          # Business modules\n│       │   │   ├── auth/\n│       │   │   ├── user/\n│       │   │   ├── booking/\n│       │   │   ├── payment/\n│       │   │   └── notification/\n│       │   ├── common/           # Shared infrastructure\n│       │   │   ├── decorators/\n│       │   │   ├── guards/\n│       │   │   └── interceptors/\n│       │   └── prisma/           # Database service\n│       └── main.ts\n├── libs/                         # Shared libraries\n│   └── shared-types/\n└── package.json\n```\n\n## Module Structure\n\n```\nmodules/booking/\n├── entities/              # Domain models and DTOs\n│   ├── booking.entity.ts\n│   ├── create-booking.dto.ts\n│   └── booking-response.dto.ts\n├── repositories/          # Data access layer\n│   └── booking.repository.ts\n├── services/              # Business logic\n│   ├── booking.service.ts\n│   └── availability.service.ts\n├── controllers/           # HTTP/API layer\n│   └── bookings.controller.ts\n└── booking.module.ts      # Module definition\n```\n\n## Module Definition\n\n```typescript\n@Module({\n  imports: [\n    PrismaModule,\n    forwardRef(() => AuthModule),\n    NotificationsModule,\n  ],\n  controllers: [BookingsController],\n  providers: [\n    BookingService,\n    AvailabilityService,\n    BookingRepository,\n  ],\n  exports: [BookingService], // Only export public API\n})\nexport class BookingsModule {}\n```\n\n## Layered Architecture Within Modules\n\n```typescript\n// Controller - HTTP layer\n@Controller('api/v1/bookings')\nexport class BookingsController {\n  constructor(private bookingService: BookingService) {}\n\n  @Get('calendar')\n  async getCalendarBookings(@Query() dto: GetBookingsDto) {\n    return this.bookingService.getBookingsForCalendar(dto);\n  }\n}\n\n// Service - Business logic\n@Injectable()\nexport class BookingService {\n  constructor(\n    private bookingRepository: BookingRepository,\n    private availabilityService: AvailabilityService,\n  ) {}\n\n  async getBookingsForCalendar(dto: GetBookingsDto) {\n    const bookings = await this.bookingRepository.findByDateRange(\n      dto.startDate,\n      dto.endDate\n    );\n    return bookings.map(this.mapToCalendarDto);\n  }\n}\n\n// Repository - Data access\n@Injectable()\nexport class BookingRepository {\n  constructor(private prisma: PrismaService) {}\n\n  async findByDateRange(start: Date, end: Date) {\n    return this.prisma.booking.findMany({\n      where: {\n        startTime: { gte: start },\n        endTime: { lte: end }\n      }\n    });\n  }\n}\n```\n\n## Shared Infrastructure\n\n```typescript\n// common/guards/jwt-auth.guard.ts\n@Injectable()\nexport class JwtAuthGuard extends AuthGuard('jwt') {\n  canActivate(context: ExecutionContext) {\n    const isPublic = this.reflector.get<boolean>('isPublic', context.getHandler());\n    return isPublic ? true : super.canActivate(context);\n  }\n}\n\n// common/decorators/current-user.decorator.ts\nexport const CurrentUser = createParamDecorator(\n  (data: unknown, ctx: ExecutionContext) => {\n    return ctx.switchToHttp().getRequest().user;\n  }\n);\n```\n",
    "architecture/serverless/index.md": "# Serverless Architecture\n\nThis directory contains serverless architecture patterns.\n\n## Available Chunks\n\n- **patterns.md** - FaaS, BaaS, cold starts, best practices\n",
    "architecture/serverless/patterns.md": "# Serverless Architecture\n\n## Key Principles\n\n- **Stateless functions**: Each invocation is independent\n- **Event-driven**: Functions triggered by events\n- **Auto-scaling**: Platform handles scaling\n- **Pay-per-use**: Billed by execution\n\n## Function Design\n\n```typescript\n// Handler pattern\nexport async function handler(\n  event: APIGatewayEvent,\n  context: Context\n): Promise<APIGatewayProxyResult> {\n  try {\n    const body = JSON.parse(event.body || '{}');\n    const result = await processOrder(body);\n\n    return {\n      statusCode: 200,\n      body: JSON.stringify(result)\n    };\n  } catch (error) {\n    return {\n      statusCode: 500,\n      body: JSON.stringify({ error: 'Internal error' })\n    };\n  }\n}\n```\n\n## Cold Start Optimization\n\n```typescript\n// Initialize outside handler (reused across invocations)\nconst dbPool = createPool(process.env.DATABASE_URL);\n\nexport async function handler(event: Event): Promise<Response> {\n  // Use cached connection\n  const result = await dbPool.query('SELECT * FROM orders');\n  return { statusCode: 200, body: JSON.stringify(result) };\n}\n```\n\n## State Management\n\n```typescript\n// Use external state stores\nclass OrderService {\n  constructor(\n    private dynamodb: DynamoDB,\n    private redis: Redis\n  ) {}\n\n  async getOrder(id: string): Promise<Order> {\n    // Check cache first\n    const cached = await this.redis.get(`order:${id}`);\n    if (cached) return JSON.parse(cached);\n\n    // Fall back to database\n    const result = await this.dynamodb.get({ Key: { id } });\n    await this.redis.set(`order:${id}`, JSON.stringify(result));\n    return result;\n  }\n}\n```\n\n## Best Practices\n\n- Keep functions small and focused\n- Use environment variables for configuration\n- Minimize dependencies to reduce cold start time\n- Handle timeouts gracefully\n- Use async/await for all I/O operations\n- Implement idempotency for event handlers\n- Log structured data for observability\n- Set appropriate memory and timeout limits\n",
    "architecture/solid/index.md": "# SOLID Principles\n\nThis directory contains SOLID design principles.\n\n## Available Chunks\n\n- **principles.md** - SRP, OCP, LSP, ISP, DIP with TypeScript examples\n",
    "architecture/solid/principles.md": "# SOLID Principles\n\n## Single Responsibility Principle (SRP)\n\nA class should have only one reason to change.\n\n**Bad:**\n```typescript\nclass UserService {\n  createUser(data: UserData): User { /* ... */ }\n  sendWelcomeEmail(user: User): void { /* ... */ }\n  generateReport(users: User[]): Report { /* ... */ }\n}\n```\n\n**Good:**\n```typescript\nclass UserService {\n  createUser(data: UserData): User { /* ... */ }\n}\n\nclass EmailService {\n  sendWelcomeEmail(user: User): void { /* ... */ }\n}\n\nclass ReportService {\n  generateUserReport(users: User[]): Report { /* ... */ }\n}\n```\n\n## Open/Closed Principle (OCP)\n\nOpen for extension, closed for modification.\n\n**Bad:**\n```typescript\nclass PaymentProcessor {\n  process(payment: Payment): void {\n    if (payment.type === 'credit') { /* credit logic */ }\n    else if (payment.type === 'paypal') { /* paypal logic */ }\n    // Must modify class to add new payment types\n  }\n}\n```\n\n**Good:**\n```typescript\ninterface PaymentHandler {\n  process(payment: Payment): void;\n}\n\nclass CreditCardHandler implements PaymentHandler {\n  process(payment: Payment): void { /* credit logic */ }\n}\n\nclass PayPalHandler implements PaymentHandler {\n  process(payment: Payment): void { /* paypal logic */ }\n}\n\nclass PaymentProcessor {\n  constructor(private handlers: Map<string, PaymentHandler>) {}\n\n  process(payment: Payment): void {\n    this.handlers.get(payment.type)?.process(payment);\n  }\n}\n```\n\n## Liskov Substitution Principle (LSP)\n\nSubtypes must be substitutable for their base types.\n\n**Bad:**\n```typescript\nclass Bird {\n  fly(): void { /* flying logic */ }\n}\n\nclass Penguin extends Bird {\n  fly(): void {\n    throw new Error(\"Penguins can't fly!\"); // Violates LSP\n  }\n}\n```\n\n**Good:**\n```typescript\ninterface Bird {\n  move(): void;\n}\n\nclass FlyingBird implements Bird {\n  move(): void { this.fly(); }\n  private fly(): void { /* flying logic */ }\n}\n\nclass Penguin implements Bird {\n  move(): void { this.swim(); }\n  private swim(): void { /* swimming logic */ }\n}\n```\n\n## Interface Segregation Principle (ISP)\n\nClients shouldn't depend on interfaces they don't use.\n\n**Bad:**\n```typescript\ninterface Worker {\n  work(): void;\n  eat(): void;\n  sleep(): void;\n}\n\nclass Robot implements Worker {\n  work(): void { /* ... */ }\n  eat(): void { throw new Error(\"Robots don't eat\"); }\n  sleep(): void { throw new Error(\"Robots don't sleep\"); }\n}\n```\n\n**Good:**\n```typescript\ninterface Workable {\n  work(): void;\n}\n\ninterface Eatable {\n  eat(): void;\n}\n\ninterface Sleepable {\n  sleep(): void;\n}\n\nclass Human implements Workable, Eatable, Sleepable {\n  work(): void { /* ... */ }\n  eat(): void { /* ... */ }\n  sleep(): void { /* ... */ }\n}\n\nclass Robot implements Workable {\n  work(): void { /* ... */ }\n}\n```\n\n## Dependency Inversion Principle (DIP)\n\nDepend on abstractions, not concretions.\n\n**Bad:**\n```typescript\nclass UserService {\n  private database = new MySQLDatabase();\n\n  getUser(id: string): User {\n    return this.database.query(`SELECT * FROM users WHERE id = '${id}'`);\n  }\n}\n```\n\n**Good:**\n```typescript\ninterface Database {\n  query(sql: string): any;\n}\n\nclass UserService {\n  constructor(private database: Database) {}\n\n  getUser(id: string): User {\n    return this.database.query(`SELECT * FROM users WHERE id = '${id}'`);\n  }\n}\n\n// Can inject any database implementation\nconst userService = new UserService(new MySQLDatabase());\nconst testService = new UserService(new InMemoryDatabase());\n```\n\n## Best Practices\n\n- Apply SRP at class, method, and module levels\n- Use interfaces and dependency injection for flexibility\n- Prefer composition over inheritance\n- Design small, focused interfaces\n- Inject dependencies rather than creating them internally\n",
    "database/design-patterns.md": "# Database Design Patterns\n\n## Schema Design\n\n### Normalization\nReduce redundancy, maintain integrity.\n\n```sql\n-- Normalized\nCREATE TABLE users (id, name, email);\nCREATE TABLE orders (id, user_id REFERENCES users(id), total);\nCREATE TABLE order_items (id, order_id REFERENCES orders(id), product_id, qty);\n```\n\n### Denormalization\nTrade redundancy for read performance.\n\n```sql\n-- Denormalized for read performance\nCREATE TABLE order_summary (\n  id, user_id, user_name, user_email,\n  total, item_count, created_at\n);\n```\n\n## Common Patterns\n\n### Soft Deletes\n```sql\nALTER TABLE users ADD COLUMN deleted_at TIMESTAMP NULL;\n\n-- Query active users\nSELECT * FROM users WHERE deleted_at IS NULL;\n```\n\n### Audit Trail\n```sql\nCREATE TABLE audit_log (\n  id SERIAL PRIMARY KEY,\n  table_name VARCHAR(100),\n  record_id VARCHAR(100),\n  action VARCHAR(20),\n  old_values JSONB,\n  new_values JSONB,\n  changed_by VARCHAR(100),\n  changed_at TIMESTAMP DEFAULT NOW()\n);\n```\n\n### Polymorphic Associations\n```sql\nCREATE TABLE comments (\n  id SERIAL PRIMARY KEY,\n  body TEXT,\n  commentable_type VARCHAR(50), -- 'post', 'image', 'video'\n  commentable_id INTEGER,\n  created_at TIMESTAMP\n);\n```\n\n## Best Practices\n\n- Use appropriate data types\n- Add indexes for frequently queried columns\n- Use foreign keys for referential integrity\n- Consider partitioning for large tables\n- Plan for schema migrations\n- Document schema decisions\n",
    "database/index.md": "# Database Guidelines\n\nThis directory contains database design and optimization patterns.\n\n## Available Chunks\n\n- **schema.md** - Naming conventions, data types, constraints, normalization\n- **indexing.md** - When to index, composite indexes, query optimization\n",
    "database/indexing.md": "# Database Indexing\n\n## When to Add Indexes\n\n```sql\n-- ✅ Columns in WHERE clauses\nCREATE INDEX idx_users_email ON users(email);\n\n-- ✅ Foreign key columns\nCREATE INDEX idx_orders_user_id ON orders(user_id);\n\n-- ✅ Columns used in ORDER BY\nCREATE INDEX idx_products_created_at ON products(created_at DESC);\n\n-- ✅ Columns used in JOIN conditions\nCREATE INDEX idx_order_items_product_id ON order_items(product_id);\n```\n\n## Composite Indexes\n\n```sql\n-- Order matters! Put most selective column first\nCREATE INDEX idx_orders_user_status ON orders(user_id, status);\n\n-- This index helps with:\nSELECT * FROM orders WHERE user_id = 123;\nSELECT * FROM orders WHERE user_id = 123 AND status = 'pending';\n\n-- But NOT with:\nSELECT * FROM orders WHERE status = 'pending'; -- Can't use index\n```\n\n## Partial Indexes\n\n```sql\n-- Index only rows matching condition\nCREATE INDEX idx_active_users ON users(email) WHERE is_active = true;\n\n-- Smaller index, faster queries on active users\nSELECT * FROM users WHERE email = 'x@y.com' AND is_active = true;\n```\n\n## Unique Indexes\n\n```sql\n-- Enforces uniqueness and improves lookup\nCREATE UNIQUE INDEX idx_users_email ON users(email);\n\n-- Multi-column unique\nCREATE UNIQUE INDEX idx_unique_order_item ON order_items(order_id, product_id);\n```\n\n## Index Types\n\n```sql\n-- B-tree (default): =, <, >, <=, >=, BETWEEN\nCREATE INDEX idx_products_price ON products(price);\n\n-- Hash: Only equality (=)\nCREATE INDEX idx_users_id_hash ON users USING hash (id);\n\n-- GIN: Arrays, JSONB, full-text search\nCREATE INDEX idx_products_tags ON products USING gin (tags);\n\n-- GiST: Geometric data, range queries\nCREATE INDEX idx_locations ON places USING gist (location);\n```\n\n## Analyze Query Performance\n\n```sql\n-- EXPLAIN ANALYZE shows actual execution\nEXPLAIN ANALYZE\nSELECT * FROM users WHERE email = 'test@example.com';\n\n-- Look for:\n-- ✅ Index Scan / Index Only Scan (good)\n-- ❌ Seq Scan on large tables (bad)\n-- ❌ High \"actual time\" values (slow)\n```\n\n## Index Maintenance\n\n```sql\n-- Monitor index usage (PostgreSQL)\nSELECT\n  schemaname, tablename, indexname, idx_scan, idx_tup_read\nFROM pg_stat_user_indexes\nORDER BY idx_scan ASC;\n\n-- Remove unused indexes (0 scans)\nDROP INDEX IF EXISTS unused_index_name;\n\n-- Rebuild bloated indexes\nREINDEX INDEX index_name;\n```\n\n## Anti-Patterns\n\n```sql\n-- ❌ Indexing every column\n-- Slows down INSERT/UPDATE, wastes space\n\n-- ❌ Indexes on low-cardinality columns\n-- Boolean columns rarely benefit from indexes\n\n-- ❌ Functions on indexed columns\n-- SELECT * FROM users WHERE LOWER(email) = 'x'; -- Can't use index!\n\n-- ✅ Use expression index instead\nCREATE INDEX idx_users_email_lower ON users(LOWER(email));\n```\n\n## Connection Pooling\n\n```typescript\n// ❌ New connection per query\nconst getUser = async (id: string) => {\n  const conn = await createConnection(); // Expensive!\n  const user = await conn.query('SELECT * FROM users WHERE id = ?', [id]);\n  await conn.close();\n  return user;\n};\n\n// ✅ Use connection pool\nconst pool = new Pool({ max: 20, idleTimeoutMillis: 30000 });\n\nconst getUser = async (id: string) => {\n  const client = await pool.connect();\n  try {\n    return await client.query('SELECT * FROM users WHERE id = $1', [id]);\n  } finally {\n    client.release(); // Return to pool\n  }\n};\n```\n",
    "database/schema.md": "# Database Schema Design\n\n## Naming Conventions\n\n```sql\n-- Tables: plural, snake_case\nCREATE TABLE users (...);\nCREATE TABLE order_items (...);\n\n-- Columns: singular, snake_case\nuser_id, created_at, is_active\n\n-- Primary keys: id\nid SERIAL PRIMARY KEY\n\n-- Foreign keys: singular_table_id\nuser_id REFERENCES users(id)\n```\n\n## Primary Keys\n\n```sql\n-- ✅ Auto-incrementing integer (simple cases)\nid SERIAL PRIMARY KEY\n\n-- ✅ UUID for distributed systems\nid UUID PRIMARY KEY DEFAULT gen_random_uuid()\n\n-- ❌ Avoid composite primary keys when possible\n-- They complicate joins and foreign keys\n```\n\n## Essential Columns\n\n```sql\n-- ✅ Standard audit columns\nCREATE TABLE products (\n  id SERIAL PRIMARY KEY,\n  name VARCHAR(255) NOT NULL,\n  price DECIMAL(10,2) NOT NULL,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  deleted_at TIMESTAMP NULL  -- Soft delete\n);\n\n-- ✅ Version column for optimistic locking\nversion INTEGER DEFAULT 1\n```\n\n## Relationships\n\n```sql\n-- One-to-Many: Foreign key on \"many\" side\nCREATE TABLE orders (\n  id SERIAL PRIMARY KEY,\n  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,\n  total DECIMAL(10,2)\n);\n\n-- Many-to-Many: Junction table\nCREATE TABLE order_items (\n  order_id INTEGER REFERENCES orders(id) ON DELETE CASCADE,\n  product_id INTEGER REFERENCES products(id),\n  quantity INTEGER NOT NULL,\n  PRIMARY KEY (order_id, product_id)\n);\n```\n\n## Constraints\n\n```sql\n-- ✅ NOT NULL for required fields\nemail VARCHAR(255) NOT NULL\n\n-- ✅ UNIQUE constraints\nemail VARCHAR(255) UNIQUE NOT NULL\n\n-- ✅ CHECK constraints for validation\nage INTEGER CHECK (age >= 0 AND age <= 150)\nstatus VARCHAR(20) CHECK (status IN ('pending', 'active', 'cancelled'))\n\n-- ✅ DEFAULT values\nis_active BOOLEAN DEFAULT true\nrole VARCHAR(20) DEFAULT 'user'\n```\n\n## Data Types\n\n```sql\n-- Strings\nVARCHAR(255) -- Variable length, max 255\nTEXT         -- Unlimited length\n\n-- Numbers\nINTEGER      -- Whole numbers\nBIGINT       -- Large whole numbers\nDECIMAL(10,2) -- Exact decimals (money)\nREAL/DOUBLE  -- Approximate decimals (scientific)\n\n-- Dates/Times\nTIMESTAMP    -- Date and time\nDATE         -- Date only\nINTERVAL     -- Duration\n\n-- Other\nBOOLEAN      -- true/false\nUUID         -- Unique identifier\nJSONB        -- JSON with indexing (PostgreSQL)\n```\n\n## Normalization Guidelines\n\n```sql\n-- ✅ 1NF: Atomic values, no repeating groups\n-- ❌ Bad: tags VARCHAR = 'tag1,tag2,tag3'\n-- ✅ Good: Separate tags table\n\n-- ✅ 2NF: No partial dependencies\n-- All non-key columns depend on entire primary key\n\n-- ✅ 3NF: No transitive dependencies\n-- Non-key columns don't depend on other non-key columns\n```\n\n## Denormalization (When Appropriate)\n\n```sql\n-- Cache computed values for read performance\nCREATE TABLE orders (\n  id SERIAL PRIMARY KEY,\n  user_id INTEGER REFERENCES users(id),\n  items_count INTEGER DEFAULT 0,  -- Denormalized\n  total DECIMAL(10,2) DEFAULT 0   -- Denormalized\n);\n\n-- Update via triggers or application logic\n```\n",
    "devops/ci-cd.md": "# CI/CD Practices\n\n## Continuous Integration\n\nRun on every commit:\n\n```yaml\n# .github/workflows/ci.yml\nname: CI\non: [push, pull_request]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n          cache: 'npm'\n      - run: npm ci\n      - run: npm run lint\n      - run: npm run typecheck\n      - run: npm test\n      - run: npm run build\n```\n\n## Continuous Deployment\n\nDeploy automatically after CI passes:\n\n```yaml\ndeploy:\n  needs: build\n  if: github.ref == 'refs/heads/main'\n  runs-on: ubuntu-latest\n  steps:\n    - uses: actions/checkout@v4\n    - run: npm ci\n    - run: npm run build\n    - run: npm run deploy\n      env:\n        DEPLOY_TOKEN: ${{ secrets.DEPLOY_TOKEN }}\n```\n\n## Deployment Strategies\n\n### Blue-Green Deployment\nRun two identical environments, switch traffic instantly.\n\n### Canary Releases\nRoute small percentage of traffic to new version first.\n\n### Rolling Updates\nGradually replace instances with new version.\n\n## Best Practices\n\n- Run fast tests first, slow tests later\n- Cache dependencies between runs\n- Use matrix builds for multiple versions/platforms\n- Keep secrets in secure storage\n- Automate database migrations\n- Include rollback procedures\n- Monitor deployments with health checks\n- Use feature flags for safer releases\n",
    "devops/index.md": "# DevOps Guidelines\n\nThis directory contains DevOps and CI/CD patterns.\n\n## Available Chunks\n\n- **ci-cd.md** - Continuous Integration and Deployment pipelines\n- **practices.md** - Infrastructure as Code, monitoring, observability\n",
    "devops/practices.md": "# DevOps Practices\n\n## Infrastructure as Code\n\n```typescript\n// Pulumi example\nconst bucket = new aws.s3.Bucket(\"app-bucket\", {\n  acl: \"private\",\n  versioning: { enabled: true }\n});\n\nconst lambda = new aws.lambda.Function(\"api\", {\n  runtime: \"nodejs20.x\",\n  handler: \"index.handler\",\n  code: new pulumi.asset.AssetArchive({\n    \".\": new pulumi.asset.FileArchive(\"./dist\")\n  })\n});\n```\n\n## Containerization\n\n```dockerfile\nFROM node:20-alpine AS builder\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci\nCOPY . .\nRUN npm run build\n\nFROM node:20-alpine\nWORKDIR /app\nCOPY --from=builder /app/dist ./dist\nCOPY --from=builder /app/node_modules ./node_modules\nEXPOSE 3000\nCMD [\"node\", \"dist/index.js\"]\n```\n\n## Observability\n\n### Logging\n```typescript\nlogger.info('Order created', {\n  orderId: order.id,\n  customerId: order.customerId,\n  total: order.total,\n  timestamp: new Date().toISOString()\n});\n```\n\n### Metrics\n```typescript\nmetrics.increment('orders.created');\nmetrics.histogram('order.value', order.total);\nmetrics.timing('order.processing_time', duration);\n```\n\n### Health Checks\n```typescript\napp.get('/health', (req, res) => {\n  res.json({\n    status: 'healthy',\n    version: process.env.APP_VERSION,\n    uptime: process.uptime()\n  });\n});\n```\n\n## Best Practices\n\n- Version control all infrastructure\n- Use immutable infrastructure\n- Implement proper secret management\n- Set up alerting for critical metrics\n- Use structured logging (JSON)\n- Include correlation IDs for tracing\n- Document runbooks for incidents\n",
    "error-handling/index.md": "# Error Handling Guidelines\n\nThis directory contains error handling patterns and strategies.\n\n## Available Chunks\n\n- **strategy.md** - Custom errors, centralized handling, Result type, retry patterns\n",
    "error-handling/strategy.md": "# Error Handling Strategy\n\n## Custom Error Classes\n\n```typescript\nclass AppError extends Error {\n  constructor(\n    message: string,\n    public statusCode: number = 500,\n    public code: string = 'INTERNAL_ERROR',\n    public details?: unknown\n  ) {\n    super(message);\n    this.name = this.constructor.name;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nclass NotFoundError extends AppError {\n  constructor(resource: string, id: string) {\n    super(`${resource} with id ${id} not found`, 404, 'NOT_FOUND', { resource, id });\n  }\n}\n\nclass ValidationError extends AppError {\n  constructor(message: string, details: unknown) {\n    super(message, 400, 'VALIDATION_ERROR', details);\n  }\n}\n\n// Usage\nif (!user) {\n  throw new NotFoundError('User', userId);\n}\n```\n\n## Never Swallow Errors\n\n```typescript\n// ❌ Silent failure - dangerous!\ntry {\n  await criticalOperation();\n} catch (error) {\n  // Error ignored\n}\n\n// ✅ Log and handle appropriately\ntry {\n  await criticalOperation();\n} catch (error) {\n  logger.error('Critical operation failed', { error });\n  throw error; // Or handle gracefully\n}\n```\n\n## Specific Error Messages\n\n```typescript\n// ❌ Not actionable\nthrow new Error('Something went wrong');\n\n// ✅ Specific and actionable\nthrow new ValidationError('Email must be a valid email address', {\n  field: 'email',\n  value: userInput.email\n});\n```\n\n## Centralized Error Handler\n\n```typescript\n// Express error middleware\napp.use((err: Error, req: Request, res: Response, next: NextFunction) => {\n  if (err instanceof AppError) {\n    return res.status(err.statusCode).json({\n      error: {\n        message: err.message,\n        code: err.code,\n        details: err.details\n      }\n    });\n  }\n\n  // Log unexpected errors\n  console.error('Unexpected error:', err);\n\n  // Don't expose internal details\n  res.status(500).json({\n    error: {\n      message: 'Internal server error',\n      code: 'INTERNAL_ERROR'\n    }\n  });\n});\n```\n\n## Async Error Wrapper\n\n```typescript\n// Wrap async handlers to catch errors automatically\nconst asyncHandler = (fn: RequestHandler) => {\n  return (req: Request, res: Response, next: NextFunction) => {\n    Promise.resolve(fn(req, res, next)).catch(next);\n  };\n};\n\n// Usage\napp.get('/users/:id', asyncHandler(async (req, res) => {\n  const user = await getUser(req.params.id);\n  res.json(user);\n}));\n```\n\n## Result Type Pattern\n\n```typescript\ntype Result<T, E = Error> =\n  | { success: true; value: T }\n  | { success: false; error: E };\n\nfunction parseJSON<T>(json: string): Result<T, string> {\n  try {\n    return { success: true, value: JSON.parse(json) };\n  } catch {\n    return { success: false, error: 'Invalid JSON' };\n  }\n}\n\n// Usage - forces explicit error handling\nconst result = parseJSON<User>(data);\nif (result.success) {\n  console.log(result.value.name);\n} else {\n  console.error(result.error);\n}\n```\n\n## Error Boundaries (React)\n\n```typescript\nclass ErrorBoundary extends React.Component {\n  state = { hasError: false };\n\n  static getDerivedStateFromError(error: Error) {\n    return { hasError: true };\n  }\n\n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\n    logger.error('UI Error', { error, errorInfo });\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return <FallbackUI />;\n    }\n    return this.props.children;\n  }\n}\n```\n\n## Retry with Limits\n\n```typescript\n// ❌ Infinite retries\nwhile (true) {\n  try {\n    await operation();\n    break;\n  } catch (error) {\n    // Retry forever - exhausts resources\n  }\n}\n\n// ✅ Limited retries with backoff\nconst maxRetries = 3;\nfor (let i = 0; i < maxRetries; i++) {\n  try {\n    await operation();\n    break;\n  } catch (error) {\n    if (i === maxRetries - 1) throw error;\n    await sleep(Math.pow(2, i) * 1000); // Exponential backoff\n  }\n}\n```\n",
    "language/index.md": "# Language-Specific Guidelines\n\nProgramming language best practices and idioms.\n\n## Available Languages\n\n- `typescript/` - TypeScript guidelines\n- `javascript/` - JavaScript (ES6+) guidelines\n- `python/` - Python guidelines\n- `go/` - Go guidelines\n- `rust/` - Rust guidelines\n- `java/` - Java guidelines\n- `csharp/` - C# guidelines\n- `ruby/` - Ruby guidelines\n",
    "language/python/async.md": "# Python Async/Await\n\n## Basic Async Patterns\n\n```python\nimport asyncio\nfrom typing import List\n\n# ✅ Async function definition\nasync def fetch_user(user_id: int) -> User:\n    async with aiohttp.ClientSession() as session:\n        async with session.get(f\"/users/{user_id}\") as response:\n            data = await response.json()\n            return User(**data)\n\n# ✅ Running async code\nasync def main():\n    user = await fetch_user(1)\n    print(user.name)\n\nasyncio.run(main())\n```\n\n## Parallel Execution\n\n```python\n# ❌ Sequential (slow)\nasync def get_all_users(ids: List[int]) -> List[User]:\n    users = []\n    for user_id in ids:\n        user = await fetch_user(user_id)  # One at a time\n        users.append(user)\n    return users\n\n# ✅ Parallel with gather (fast)\nasync def get_all_users(ids: List[int]) -> List[User]:\n    tasks = [fetch_user(user_id) for user_id in ids]\n    return await asyncio.gather(*tasks)  # All at once\n\n# ✅ Parallel with error handling\nasync def get_all_users_safe(ids: List[int]) -> List[User | Exception]:\n    tasks = [fetch_user(user_id) for user_id in ids]\n    return await asyncio.gather(*tasks, return_exceptions=True)\n```\n\n## Async Context Managers\n\n```python\nfrom contextlib import asynccontextmanager\n\n# ✅ Async context manager\n@asynccontextmanager\nasync def get_connection():\n    conn = await database.connect()\n    try:\n        yield conn\n    finally:\n        await conn.close()\n\n# Usage\nasync def query_users():\n    async with get_connection() as conn:\n        return await conn.execute(\"SELECT * FROM users\")\n```\n\n## Timeouts and Cancellation\n\n```python\n# ✅ Add timeouts to prevent hanging\nasync def fetch_with_timeout(url: str, timeout: float = 10.0):\n    try:\n        async with asyncio.timeout(timeout):\n            return await fetch(url)\n    except asyncio.TimeoutError:\n        raise ServiceError(f\"Request to {url} timed out\")\n\n# ✅ Handle cancellation gracefully\nasync def long_running_task():\n    try:\n        while True:\n            await process_batch()\n            await asyncio.sleep(1)\n    except asyncio.CancelledError:\n        await cleanup()\n        raise\n```\n\n## Semaphore for Rate Limiting\n\n```python\n# ✅ Limit concurrent operations\nasync def fetch_all(urls: List[str], max_concurrent: int = 10):\n    semaphore = asyncio.Semaphore(max_concurrent)\n\n    async def fetch_one(url: str):\n        async with semaphore:\n            return await fetch(url)\n\n    return await asyncio.gather(*[fetch_one(url) for url in urls])\n```\n",
    "language/python/basics.md": "# Python Fundamentals\n\n## PEP 8 Style Guide\n\n```python\n# Naming conventions\nvariable_name = \"snake_case\"          # Variables and functions\nCONSTANT_VALUE = 42                   # Constants\nClassName = \"PascalCase\"              # Classes\n_private_var = \"internal\"             # Private by convention\n\n# Imports - group and order\nimport os                             # 1. Standard library\nimport sys\n\nimport requests                       # 2. Third-party\nfrom flask import Flask\n\nfrom myapp.models import User         # 3. Local application\nfrom myapp.utils import helper\n```\n\n## String Formatting\n\n```python\n# ✅ Use f-strings (Python 3.6+)\nname = \"Alice\"\nage = 30\nmessage = f\"Hello, {name}! You are {age} years old.\"\n\n# ✅ Multi-line f-strings\nquery = f\"\"\"\n    SELECT *\n    FROM users\n    WHERE name = '{name}'\n    AND age > {age - 5}\n\"\"\"\n\n# ❌ Avoid old-style formatting\nmessage = \"Hello, %s!\" % name           # Old style\nmessage = \"Hello, {}!\".format(name)     # Verbose\n```\n\n## List Comprehensions\n\n```python\n# ✅ Simple and readable\nsquares = [x ** 2 for x in range(10)]\neven_squares = [x ** 2 for x in range(10) if x % 2 == 0]\n\n# ❌ Too complex - use regular loop instead\nresult = [\n    transform(item)\n    for sublist in nested_list\n    for item in sublist\n    if condition(item) and another_condition(item)\n]\n\n# ✅ Break into steps when complex\nfiltered_items = [item for sublist in nested_list for item in sublist]\nfiltered_items = [item for item in filtered_items if condition(item)]\nresult = [transform(item) for item in filtered_items]\n```\n\n## Context Managers\n\n```python\n# ✅ Always use context managers for resources\nwith open('file.txt', 'r') as f:\n    content = f.read()\n# File automatically closed\n\n# ✅ Database connections\nwith db.connection() as conn:\n    cursor = conn.execute(query)\n\n# ✅ Multiple resources\nwith open('input.txt') as infile, open('output.txt', 'w') as outfile:\n    outfile.write(infile.read())\n```\n\n## Pythonic Patterns\n\n```python\n# ✅ EAFP (Easier to Ask Forgiveness than Permission)\ntry:\n    value = my_dict[key]\nexcept KeyError:\n    value = default\n\n# Or simply:\nvalue = my_dict.get(key, default)\n\n# ✅ Truthiness\nif my_list:          # Instead of: if len(my_list) > 0\n    process(my_list)\n\nif name:             # Instead of: if name != \"\"\n    greet(name)\n```\n",
    "language/python/index.md": "# Python Language Guidelines\n\nThis directory contains Python-specific coding guidelines.\n\n## Available Chunks\n\n- **basics.md** - PEP 8, string formatting, comprehensions, context managers\n- **types.md** - Type hints, TypedDict, Protocols, generics\n- **async.md** - async/await, asyncio, parallel execution\n- **testing.md** - pytest fixtures, parametrized tests, mocking\n",
    "language/python/testing.md": "# Python Testing with pytest\n\n## Basic Test Structure\n\n```python\nimport pytest\nfrom myapp.services import UserService\n\nclass TestUserService:\n    def test_create_user_with_valid_data(self):\n        # Arrange\n        service = UserService()\n        user_data = {\"email\": \"test@example.com\", \"name\": \"Test User\"}\n\n        # Act\n        user = service.create_user(user_data)\n\n        # Assert\n        assert user.id is not None\n        assert user.email == \"test@example.com\"\n\n    def test_create_user_with_invalid_email_raises_error(self):\n        service = UserService()\n\n        with pytest.raises(ValidationError, match=\"Invalid email\"):\n            service.create_user({\"email\": \"invalid\", \"name\": \"Test\"})\n```\n\n## Fixtures\n\n```python\nimport pytest\nfrom sqlalchemy import create_engine\n\n@pytest.fixture\ndef db_session():\n    \"\"\"Provide a transactional database session.\"\"\"\n    engine = create_engine(\"sqlite:///:memory:\")\n    Session = sessionmaker(bind=engine)\n    session = Session()\n\n    yield session\n\n    session.rollback()\n    session.close()\n\n@pytest.fixture\ndef user_service(db_session):\n    \"\"\"Provide UserService with test database.\"\"\"\n    return UserService(db_session)\n\n# Usage - fixtures injected automatically\ndef test_find_user(user_service, db_session):\n    user = User(email=\"test@example.com\")\n    db_session.add(user)\n    db_session.commit()\n\n    found = user_service.find_by_email(\"test@example.com\")\n    assert found.id == user.id\n```\n\n## Parametrized Tests\n\n```python\n@pytest.mark.parametrize(\"age,expected\", [\n    (17, False),\n    (18, True),\n    (21, True),\n    (0, False),\n    (-1, False),\n])\ndef test_is_adult(age, expected):\n    assert is_adult(age) == expected\n\n@pytest.mark.parametrize(\"email\", [\n    \"user@example.com\",\n    \"user.name@example.co.uk\",\n    \"user+tag@example.com\",\n])\ndef test_valid_emails(email):\n    assert validate_email(email) is True\n```\n\n## Mocking\n\n```python\nfrom unittest.mock import Mock, patch, AsyncMock\n\ndef test_send_notification(mocker):\n    # Mock external service\n    mock_email = mocker.patch(\"myapp.services.email_client\")\n    mock_email.send.return_value = True\n\n    service = NotificationService()\n    result = service.send_welcome_email(\"user@example.com\")\n\n    assert result is True\n    mock_email.send.assert_called_once_with(\n        to=\"user@example.com\",\n        template=\"welcome\"\n    )\n\n# Async mocking\n@pytest.mark.asyncio\nasync def test_fetch_user(mocker):\n    mock_client = mocker.patch(\"myapp.api.http_client\")\n    mock_client.get = AsyncMock(return_value={\"id\": 1, \"name\": \"Test\"})\n\n    user = await fetch_user(1)\n    assert user[\"name\"] == \"Test\"\n```\n\n## pytest Configuration\n\n```ini\n# pytest.ini\n[pytest]\ntestpaths = tests\npython_files = test_*.py\npython_functions = test_*\naddopts = -v --tb=short --strict-markers\nmarkers =\n    slow: marks tests as slow\n    integration: marks tests as integration tests\n```\n",
    "language/python/types.md": "# Python Type Hints\n\n## Basic Type Annotations\n\n```python\nfrom typing import List, Dict, Optional, Union, Tuple\n\n# Variable annotations\nname: str = \"Alice\"\nage: int = 30\nprices: List[float] = [9.99, 19.99, 29.99]\nuser_scores: Dict[str, int] = {\"alice\": 100, \"bob\": 85}\n\n# Function annotations\ndef greet(name: str, times: int = 1) -> str:\n    return f\"Hello, {name}! \" * times\n\ndef find_user(user_id: int) -> Optional[User]:\n    \"\"\"Returns User or None if not found.\"\"\"\n    return db.get(user_id)\n```\n\n## Modern Python 3.10+ Syntax\n\n```python\n# ✅ Use built-in types directly (Python 3.9+)\ndef process(items: list[str]) -> dict[str, int]:\n    return {item: len(item) for item in items}\n\n# ✅ Union syntax with | (Python 3.10+)\ndef parse(value: str | int | None) -> str:\n    if value is None:\n        return \"\"\n    return str(value)\n\n# Instead of:\nfrom typing import Union, Optional\ndef parse(value: Union[str, int, None]) -> str: ...\n```\n\n## TypedDict and Protocols\n\n```python\nfrom typing import TypedDict, Protocol\n\n# ✅ TypedDict for structured dictionaries\nclass UserDict(TypedDict):\n    id: int\n    name: str\n    email: str\n    is_active: bool\n\ndef create_user(data: UserDict) -> User:\n    return User(**data)\n\n# ✅ Protocol for structural typing (duck typing)\nclass Readable(Protocol):\n    def read(self) -> str: ...\n\ndef process_file(file: Readable) -> None:\n    content = file.read()\n    # Works with any object that has read() method\n```\n\n## Generics\n\n```python\nfrom typing import TypeVar, Generic\n\nT = TypeVar('T')\n\nclass Repository(Generic[T]):\n    def __init__(self, model: type[T]) -> None:\n        self.model = model\n\n    def find(self, id: int) -> T | None:\n        return self.db.get(self.model, id)\n\n    def save(self, entity: T) -> T:\n        return self.db.save(entity)\n\n# Usage\nuser_repo = Repository[User](User)\nuser = user_repo.find(1)  # Returns User | None\n```\n\n## Type Checking with mypy\n\n```bash\n# Run type checker\nmypy src/\n\n# mypy.ini configuration\n[mypy]\npython_version = 3.11\nstrict = True\nwarn_return_any = True\nwarn_unused_ignores = True\n```\n",
    "language/typescript/async.md": "# Async/Await Patterns\n\n## Prefer async/await\n\nAlways use async/await over promise chains:\n\n```typescript\n// ✅ Good\nasync function fetchUser(id: string): Promise<User> {\n  const response = await fetch(`/api/users/${id}`);\n  if (!response.ok) {\n    throw new Error(`HTTP ${response.status}`);\n  }\n  return await response.json();\n}\n\n// ❌ Avoid\nfunction fetchUser(id: string): Promise<User> {\n  return fetch(`/api/users/${id}`)\n    .then(res => res.json());\n}\n```\n\n## Error Handling\n\nAlways wrap async operations in try/catch:\n\n```typescript\nasync function safeOperation(): Promise<Result> {\n  try {\n    const data = await riskyOperation();\n    return { success: true, data };\n  } catch (error) {\n    logger.error('Operation failed', error);\n    return { success: false, error: error.message };\n  }\n}\n```\n\n## Parallel Execution\n\nUse `Promise.all()` for independent operations:\n\n```typescript\n// ✅ Good - parallel (fast)\nconst [users, posts, comments] = await Promise.all([\n  fetchUsers(),\n  fetchPosts(),\n  fetchComments()\n]);\n\n// ❌ Bad - sequential (slow)\nconst users = await fetchUsers();\nconst posts = await fetchPosts();\nconst comments = await fetchComments();\n```\n\n## Handling Failures\n\nUse `Promise.allSettled()` when some failures are acceptable:\n\n```typescript\nconst results = await Promise.allSettled([\n  fetchData1(),\n  fetchData2(),\n  fetchData3()\n]);\n\nresults.forEach((result, index) => {\n  if (result.status === 'fulfilled') {\n    console.log(`Success ${index}:`, result.value);\n  } else {\n    console.error(`Failed ${index}:`, result.reason);\n  }\n});\n```\n\n## Retry Pattern\n\nImplement retry with exponential backoff:\n\n```typescript\nasync function retryWithBackoff<T>(\n  fn: () => Promise<T>,\n  maxRetries: number = 3\n): Promise<T> {\n  let lastError: Error;\n\n  for (let attempt = 0; attempt < maxRetries; attempt++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error as Error;\n      if (attempt < maxRetries - 1) {\n        const delay = 1000 * Math.pow(2, attempt);\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n  }\n\n  throw lastError!;\n}\n```\n",
    "language/typescript/basics.md": "# TypeScript Fundamentals\n\n## Strict Mode (Required)\n\nAlways use strict mode in `tsconfig.json`:\n\n```json\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"noImplicitAny\": true,\n    \"strictNullChecks\": true,\n    \"strictFunctionTypes\": true\n  }\n}\n```\n\n## Type Annotations\n\nUse explicit types for clarity:\n\n```typescript\n// Function signatures\nfunction calculateTotal(items: CartItem[], taxRate: number): number {\n  const subtotal = items.reduce((sum, item) => sum + item.price, 0);\n  return subtotal * (1 + taxRate);\n}\n\n// Variable declarations\nconst userName: string = \"Alice\";\nconst age: number = 30;\nconst isActive: boolean = true;\n```\n\n## Avoid `any`\n\nNever use `any` - use `unknown` with type guards:\n\n```typescript\n// ❌ Bad\nfunction processData(data: any) {\n  return data.value;\n}\n\n// ✅ Good\nfunction processData(data: unknown): string {\n  if (typeof data === 'object' && data !== null && 'value' in data) {\n    return String(data.value);\n  }\n  throw new Error('Invalid data structure');\n}\n```\n\n## Type Guards\n\nImplement custom type guards:\n\n```typescript\ninterface User {\n  id: string;\n  email: string;\n}\n\nfunction isUser(value: unknown): value is User {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    'id' in value &&\n    'email' in value &&\n    typeof value.id === 'string' &&\n    typeof value.email === 'string'\n  );\n}\n\n// Usage\nif (isUser(data)) {\n  console.log(data.email); // Type: User\n}\n```\n\n## Naming Conventions\n\n- Classes/Interfaces: `PascalCase`\n- Functions/Variables: `camelCase`\n- Constants: `UPPER_SNAKE_CASE`\n- Files: `kebab-case.ts`\n- No `I` prefix for interfaces\n",
    "language/typescript/config.md": "# TypeScript Configuration\n\n## tsconfig.json Best Practices\n\n```json\n{\n  \"compilerOptions\": {\n    // Strict type checking\n    \"strict\": true,\n    \"noImplicitAny\": true,\n    \"strictNullChecks\": true,\n    \"strictFunctionTypes\": true,\n    \"strictBindCallApply\": true,\n    \"strictPropertyInitialization\": true,\n    \"noImplicitThis\": true,\n    \"alwaysStrict\": true,\n\n    // Additional checks\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true,\n    \"noImplicitReturns\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"noUncheckedIndexedAccess\": true,\n\n    // Module resolution\n    \"module\": \"ESNext\",\n    \"moduleResolution\": \"bundler\",\n    \"esModuleInterop\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"resolveJsonModule\": true,\n\n    // Output\n    \"target\": \"ES2022\",\n    \"outDir\": \"./dist\",\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true,\n\n    // Path aliases\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@/*\": [\"src/*\"],\n      \"@services/*\": [\"src/services/*\"],\n      \"@models/*\": [\"src/models/*\"]\n    }\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\", \"**/*.test.ts\"]\n}\n```\n\n## Path Aliases Setup\n\n```typescript\n// With path aliases configured:\nimport { UserService } from '@services/user';\nimport { User } from '@models/user';\n\n// Instead of relative paths:\nimport { UserService } from '../../../services/user';\n```\n\n## Project References (Monorepo)\n\n```json\n// packages/shared/tsconfig.json\n{\n  \"compilerOptions\": {\n    \"composite\": true,\n    \"outDir\": \"./dist\"\n  }\n}\n\n// packages/api/tsconfig.json\n{\n  \"extends\": \"../../tsconfig.base.json\",\n  \"references\": [\n    { \"path\": \"../shared\" }\n  ]\n}\n```\n\n## Environment-Specific Configs\n\n```json\n// tsconfig.build.json - for production builds\n{\n  \"extends\": \"./tsconfig.json\",\n  \"compilerOptions\": {\n    \"sourceMap\": false,\n    \"removeComments\": true\n  },\n  \"exclude\": [\"**/*.test.ts\", \"**/*.spec.ts\"]\n}\n```\n",
    "language/typescript/error-handling.md": "# TypeScript Error Handling\n\n## Custom Error Classes\n\n```typescript\n// ✅ Create structured error hierarchy\nclass AppError extends Error {\n  constructor(\n    message: string,\n    public statusCode: number = 500,\n    public code: string = 'INTERNAL_ERROR',\n    public details?: unknown\n  ) {\n    super(message);\n    this.name = this.constructor.name;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nclass NotFoundError extends AppError {\n  constructor(resource: string, id: string) {\n    super(`${resource} with id ${id} not found`, 404, 'NOT_FOUND', { resource, id });\n  }\n}\n\nclass ValidationError extends AppError {\n  constructor(message: string, details: unknown) {\n    super(message, 400, 'VALIDATION_ERROR', details);\n  }\n}\n```\n\n## Async Error Handling\n\n```typescript\n// ✅ Always handle promise rejections\nasync function fetchUser(id: string): Promise<User> {\n  try {\n    const response = await api.get(`/users/${id}`);\n    return response.data;\n  } catch (error) {\n    if (error instanceof ApiError && error.status === 404) {\n      throw new NotFoundError('User', id);\n    }\n    throw new AppError('Failed to fetch user', 500, 'FETCH_ERROR', { userId: id });\n  }\n}\n\n// ✅ Use wrapper for Express async handlers\nconst asyncHandler = (fn: RequestHandler) => {\n  return (req: Request, res: Response, next: NextFunction) => {\n    Promise.resolve(fn(req, res, next)).catch(next);\n  };\n};\n```\n\n## Result Type Pattern\n\n```typescript\n// ✅ Explicit success/failure without exceptions\ntype Result<T, E = Error> =\n  | { success: true; value: T }\n  | { success: false; error: E };\n\nfunction parseJSON<T>(json: string): Result<T, string> {\n  try {\n    return { success: true, value: JSON.parse(json) };\n  } catch {\n    return { success: false, error: 'Invalid JSON' };\n  }\n}\n\n// Usage\nconst result = parseJSON<User>(data);\nif (result.success) {\n  console.log(result.value.name);\n} else {\n  console.error(result.error);\n}\n```\n\n## Centralized Error Handler\n\n```typescript\n// ✅ Express error middleware\napp.use((err: Error, req: Request, res: Response, next: NextFunction) => {\n  if (err instanceof AppError) {\n    return res.status(err.statusCode).json({\n      error: { message: err.message, code: err.code, details: err.details }\n    });\n  }\n\n  console.error('Unexpected error:', err);\n  res.status(500).json({\n    error: { message: 'Internal server error', code: 'INTERNAL_ERROR' }\n  });\n});\n```\n",
    "language/typescript/generics.md": "# TypeScript Generics\n\n## Basic Generic Functions\n\n```typescript\n// ✅ Generic function for type-safe operations\nfunction first<T>(array: T[]): T | undefined {\n  return array[0];\n}\n\nconst numbers = [1, 2, 3];\nconst firstNumber = first(numbers); // Type: number | undefined\n\nconst users = [{ name: 'John' }];\nconst firstUser = first(users); // Type: { name: string } | undefined\n```\n\n## Generic Interfaces\n\n```typescript\n// ✅ Generic repository pattern\ninterface Repository<T> {\n  findById(id: string): Promise<T | null>;\n  findAll(): Promise<T[]>;\n  create(entity: Omit<T, 'id'>): Promise<T>;\n  update(id: string, data: Partial<T>): Promise<T>;\n  delete(id: string): Promise<void>;\n}\n\nclass UserRepository implements Repository<User> {\n  async findById(id: string): Promise<User | null> {\n    return this.db.users.findUnique({ where: { id } });\n  }\n  // ... other methods\n}\n```\n\n## Generic Constraints\n\n```typescript\n// ✅ Constrain generic types\ninterface HasId {\n  id: string;\n}\n\nfunction getById<T extends HasId>(items: T[], id: string): T | undefined {\n  return items.find(item => item.id === id);\n}\n\n// Works with any type that has an id\ngetById(users, '123');\ngetById(products, '456');\n```\n\n## Mapped Types\n\n```typescript\n// ✅ Create transformed types\ntype Nullable<T> = {\n  [K in keyof T]: T[K] | null;\n};\n\ntype NullableUser = Nullable<User>;\n// { id: string | null; name: string | null; ... }\n\n// ✅ Conditional types\ntype ExtractArrayType<T> = T extends Array<infer U> ? U : never;\n\ntype StringArrayElement = ExtractArrayType<string[]>; // string\n```\n\n## Default Generic Parameters\n\n```typescript\n// ✅ Provide defaults for flexibility\ninterface ApiResponse<T = unknown, E = Error> {\n  data?: T;\n  error?: E;\n  status: number;\n}\n\n// Can use with or without type parameters\nconst response1: ApiResponse<User> = { data: user, status: 200 };\nconst response2: ApiResponse = { status: 500, error: new Error('Failed') };\n```\n",
    "language/typescript/index.md": "# TypeScript Guidelines\n\nTypeScript-specific best practices for Claude Code.\n\n## Chunks\n\n- `basics.md` - Type system fundamentals and strict mode\n- `interfaces-types.md` - Interfaces vs types, when to use each\n- `generics.md` - Generic programming patterns\n- `async.md` - Async/await and Promise patterns\n- `error-handling.md` - Type-safe error handling\n- `testing.md` - Testing TypeScript code\n- `config.md` - tsconfig.json best practices\n- `performance.md` - Performance optimization\n",
    "language/typescript/interfaces-types.md": "# TypeScript Types & Interfaces\n\n## Prefer Interfaces for Public APIs\n\n```typescript\n// ✅ Use interfaces for object shapes\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n  createdAt: Date;\n}\n\n// ✅ Use type aliases for unions and complex types\ntype UserRole = 'admin' | 'editor' | 'viewer';\ntype ResponseHandler = (response: Response) => void;\n```\n\n## Discriminated Unions\n\n```typescript\n// ✅ Use discriminated unions for variant types\ntype Result<T> =\n  | { success: true; data: T }\n  | { success: false; error: string };\n\nfunction handleResult(result: Result<User>) {\n  if (result.success) {\n    console.log(result.data.name); // TypeScript knows data exists\n  } else {\n    console.error(result.error); // TypeScript knows error exists\n  }\n}\n```\n\n## Utility Types\n\n```typescript\n// Use built-in utility types\ntype PartialUser = Partial<User>;           // All fields optional\ntype RequiredUser = Required<User>;         // All fields required\ntype ReadonlyUser = Readonly<User>;         // All fields readonly\ntype UserKeys = keyof User;                 // 'id' | 'name' | 'email' | 'createdAt'\ntype PickedUser = Pick<User, 'id' | 'name'>; // Only id and name\ntype OmittedUser = Omit<User, 'createdAt'>; // Everything except createdAt\n```\n\n## Type Guards\n\n```typescript\n// ✅ Use type guards for runtime checking\nfunction isUser(value: unknown): value is User {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    'id' in value &&\n    'email' in value\n  );\n}\n\n// Usage\nconst data: unknown = fetchData();\nif (isUser(data)) {\n  console.log(data.email); // TypeScript knows it's a User\n}\n```\n\n## Avoid `any`\n\n```typescript\n// ❌ Never use any\nfunction process(data: any) {\n  return data.name; // No type safety\n}\n\n// ✅ Use unknown with type guards\nfunction process(data: unknown) {\n  if (isUser(data)) {\n    return data.name; // Type-safe\n  }\n  throw new Error('Invalid data');\n}\n```\n",
    "language/typescript/performance.md": "# TypeScript Performance\n\n## Choose Right Data Structures\n\n```typescript\n// ❌ Array for lookups (O(n))\nconst users: User[] = [];\nconst findUser = (id: string) => users.find(u => u.id === id);\n\n// ✅ Map for O(1) lookups\nconst users = new Map<string, User>();\nconst findUser = (id: string) => users.get(id);\n\n// ❌ Array for membership checks\nconst hasPermission = (perms: string[], perm: string) => perms.includes(perm);\n\n// ✅ Set for O(1) membership\nconst hasPermission = (perms: Set<string>, perm: string) => perms.has(perm);\n```\n\n## Avoid N+1 Queries\n\n```typescript\n// ❌ N+1 queries\nconst getOrdersWithCustomers = async () => {\n  const orders = await db.query('SELECT * FROM orders');\n  for (const order of orders) {\n    order.customer = await db.query('SELECT * FROM customers WHERE id = ?', [order.customerId]);\n  }\n  return orders;\n};\n\n// ✅ Single JOIN query\nconst getOrdersWithCustomers = async () => {\n  return db.query(`\n    SELECT orders.*, customers.name as customer_name\n    FROM orders\n    JOIN customers ON orders.customer_id = customers.id\n  `);\n};\n\n// ✅ Using ORM with eager loading\nconst getOrdersWithCustomers = async () => {\n  return orderRepository.find({ relations: ['customer'] });\n};\n```\n\n## Parallel Execution\n\n```typescript\n// ❌ Sequential (slow)\nconst getUserData = async (userId: string) => {\n  const user = await fetchUser(userId);       // 100ms\n  const posts = await fetchPosts(userId);     // 150ms\n  const comments = await fetchComments(userId); // 120ms\n  return { user, posts, comments }; // Total: 370ms\n};\n\n// ✅ Parallel (fast)\nconst getUserData = async (userId: string) => {\n  const [user, posts, comments] = await Promise.all([\n    fetchUser(userId),\n    fetchPosts(userId),\n    fetchComments(userId)\n  ]);\n  return { user, posts, comments }; // Total: 150ms\n};\n```\n\n## Memoization\n\n```typescript\nconst memoize = <T extends (...args: any[]) => any>(fn: T): T => {\n  const cache = new Map<string, ReturnType<T>>();\n\n  return ((...args: any[]) => {\n    const key = JSON.stringify(args);\n    if (cache.has(key)) return cache.get(key);\n    const result = fn(...args);\n    cache.set(key, result);\n    return result;\n  }) as T;\n};\n\nconst expensiveCalc = memoize((n: number) => {\n  // Expensive computation\n  return result;\n});\n```\n\n## Batch Processing\n\n```typescript\n// ✅ Process in batches\nconst processUsers = async (userIds: string[]) => {\n  const BATCH_SIZE = 50;\n\n  for (let i = 0; i < userIds.length; i += BATCH_SIZE) {\n    const batch = userIds.slice(i, i + BATCH_SIZE);\n    await Promise.all(batch.map(id => updateUser(id)));\n  }\n};\n```\n",
    "language/typescript/testing.md": "# TypeScript Testing\n\n## Test Structure: Arrange-Act-Assert\n\n```typescript\ndescribe('UserService', () => {\n  describe('createUser', () => {\n    it('should create user with hashed password', async () => {\n      // Arrange\n      const userData = { email: 'test@example.com', password: 'password123' };\n      const mockRepo = { save: jest.fn().mockResolvedValue({ id: '1', ...userData }) };\n      const service = new UserService(mockRepo);\n\n      // Act\n      const result = await service.createUser(userData);\n\n      // Assert\n      expect(result.id).toBe('1');\n      expect(mockRepo.save).toHaveBeenCalledWith(\n        expect.objectContaining({ email: 'test@example.com' })\n      );\n    });\n  });\n});\n```\n\n## Test Observable Behavior, Not Implementation\n\n```typescript\n// ❌ Testing implementation details\nit('should call validateEmail method', () => {\n  const spy = jest.spyOn(service, 'validateEmail');\n  service.createUser({ email: 'test@example.com' });\n  expect(spy).toHaveBeenCalled(); // Brittle - breaks if refactored\n});\n\n// ✅ Testing observable behavior\nit('should reject invalid email', async () => {\n  await expect(\n    service.createUser({ email: 'invalid' })\n  ).rejects.toThrow('Invalid email');\n});\n```\n\n## Test Doubles\n\n```typescript\n// Stub: Returns canned responses\nconst stubDatabase = {\n  findUser: () => ({ id: '1', name: 'Test User' })\n};\n\n// Mock: Pre-programmed with expectations\nconst mockPayment = {\n  charge: jest.fn()\n    .mockResolvedValueOnce({ success: true })\n    .mockResolvedValueOnce({ success: false })\n};\n\n// Fake: Working implementation (not for production)\nclass FakeDatabase implements Database {\n  private data = new Map<string, any>();\n\n  async save(id: string, data: any) { this.data.set(id, data); }\n  async find(id: string) { return this.data.get(id); }\n}\n```\n\n## One Test Per Condition\n\n```typescript\n// ❌ Multiple assertions for different scenarios\nit('should validate user input', () => {\n  expect(() => validate({ age: -1 })).toThrow();\n  expect(() => validate({ age: 200 })).toThrow();\n  expect(() => validate({ name: '' })).toThrow();\n});\n\n// ✅ One test per condition\nit('should reject negative age', () => {\n  expect(() => validate({ age: -1 })).toThrow('Age must be positive');\n});\n\nit('should reject age over 150', () => {\n  expect(() => validate({ age: 200 })).toThrow('Age must be under 150');\n});\n```\n\n## Keep Tests Independent\n\n```typescript\n// ✅ Each test is self-contained\nit('should update user', async () => {\n  const user = await service.createUser({ name: 'Test' });\n  const updated = await service.updateUser(user.id, { name: 'Updated' });\n  expect(updated.name).toBe('Updated');\n});\n```\n",
    "original/architecture/caching-strategies.md": "# Caching Strategies & Patterns\n\n## Cache Layers\n\n### Multi-Tier Caching\n\n```\nClient (Browser)\n    ↓ Cache-Control headers\nCDN (CloudFlare/CloudFront)\n    ↓ Geographic distribution\nReverse Proxy (Nginx/Varnish)\n    ↓ HTTP caching\nApplication Cache (Redis/Memcached)\n    ↓ In-memory data\nDatabase Query Cache\n    ↓ Query results\n```\n\n### Browser Caching\n\n```typescript\n// Static assets\napp.use('/static', express.static('public', {\n  maxAge: '1y',           // Cache for 1 year\n  immutable: true          // Never revalidate\n}));\n\n// Dynamic content with validation\napp.get('/api/user/:id', async (req, res) => {\n  const user = await getUser(req.params.id);\n\n  // Cache for 5 minutes, revalidate when stale\n  res.set('Cache-Control', 'public, max-age=300, must-revalidate');\n\n  // ETag for conditional requests\n  const etag = generateETag(user);\n  res.set('ETag', etag);\n\n  if (req.headers['if-none-match'] === etag) {\n    return res.status(304).end();\n  }\n\n  res.json(user);\n});\n```\n\n### CDN Caching\n\n```typescript\n// Cloudflare Page Rules or AWS CloudFront\napp.get('/api/public-data', (req, res) => {\n  // Cache at CDN edge for 1 hour\n  res.set('Cache-Control', 'public, max-age=3600, s-maxage=3600');\n  res.set('Surrogate-Control', 'max-age=86400');  // CDN-specific\n\n  res.json(getPublicData());\n});\n\n// Purge CDN cache when data changes\nconst updatePublicData = async (data) => {\n  await db.update(data);\n\n  // Purge Cloudflare cache\n  await cloudflare.zones.purgeCache({\n    files: ['https://example.com/api/public-data']\n  });\n};\n```\n\n## Cache Patterns\n\n### Cache-Aside (Lazy Loading)\n\n```typescript\nconst getUser = async (userId: string): Promise<User> => {\n  // 1. Check cache\n  const cached = await redis.get(`user:${userId}`);\n  if (cached) {\n    return JSON.parse(cached);\n  }\n\n  // 2. Cache miss: fetch from database\n  const user = await db.findUser(userId);\n\n  if (!user) {\n    throw new NotFoundError('User', userId);\n  }\n\n  // 3. Store in cache\n  await redis.setex(`user:${userId}`, 3600, JSON.stringify(user));\n\n  return user;\n};\n```\n\n### Read-Through Cache\n\n```typescript\nclass CachedUserRepository {\n  constructor(\n    private cache: Redis,\n    private db: Database\n  ) {}\n\n  async findById(userId: string): Promise<User> {\n    const cacheKey = `user:${userId}`;\n\n    // Cache handles fetching\n    return this.cache.getOrSet(cacheKey, async () => {\n      const user = await this.db.findUser(userId);\n      return user;\n    }, 3600);\n  }\n}\n\n// Redis getOrSet implementation\nRedis.prototype.getOrSet = async function(\n  key: string,\n  fetchFn: () => Promise<any>,\n  ttl: number\n): Promise<any> {\n  const cached = await this.get(key);\n\n  if (cached) {\n    return JSON.parse(cached);\n  }\n\n  const value = await fetchFn();\n  await this.setex(key, ttl, JSON.stringify(value));\n\n  return value;\n};\n```\n\n### Write-Through Cache\n\n```typescript\nconst updateUser = async (userId: string, data: Partial<User>): Promise<User> => {\n  // 1. Update database\n  const user = await db.updateUser(userId, data);\n\n  // 2. Update cache\n  await redis.setex(`user:${userId}`, 3600, JSON.stringify(user));\n\n  return user;\n};\n```\n\n### Write-Behind (Write-Back) Cache\n\n```typescript\nclass WriteBehindCache {\n  private writeQueue: Map<string, any> = new Map();\n  private flushInterval: NodeJS.Timeout;\n\n  constructor(\n    private cache: Redis,\n    private db: Database,\n    private flushIntervalMs: number = 5000\n  ) {\n    this.startFlushTimer();\n  }\n\n  async set(key: string, value: any): Promise<void> {\n    // 1. Write to cache immediately\n    await this.cache.set(key, JSON.stringify(value));\n\n    // 2. Queue for database write\n    this.writeQueue.set(key, value);\n  }\n\n  private startFlushTimer(): void {\n    this.flushInterval = setInterval(async () => {\n      await this.flush();\n    }, this.flushIntervalMs);\n  }\n\n  private async flush(): Promise<void> {\n    if (this.writeQueue.size === 0) return;\n\n    const entries = Array.from(this.writeQueue.entries());\n    this.writeQueue.clear();\n\n    // Batch write to database\n    await Promise.all(\n      entries.map(([key, value]) =>\n        this.db.upsert(key, value)\n      )\n    );\n  }\n\n  async shutdown(): Promise<void> {\n    clearInterval(this.flushInterval);\n    await this.flush();\n  }\n}\n```\n\n### Refresh-Ahead\n\n```typescript\nclass RefreshAheadCache {\n  constructor(\n    private cache: Redis,\n    private fetchFn: (key: string) => Promise<any>,\n    private ttl: number = 3600\n  ) {}\n\n  async get(key: string): Promise<any> {\n    const data = await this.cache.get(key);\n\n    if (!data) {\n      return this.fetchAndCache(key);\n    }\n\n    const ttlRemaining = await this.cache.ttl(key);\n\n    // Refresh if less than 10% of TTL remains\n    if (ttlRemaining < this.ttl * 0.1) {\n      // Async refresh, return stale data immediately\n      this.fetchAndCache(key).catch(err =>\n        console.error('Background refresh failed:', err)\n      );\n    }\n\n    return JSON.parse(data);\n  }\n\n  private async fetchAndCache(key: string): Promise<any> {\n    const value = await this.fetchFn(key);\n    await this.cache.setex(key, this.ttl, JSON.stringify(value));\n    return value;\n  }\n}\n```\n\n## Cache Invalidation\n\n### Time-Based Expiration (TTL)\n\n```typescript\n// Fixed TTL\nawait redis.setex('user:123', 3600, JSON.stringify(user)); // 1 hour\n\n// Variable TTL based on data type\nconst getTTL = (dataType: string): number => {\n  switch (dataType) {\n    case 'user': return 3600;           // 1 hour\n    case 'product': return 600;         // 10 minutes\n    case 'config': return 86400;        // 24 hours\n    case 'popular-posts': return 300;   // 5 minutes\n    default: return 1800;\n  }\n};\n```\n\n### Event-Based Invalidation\n\n```typescript\n// Invalidate on update\nconst updateUser = async (userId: string, data: Partial<User>): Promise<User> => {\n  const user = await db.updateUser(userId, data);\n\n  // Invalidate user cache\n  await redis.del(`user:${userId}`);\n\n  // Invalidate related caches\n  await redis.del(`user:${userId}:orders`);\n  await redis.del(`user:${userId}:preferences`);\n\n  return user;\n};\n\n// Event-driven invalidation\neventBus.on('user.updated', async (event) => {\n  await redis.del(`user:${event.userId}`);\n});\n\neventBus.on('order.created', async (event) => {\n  await redis.del(`user:${event.userId}:orders`);\n});\n```\n\n### Cache Tags\n\n```typescript\nclass TaggedCache {\n  constructor(private cache: Redis) {}\n\n  async set(key: string, value: any, ttl: number, tags: string[]): Promise<void> {\n    // Store value\n    await this.cache.setex(key, ttl, JSON.stringify(value));\n\n    // Associate tags\n    for (const tag of tags) {\n      await this.cache.sadd(`tag:${tag}`, key);\n    }\n  }\n\n  async invalidateTag(tag: string): Promise<void> {\n    // Get all keys with this tag\n    const keys = await this.cache.smembers(`tag:${tag}`);\n\n    if (keys.length > 0) {\n      // Delete all tagged keys\n      await this.cache.del(...keys);\n    }\n\n    // Remove tag set\n    await this.cache.del(`tag:${tag}`);\n  }\n}\n\n// Usage\nconst cache = new TaggedCache(redis);\n\n// Cache with tags\nawait cache.set('product:123', product, 3600, ['products', 'category:electronics', 'brand:acme']);\n\n// Invalidate all products in category\nawait cache.invalidateTag('category:electronics');\n```\n\n### Surrogate Keys\n\n```typescript\n// Group related cache entries\nconst cacheUser = async (userId: string, user: User): Promise<void> => {\n  await redis.setex(`user:${userId}`, 3600, JSON.stringify(user));\n\n  // Track in user's surrogate key set\n  await redis.sadd(`surrogate:user:${userId}`, `user:${userId}`);\n  await redis.sadd(`surrogate:user:${userId}`, `user:${userId}:orders`);\n  await redis.sadd(`surrogate:user:${userId}`, `user:${userId}:preferences`);\n};\n\nconst invalidateUserCache = async (userId: string): Promise<void> => {\n  // Get all keys in surrogate set\n  const keys = await redis.smembers(`surrogate:user:${userId}`);\n\n  // Delete all\n  if (keys.length > 0) {\n    await redis.del(...keys);\n  }\n\n  // Delete surrogate set\n  await redis.del(`surrogate:user:${userId}`);\n};\n```\n\n## Cache Warming\n\n### Proactive Caching\n\n```typescript\n// Warm cache on application startup\nconst warmCache = async (): Promise<void> => {\n  console.log('Warming cache...');\n\n  // Popular products\n  const popularProducts = await db.getPopularProducts(100);\n  for (const product of popularProducts) {\n    await redis.setex(\n      `product:${product.id}`,\n      3600,\n      JSON.stringify(product)\n    );\n  }\n\n  // Global configuration\n  const config = await db.getConfiguration();\n  await redis.setex('app:config', 86400, JSON.stringify(config));\n\n  console.log('Cache warmed');\n};\n\n// Run on startup\napp.on('ready', warmCache);\n```\n\n### Scheduled Cache Warming\n\n```typescript\nimport cron from 'node-cron';\n\n// Warm cache every hour\ncron.schedule('0 * * * *', async () => {\n  console.log('Scheduled cache warming');\n\n  const trendingPosts = await db.getTrendingPosts();\n  for (const post of trendingPosts) {\n    await redis.setex(`post:${post.id}`, 3600, JSON.stringify(post));\n  }\n});\n```\n\n## Distributed Caching\n\n### Redis Cluster\n\n```typescript\nimport Redis from 'ioredis';\n\nconst cluster = new Redis.Cluster([\n  { host: 'redis-1', port: 6379 },\n  { host: 'redis-2', port: 6379 },\n  { host: 'redis-3', port: 6379 }\n], {\n  redisOptions: {\n    password: process.env.REDIS_PASSWORD\n  },\n  scaleReads: 'slave'  // Read from replicas\n});\n\n// Automatic sharding across cluster\nawait cluster.set('user:123', JSON.stringify(user));\n```\n\n### Cache Replication\n\n```typescript\n// Primary-Replica setup\nconst primary = new Redis({\n  host: 'redis-primary',\n  port: 6379\n});\n\nconst replica = new Redis({\n  host: 'redis-replica',\n  port: 6379\n});\n\n// Write to primary\nawait primary.set('user:123', JSON.stringify(user));\n\n// Read from replica (eventually consistent)\nconst user = await replica.get('user:123');\n```\n\n## Cache Stampede Prevention\n\n### Mutex/Lock Pattern\n\n```typescript\nconst getUserWithLock = async (userId: string): Promise<User> => {\n  const cacheKey = `user:${userId}`;\n  const lockKey = `lock:${cacheKey}`;\n\n  // Check cache\n  const cached = await redis.get(cacheKey);\n  if (cached) {\n    return JSON.parse(cached);\n  }\n\n  // Try to acquire lock\n  const lockAcquired = await redis.set(\n    lockKey,\n    '1',\n    'EX', 10,  // 10 second expiry\n    'NX'       // Only set if not exists\n  );\n\n  if (lockAcquired) {\n    try {\n      // Only this request fetches from database\n      const user = await db.findUser(userId);\n\n      await redis.setex(cacheKey, 3600, JSON.stringify(user));\n\n      return user;\n    } finally {\n      await redis.del(lockKey);\n    }\n  }\n\n  // Lock not acquired, wait and retry\n  await new Promise(resolve => setTimeout(resolve, 100));\n  return getUserWithLock(userId);  // Retry\n};\n```\n\n### Probabilistic Early Expiration\n\n```typescript\nconst getWithProbabilisticRefresh = async (key: string): Promise<any> => {\n  const data = await redis.get(key);\n\n  if (!data) {\n    return fetchAndCache(key);\n  }\n\n  const ttl = await redis.ttl(key);\n  const delta = Math.random() * 60;  // Random 0-60 seconds\n\n  // Probabilistically refresh before expiry\n  if (ttl - delta <= 0) {\n    // Async refresh\n    fetchAndCache(key).catch(console.error);\n  }\n\n  return JSON.parse(data);\n};\n```\n\n## Cache Eviction Policies\n\n### LRU (Least Recently Used)\n\n```typescript\nclass LRUCache<T> {\n  private cache = new Map<string, T>();\n  private accessOrder: string[] = [];\n\n  constructor(private maxSize: number) {}\n\n  get(key: string): T | undefined {\n    const value = this.cache.get(key);\n\n    if (value !== undefined) {\n      // Move to end (most recently used)\n      this.accessOrder = this.accessOrder.filter(k => k !== key);\n      this.accessOrder.push(key);\n    }\n\n    return value;\n  }\n\n  set(key: string, value: T): void {\n    // Remove if exists\n    if (this.cache.has(key)) {\n      this.accessOrder = this.accessOrder.filter(k => k !== key);\n    }\n\n    // Evict oldest if at capacity\n    if (this.cache.size >= this.maxSize && !this.cache.has(key)) {\n      const oldest = this.accessOrder.shift();\n      if (oldest) {\n        this.cache.delete(oldest);\n      }\n    }\n\n    this.cache.set(key, value);\n    this.accessOrder.push(key);\n  }\n}\n```\n\n### Redis Eviction Policies\n\n```bash\n# redis.conf\n\n# allkeys-lru: Evict any key using LRU\nmaxmemory-policy allkeys-lru\n\n# volatile-lru: Evict keys with TTL using LRU\nmaxmemory-policy volatile-lru\n\n# allkeys-lfu: Evict using Least Frequently Used\nmaxmemory-policy allkeys-lfu\n\n# volatile-ttl: Evict keys with shortest TTL\nmaxmemory-policy volatile-ttl\n```\n\n## Cache Metrics\n\n### Monitoring\n\n```typescript\nclass CacheMonitor {\n  private hits = 0;\n  private misses = 0;\n  private errors = 0;\n\n  recordHit(): void {\n    this.hits++;\n  }\n\n  recordMiss(): void {\n    this.misses++;\n  }\n\n  recordError(): void {\n    this.errors++;\n  }\n\n  getStats() {\n    const total = this.hits + this.misses;\n    const hitRate = total > 0 ? (this.hits / total) * 100 : 0;\n\n    return {\n      hits: this.hits,\n      misses: this.misses,\n      errors: this.errors,\n      total,\n      hitRate: hitRate.toFixed(2) + '%'\n    };\n  }\n\n  reset(): void {\n    this.hits = 0;\n    this.misses = 0;\n    this.errors = 0;\n  }\n}\n\n// Usage\nconst monitor = new CacheMonitor();\n\nconst getCached = async (key: string): Promise<any> => {\n  try {\n    const value = await redis.get(key);\n\n    if (value) {\n      monitor.recordHit();\n      return JSON.parse(value);\n    }\n\n    monitor.recordMiss();\n    return null;\n  } catch (error) {\n    monitor.recordError();\n    throw error;\n  }\n};\n\n// Expose metrics\napp.get('/metrics/cache', (req, res) => {\n  res.json(monitor.getStats());\n});\n```\n\n## Anti-Patterns\n\n### ❌ Caching Everything\n\n```typescript\n// Don't cache data that changes frequently\nawait redis.set('user-online-status', status);  // Changes every second\n\n// Don't cache tiny computations\nawait redis.set('2+2', '4');  // Caching overhead > computation\n```\n\n### ❌ No Cache Invalidation Strategy\n\n```typescript\n// ❌ Cache never expires, stale forever\nawait redis.set('user:123', JSON.stringify(user));  // No TTL\n\n// ✅ Always set appropriate TTL\nawait redis.setex('user:123', 3600, JSON.stringify(user));\n```\n\n### ❌ Ignoring Cache Failures\n\n```typescript\n// ❌ Application crashes when cache is down\nconst user = await redis.get(`user:${id}`);  // Throws if Redis down\n\n// ✅ Graceful degradation\nconst getUserResilient = async (id: string): Promise<User> => {\n  try {\n    const cached = await redis.get(`user:${id}`);\n    if (cached) return JSON.parse(cached);\n  } catch (error) {\n    console.warn('Cache unavailable, fetching from database');\n  }\n\n  return db.findUser(id);\n};\n```\n\n### ❌ Cache Key Collisions\n\n```typescript\n// ❌ Ambiguous keys\nawait redis.set('123', user);  // user? product? order?\n\n// ✅ Namespaced keys\nawait redis.set('user:123', JSON.stringify(user));\nawait redis.set('product:123', JSON.stringify(product));\n```\n\n## Best Practices\n\n### Cache Key Naming\n\n```typescript\n// Hierarchical namespace\nconst generateKey = {\n  user: (id: string) => `user:${id}`,\n  userOrders: (userId: string) => `user:${userId}:orders`,\n  product: (id: string) => `product:${id}`,\n  categoryProducts: (categoryId: string) => `category:${categoryId}:products`,\n  sessionData: (sessionId: string) => `session:${sessionId}`\n};\n\n// Usage\nawait redis.setex(generateKey.user('123'), 3600, JSON.stringify(user));\n```\n\n### Compress Large Values\n\n```typescript\nimport zlib from 'zlib';\nimport { promisify } from 'util';\n\nconst gzip = promisify(zlib.gzip);\nconst gunzip = promisify(zlib.gunzip);\n\nconst setCompressed = async (key: string, value: any, ttl: number): Promise<void> => {\n  const json = JSON.stringify(value);\n  const compressed = await gzip(json);\n\n  await redis.setex(key, ttl, compressed);\n};\n\nconst getCompressed = async (key: string): Promise<any> => {\n  const compressed = await redis.getBuffer(key);\n\n  if (!compressed) return null;\n\n  const decompressed = await gunzip(compressed);\n  return JSON.parse(decompressed.toString());\n};\n```\n\n### Cache Versioning\n\n```typescript\n// Include version in key\nconst CACHE_VERSION = 'v2';\n\nconst getCacheKey = (entity: string, id: string): string => {\n  return `${CACHE_VERSION}:${entity}:${id}`;\n};\n\n// When schema changes, increment version\n// Old cache keys automatically become invalid\nawait redis.setex(getCacheKey('user', '123'), 3600, JSON.stringify(user));\n```\n\n## References\n\n- [Caching Strategies](https://aws.amazon.com/caching/best-practices/)\n- [Redis Best Practices](https://redis.io/docs/manual/patterns/)\n- [HTTP Caching](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching)\n- [Cache Stampede](https://en.wikipedia.org/wiki/Cache_stampede)\n",
    "original/architecture/clean-architecture.md": "# Clean Architecture Guidelines\n\n## Overview\n\nClean Architecture, introduced by Robert C. Martin (Uncle Bob), is an architectural pattern that emphasizes separation of concerns through layers with strict dependency rules. The core principle: **dependencies point inward toward business logic**.\n\n## Core Principles\n\n### The Dependency Rule\n\n**Source code dependencies must point only inward, toward higher-level policies.**\n\n- Outer circles are mechanisms\n- Inner circles are policies\n- Inner circles know nothing about outer circles\n- Data formats from outer circles must not be used by inner circles\n\n### Circles of Clean Architecture\n\n**From Outside to Inside:**\n\n1. **Frameworks & Drivers** (outermost)\n   - UI, Database, Web, External Interfaces\n   - Details that change frequently\n\n2. **Interface Adapters**\n   - Controllers, Presenters, Gateways\n   - Convert data between use cases and external formats\n\n3. **Application Business Rules**\n   - Use Cases / Interactors\n   - Application-specific business rules\n\n4. **Enterprise Business Rules** (innermost)\n   - Entities\n   - Enterprise-wide business rules\n   - Most stable, least likely to change\n\n## Layer Responsibilities\n\n### Entities (Enterprise Business Rules)\n\n**What They Are:**\n- Core business objects\n- Encapsulate enterprise-wide critical rules\n- Least likely to change when something external changes\n\n**Characteristics:**\n- No dependencies on anything\n- Pure business logic\n- Can be used across many applications\n\n```typescript\nclass Loan {\n  constructor(\n    private principal: Money,\n    private rate: InterestRate,\n    private term: Term\n  ) {}\n\n  calculateMonthlyPayment(): Money {\n    // Pure business calculation\n    const monthlyRate = this.rate.monthly();\n    const months = this.term.inMonths();\n    return this.principal.monthlyPayment(monthlyRate, months);\n  }\n}\n```\n\n### Use Cases (Application Business Rules)\n\n**What They Are:**\n- Application-specific business rules\n- Orchestrate flow of data to/from entities\n- Direct entities to use enterprise rules\n\n**Characteristics:**\n- Depend only on entities\n- Independent of UI, database, frameworks\n- Changes to use cases don't affect entities\n\n```typescript\ninterface CreateOrderUseCase {\n  execute(request: CreateOrderRequest): Promise<CreateOrderResponse>;\n}\n\nclass CreateOrder implements CreateOrderUseCase {\n  constructor(\n    private orderRepository: OrderRepository,\n    private paymentGateway: PaymentGateway\n  ) {}\n\n  async execute(request: CreateOrderRequest): Promise<CreateOrderResponse> {\n    // Application orchestration logic\n    const order = new Order(request.items);\n    const payment = await this.paymentGateway.process(order.total);\n\n    if (payment.successful) {\n      await this.orderRepository.save(order);\n      return { orderId: order.id, status: 'confirmed' };\n    }\n\n    return { orderId: null, status: 'payment-failed' };\n  }\n}\n```\n\n### Interface Adapters\n\n**What They Are:**\n- Convert data between use case and external world formats\n- Controllers, Presenters, Gateways\n\n**Characteristics:**\n- Depend on use cases, not on frameworks\n- Transform external data to use case format\n- Transform use case results to external format\n\n```typescript\nclass OrderController {\n  constructor(private createOrderUseCase: CreateOrderUseCase) {}\n\n  async handleRequest(httpRequest: HttpRequest): Promise<HttpResponse> {\n    // Adapt HTTP to use case\n    const request: CreateOrderRequest = {\n      items: httpRequest.body.items.map(item => ({\n        productId: item.id,\n        quantity: item.qty\n      }))\n    };\n\n    const response = await this.createOrderUseCase.execute(request);\n\n    // Adapt use case result to HTTP\n    return {\n      status: response.status === 'confirmed' ? 200 : 400,\n      body: { orderId: response.orderId }\n    };\n  }\n}\n```\n\n### Frameworks & Drivers\n\n**What They Are:**\n- External tools, frameworks, databases\n- Web framework, database, UI framework\n\n**Characteristics:**\n- Outermost layer\n- Details that can be swapped\n- Glue code connecting to inner layers\n\n## Dependency Inversion\n\n### The Problem\n\nHigher-level policies shouldn't depend on lower-level details.\n\n❌ **Wrong Direction:**\n```typescript\nclass OrderService {\n  async createOrder(data: any) {\n    const db = new PostgreSQLDatabase(); // Direct dependency\n    await db.save(data);\n  }\n}\n```\n\n### The Solution\n\nDefine interfaces in inner layers, implement in outer layers.\n\n✅ **Correct Direction:**\n```typescript\n// Inner layer defines interface\ninterface OrderRepository {\n  save(order: Order): Promise<void>;\n}\n\n// Use case depends on abstraction\nclass CreateOrderUseCase {\n  constructor(private repository: OrderRepository) {}\n\n  async execute(request: CreateOrderRequest) {\n    const order = new Order(request);\n    await this.repository.save(order); // Depends on abstraction\n  }\n}\n\n// Outer layer implements interface\nclass PostgreSQLOrderRepository implements OrderRepository {\n  async save(order: Order): Promise<void> {\n    // PostgreSQL specific implementation\n  }\n}\n```\n\n## Best Practices\n\n### Independent of Frameworks\n\n✅ **Framework as Tool:**\n- Use frameworks, don't marry them\n- Business logic doesn't depend on framework existence\n- Can change frameworks without rewriting business logic\n\n❌ **Framework as Architecture:**\n- Don't inherit from framework base classes in business logic\n- Don't let framework dictate your architecture\n\n### Independent of UI\n\n✅ **UI Agnostic:**\n- Business logic works with any UI\n- Same use cases for web, mobile, CLI, API\n- UI is a plugin to business logic\n\n❌ **UI Coupled:**\n- Business logic in controllers or views\n- Different logic for different UIs\n\n### Independent of Database\n\n✅ **Storage Agnostic:**\n- Business rules don't care about storage\n- Can swap databases without changing use cases\n- Database is a detail, not a dependency\n\n❌ **Database Coupled:**\n- Business logic depends on SQL or ORM\n- Domain objects are database entities\n\n### Testable\n\n✅ **Easy Testing:**\n- Test business rules without UI, database, web server\n- Test use cases with mocked repositories\n- Test entities with pure unit tests\n\n❌ **Hard Testing:**\n- Need to spin up database for unit tests\n- Need to start web server for logic tests\n- Can't test without external dependencies\n\n## Folder Structure Example\n\n```\nsrc/\n├── domain/                 # Enterprise Business Rules\n│   ├── entities/\n│   │   ├── Order.ts\n│   │   └── Customer.ts\n│   └── value-objects/\n│       ├── Money.ts\n│       └── Email.ts\n├── application/           # Application Business Rules\n│   ├── use-cases/\n│   │   ├── CreateOrder.ts\n│   │   └── GetOrderHistory.ts\n│   └── ports/            # Interfaces (ports)\n│       ├── OrderRepository.ts\n│       └── PaymentGateway.ts\n├── adapters/             # Interface Adapters\n│   ├── controllers/\n│   │   └── OrderController.ts\n│   ├── presenters/\n│   │   └── OrderPresenter.ts\n│   └── gateways/\n│       └── StripePaymentGateway.ts\n├── infrastructure/       # Frameworks & Drivers\n│   ├── database/\n│   │   └── PostgreSQLOrderRepository.ts\n│   ├── web/\n│   │   └── ExpressServer.ts\n│   └── config/\n│       └── AppConfig.ts\n└── main/                 # Composition Root\n    └── index.ts          # Wire everything together\n```\n\n## Crossing Boundaries\n\n### Data Transfer Objects (DTOs)\n\nUse simple data structures to cross boundaries:\n\n```typescript\n// Use case request (adapter → use case)\ninterface CreateOrderRequest {\n  customerId: string;\n  items: Array<{\n    productId: string;\n    quantity: number;\n  }>;\n}\n\n// Use case response (use case → adapter)\ninterface CreateOrderResponse {\n  orderId: string;\n  status: 'confirmed' | 'payment-failed';\n  total: number;\n}\n```\n\n### Avoid Passing Entities\n\n❌ **Don't:**\n```typescript\n// Don't pass domain entities across boundaries\nfunction handleHttpRequest(req): Order {\n  return createOrder(req); // Returns entity\n}\n```\n\n✅ **Do:**\n```typescript\n// Use DTOs at boundaries\nfunction handleHttpRequest(req): OrderDTO {\n  const order = createOrder(req);\n  return toDTO(order); // Convert to DTO\n}\n```\n\n## Common Pitfalls\n\n❌ **Leaking Abstractions:** Database models leaking into use cases\n❌ **God Use Cases:** Single use case doing everything\n❌ **Anemic Domain:** All logic in use cases, entities are just data\n❌ **Framework Coupling:** Inheriting from framework classes in domain\n❌ **Skipping Layers:** Controllers directly accessing repositories\n❌ **Wrong Dependencies:** Use cases depending on infrastructure\n\n## When to Use Clean Architecture\n\n✅ **Good For:**\n- Long-lived applications\n- Complex business domains\n- Applications requiring high testability\n- Projects where business rules change frequently\n- Systems with multiple UIs or integration points\n\n❌ **Overkill For:**\n- Simple CRUD applications\n- Prototypes or short-lived experiments\n- Small microservices with trivial logic\n- Applications with stable, simple requirements\n\n## Benefits\n\n✅ Independent of frameworks\n✅ Testable business logic\n✅ Independent of UI\n✅ Independent of database\n✅ Independent of external agencies\n✅ Screaming architecture (intent is clear)\n✅ Easy to understand and reason about\n✅ Supports multiple UIs and databases\n\n## Trade-offs\n\n⚠️ More files and indirection\n⚠️ Initial development may feel slower\n⚠️ Requires discipline to maintain boundaries\n⚠️ May be over-engineering for simple domains\n⚠️ Team must understand the pattern\n\n## Key Takeaways\n\n1. **Dependencies point inward** - This is non-negotiable\n2. **Business rules at center** - Isolated from details\n3. **Frameworks are details** - Use, don't depend on\n4. **Testability is paramount** - Test without external dependencies\n5. **Screaming architecture** - Purpose is obvious from structure\n",
    "original/architecture/database-design-patterns.md": "# Database Design Patterns & Best Practices\n\n## Schema Design\n\n### Normalization\n\n```sql\n-- ❌ Denormalized (data duplication)\nCREATE TABLE orders (\n  id UUID PRIMARY KEY,\n  customer_name VARCHAR(100),\n  customer_email VARCHAR(100),\n  customer_address TEXT,\n  order_date TIMESTAMP,\n  total DECIMAL(10, 2)\n);\n-- Customer data duplicated in every order\n\n-- ✅ Normalized (3NF)\nCREATE TABLE customers (\n  id UUID PRIMARY KEY,\n  name VARCHAR(100) NOT NULL,\n  email VARCHAR(100) UNIQUE NOT NULL,\n  address TEXT\n);\n\nCREATE TABLE orders (\n  id UUID PRIMARY KEY,\n  customer_id UUID NOT NULL REFERENCES customers(id),\n  order_date TIMESTAMP DEFAULT NOW(),\n  total DECIMAL(10, 2) NOT NULL\n);\n\nCREATE TABLE order_items (\n  id UUID PRIMARY KEY,\n  order_id UUID NOT NULL REFERENCES orders(id) ON DELETE CASCADE,\n  product_id UUID NOT NULL REFERENCES products(id),\n  quantity INT NOT NULL,\n  price DECIMAL(10, 2) NOT NULL\n);\n```\n\n### Selective Denormalization for Performance\n\n```sql\n-- When reads vastly outnumber writes, denormalize selectively\n\nCREATE TABLE orders (\n  id UUID PRIMARY KEY,\n  customer_id UUID NOT NULL REFERENCES customers(id),\n  customer_name VARCHAR(100) NOT NULL,  -- Denormalized for query performance\n  order_date TIMESTAMP DEFAULT NOW(),\n  total DECIMAL(10, 2) NOT NULL,\n  item_count INT NOT NULL DEFAULT 0     -- Denormalized count\n);\n\n-- Update denormalized fields with triggers\nCREATE OR REPLACE FUNCTION update_order_item_count()\nRETURNS TRIGGER AS $$\nBEGIN\n  UPDATE orders\n  SET item_count = (\n    SELECT COUNT(*) FROM order_items WHERE order_id = NEW.order_id\n  )\n  WHERE id = NEW.order_id;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER order_items_count_trigger\nAFTER INSERT OR DELETE ON order_items\nFOR EACH ROW EXECUTE FUNCTION update_order_item_count();\n```\n\n## Evolutionary Database Design\n\n### Migration-Based Changes\n\n```sql\n-- migrations/001_create_users_table.sql\nCREATE TABLE users (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  email VARCHAR(255) UNIQUE NOT NULL,\n  created_at TIMESTAMP DEFAULT NOW()\n);\n\n-- migrations/002_add_name_to_users.sql\nALTER TABLE users\nADD COLUMN name VARCHAR(100);\n\n-- migrations/003_make_name_required.sql\n-- Step 1: Set default for existing rows\nUPDATE users SET name = 'Unknown' WHERE name IS NULL;\n\n-- Step 2: Add NOT NULL constraint\nALTER TABLE users\nALTER COLUMN name SET NOT NULL;\n```\n\n### Zero-Downtime Migrations\n\n```sql\n-- Adding a column with default value (instant in modern databases)\nALTER TABLE users\nADD COLUMN status VARCHAR(20) DEFAULT 'active';\n\n-- Removing a column (multi-step for safety)\n\n-- Step 1: Stop writing to column (deploy code change)\n-- Deploy application code that ignores old_column\n\n-- Step 2: Drop column (after deploy confirms success)\nALTER TABLE users DROP COLUMN old_column;\n\n-- Renaming a column (parallel change pattern)\n\n-- Step 1: Add new column\nALTER TABLE users ADD COLUMN full_name VARCHAR(200);\n\n-- Step 2: Backfill data\nUPDATE users SET full_name = name WHERE full_name IS NULL;\n\n-- Step 3: Deploy code using both columns\n-- Application writes to both, reads from full_name\n\n-- Step 4: Make new column NOT NULL\nALTER TABLE users ALTER COLUMN full_name SET NOT NULL;\n\n-- Step 5: Deploy code using only new column\n\n-- Step 6: Drop old column\nALTER TABLE users DROP COLUMN name;\n```\n\n### Migration Tool Example\n\n```typescript\n// migrations/index.ts\nimport { Kysely, sql } from 'kysely';\n\nexport async function up(db: Kysely<any>): Promise<void> {\n  await db.schema\n    .createTable('users')\n    .addColumn('id', 'uuid', (col) =>\n      col.primaryKey().defaultTo(sql`gen_random_uuid()`)\n    )\n    .addColumn('email', 'varchar(255)', (col) =>\n      col.notNull().unique()\n    )\n    .addColumn('created_at', 'timestamp', (col) =>\n      col.defaultTo(sql`now()`)\n    )\n    .execute();\n\n  await db.schema\n    .createIndex('users_email_idx')\n    .on('users')\n    .column('email')\n    .execute();\n}\n\nexport async function down(db: Kysely<any>): Promise<void> {\n  await db.schema.dropTable('users').execute();\n}\n```\n\n## Indexing Strategies\n\n### Single-Column Indexes\n\n```sql\n-- ❌ No index - full table scan\nSELECT * FROM users WHERE email = 'user@example.com';\n\n-- ✅ Add index\nCREATE INDEX idx_users_email ON users(email);\n\n-- Query now uses index seek\nSELECT * FROM users WHERE email = 'user@example.com';\n```\n\n### Composite Indexes\n\n```sql\n-- Query filtering by multiple columns\nSELECT * FROM orders\nWHERE user_id = '123' AND status = 'pending';\n\n-- ✅ Composite index (order matters!)\nCREATE INDEX idx_orders_user_status ON orders(user_id, status);\n\n-- This query uses the index\nSELECT * FROM orders WHERE user_id = '123' AND status = 'pending';\n\n-- This query also uses the index (leftmost prefix)\nSELECT * FROM orders WHERE user_id = '123';\n\n-- ❌ This query does NOT use the index\nSELECT * FROM orders WHERE status = 'pending';  -- status is not leftmost\n\n-- For both queries, create index with different order\nCREATE INDEX idx_orders_status_user ON orders(status, user_id);\n```\n\n### Covering Indexes\n\n```sql\n-- ❌ Index seek + table lookup\nCREATE INDEX idx_users_email ON users(email);\n\nSELECT id, name FROM users WHERE email = 'user@example.com';\n-- Finds row via index, then fetches name from table\n\n-- ✅ Covering index (includes all needed columns)\nCREATE INDEX idx_users_email_covering ON users(email) INCLUDE (name);\n\nSELECT id, name FROM users WHERE email = 'user@example.com';\n-- All data in index, no table lookup needed\n```\n\n### Partial Indexes\n\n```sql\n-- Index only active users\nCREATE INDEX idx_active_users\nON users(email)\nWHERE active = true;\n\n-- Smaller index, faster lookups for common case\nSELECT * FROM users WHERE email = 'user@example.com' AND active = true;\n```\n\n### Analyze Index Usage\n\n```sql\n-- PostgreSQL: Check index usage\nSELECT\n  schemaname,\n  tablename,\n  indexname,\n  idx_scan as index_scans,\n  idx_tup_read as tuples_read,\n  idx_tup_fetch as tuples_fetched\nFROM pg_stat_user_indexes\nORDER BY idx_scan ASC;\n\n-- Find unused indexes\nSELECT\n  schemaname,\n  tablename,\n  indexname\nFROM pg_stat_user_indexes\nWHERE idx_scan = 0\n  AND indexrelname NOT LIKE 'pg_toast%';\n```\n\n## Polyglot Persistence\n\n### Choosing the Right Database\n\n```typescript\n// Relational (PostgreSQL) - Structured data, complex queries\nclass UserRepository {\n  async findByEmail(email: string): Promise<User> {\n    return db.query(\n      'SELECT * FROM users WHERE email = $1',\n      [email]\n    );\n  }\n\n  async getUserOrders(userId: string): Promise<Order[]> {\n    return db.query(`\n      SELECT o.*, array_agg(oi.*) as items\n      FROM orders o\n      JOIN order_items oi ON o.id = oi.order_id\n      WHERE o.user_id = $1\n      GROUP BY o.id\n    `, [userId]);\n  }\n}\n\n// Key-Value (Redis) - Caching, session storage\nclass SessionStore {\n  constructor(private redis: Redis) {}\n\n  async set(sessionId: string, data: SessionData): Promise<void> {\n    await this.redis.setex(\n      `session:${sessionId}`,\n      3600,\n      JSON.stringify(data)\n    );\n  }\n\n  async get(sessionId: string): Promise<SessionData | null> {\n    const data = await this.redis.get(`session:${sessionId}`);\n    return data ? JSON.parse(data) : null;\n  }\n}\n\n// Document (MongoDB) - Flexible schema, nested data\nclass ProductCatalog {\n  constructor(private mongo: MongoClient) {}\n\n  async addProduct(product: Product): Promise<void> {\n    await this.mongo.db().collection('products').insertOne({\n      name: product.name,\n      price: product.price,\n      attributes: product.attributes,  // Flexible nested structure\n      reviews: [],\n      metadata: {\n        createdAt: new Date(),\n        updatedAt: new Date()\n      }\n    });\n  }\n}\n\n// Search Engine (Elasticsearch) - Full-text search\nclass ProductSearch {\n  constructor(private es: ElasticsearchClient) {}\n\n  async search(query: string): Promise<Product[]> {\n    const result = await this.es.search({\n      index: 'products',\n      body: {\n        query: {\n          multi_match: {\n            query,\n            fields: ['name^2', 'description', 'category']\n          }\n        }\n      }\n    });\n\n    return result.hits.hits.map(hit => hit._source);\n  }\n}\n\n// Graph Database (Neo4j) - Relationships, social networks\nclass SocialGraph {\n  async getFriendRecommendations(userId: string): Promise<User[]> {\n    return neo4j.run(`\n      MATCH (user:User {id: $userId})-[:FRIENDS_WITH]->(friend)-[:FRIENDS_WITH]->(recommendation)\n      WHERE NOT (user)-[:FRIENDS_WITH]->(recommendation)\n        AND user <> recommendation\n      RETURN recommendation, count(*) as mutual_friends\n      ORDER BY mutual_friends DESC\n      LIMIT 10\n    `, { userId });\n  }\n}\n```\n\n## Connection Pooling\n\n### PostgreSQL Pool Configuration\n\n```typescript\nimport { Pool } from 'pg';\n\nconst pool = new Pool({\n  host: process.env.DB_HOST,\n  port: parseInt(process.env.DB_PORT || '5432'),\n  database: process.env.DB_NAME,\n  user: process.env.DB_USER,\n  password: process.env.DB_PASSWORD,\n\n  // Pool configuration\n  max: 20,                      // Maximum connections\n  min: 5,                       // Minimum idle connections\n  idleTimeoutMillis: 30000,     // Close idle connections after 30s\n  connectionTimeoutMillis: 2000, // Error if can't connect in 2s\n  maxUses: 7500,                // Reconnect after N uses (prevents leaks)\n});\n\n// Proper connection handling\nconst getUser = async (id: string): Promise<User> => {\n  const client = await pool.connect();\n\n  try {\n    const result = await client.query(\n      'SELECT * FROM users WHERE id = $1',\n      [id]\n    );\n    return result.rows[0];\n  } finally {\n    client.release(); // Always release back to pool\n  }\n};\n\n// Graceful shutdown\nprocess.on('SIGTERM', async () => {\n  await pool.end();\n  process.exit(0);\n});\n```\n\n## Transaction Management\n\n### ACID Transactions\n\n```typescript\n// Single transaction\nconst transferMoney = async (fromId: string, toId: string, amount: number) => {\n  const client = await pool.connect();\n\n  try {\n    await client.query('BEGIN');\n\n    // Debit from account\n    await client.query(\n      'UPDATE accounts SET balance = balance - $1 WHERE id = $2',\n      [amount, fromId]\n    );\n\n    // Credit to account\n    await client.query(\n      'UPDATE accounts SET balance = balance + $1 WHERE id = $2',\n      [amount, toId]\n    );\n\n    await client.query('COMMIT');\n  } catch (error) {\n    await client.query('ROLLBACK');\n    throw error;\n  } finally {\n    client.release();\n  }\n};\n```\n\n### Optimistic Locking\n\n```sql\n-- Add version column\nALTER TABLE products ADD COLUMN version INT DEFAULT 1;\n\n-- Update with version check\nUPDATE products\nSET stock = stock - 1, version = version + 1\nWHERE id = '123' AND version = 5;\n\n-- Returns 0 rows if version doesn't match (concurrent update detected)\n```\n\n```typescript\nconst updateProduct = async (id: string, currentVersion: number, updates: Partial<Product>) => {\n  const result = await db.query(`\n    UPDATE products\n    SET name = $1, price = $2, version = version + 1\n    WHERE id = $3 AND version = $4\n    RETURNING *\n  `, [updates.name, updates.price, id, currentVersion]);\n\n  if (result.rows.length === 0) {\n    throw new Error('Concurrent modification detected');\n  }\n\n  return result.rows[0];\n};\n```\n\n## Query Optimization\n\n### Use EXPLAIN ANALYZE\n\n```sql\nEXPLAIN ANALYZE\nSELECT u.name, COUNT(o.id) as order_count\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id\nWHERE u.created_at > '2024-01-01'\nGROUP BY u.id, u.name\nHAVING COUNT(o.id) > 5;\n\n-- Output shows:\n-- - Seq Scan vs Index Scan\n-- - Actual execution time\n-- - Rows processed vs estimated\n```\n\n### Avoid N+1 Queries\n\n```typescript\n// ❌ N+1 queries\nconst getUsersWithOrders = async () => {\n  const users = await db.query('SELECT * FROM users');\n\n  for (const user of users) {\n    user.orders = await db.query(\n      'SELECT * FROM orders WHERE user_id = $1',\n      [user.id]\n    ); // N queries!\n  }\n\n  return users;\n};\n\n// ✅ Single query with JOIN\nconst getUsersWithOrders = async () => {\n  return db.query(`\n    SELECT\n      u.*,\n      json_agg(o.*) as orders\n    FROM users u\n    LEFT JOIN orders o ON u.id = o.user_id\n    GROUP BY u.id\n  `);\n};\n\n// ✅ Or use DataLoader (batching)\nimport DataLoader from 'dataloader';\n\nconst orderLoader = new DataLoader(async (userIds: string[]) => {\n  const orders = await db.query(\n    'SELECT * FROM orders WHERE user_id = ANY($1)',\n    [userIds]\n  );\n\n  // Group by user_id\n  const ordersByUser = new Map();\n  orders.forEach(order => {\n    if (!ordersByUser.has(order.user_id)) {\n      ordersByUser.set(order.user_id, []);\n    }\n    ordersByUser.get(order.user_id).push(order);\n  });\n\n  return userIds.map(id => ordersByUser.get(id) || []);\n});\n```\n\n### Pagination\n\n```typescript\n// ❌ OFFSET pagination (slow for large offsets)\nconst getUsers = async (page: number, pageSize: number) => {\n  const offset = page * pageSize;\n  return db.query(\n    'SELECT * FROM users ORDER BY created_at DESC LIMIT $1 OFFSET $2',\n    [pageSize, offset]\n  );\n  // Page 1000: scans and skips 1,000,000 rows!\n};\n\n// ✅ Cursor-based pagination (keyset pagination)\nconst getUsers = async (afterCursor?: string, pageSize: number = 20) => {\n  const query = afterCursor\n    ? 'SELECT * FROM users WHERE created_at < $1 ORDER BY created_at DESC LIMIT $2'\n    : 'SELECT * FROM users ORDER BY created_at DESC LIMIT $1';\n\n  const params = afterCursor\n    ? [afterCursor, pageSize]\n    : [pageSize];\n\n  const users = await db.query(query, params);\n\n  return {\n    users,\n    nextCursor: users[users.length - 1]?.created_at\n  };\n};\n```\n\n## Data Modeling Patterns\n\n### Soft Delete\n\n```sql\n-- Add deleted_at column\nALTER TABLE users\nADD COLUMN deleted_at TIMESTAMP NULL;\n\nCREATE INDEX idx_users_deleted_at ON users(deleted_at)\nWHERE deleted_at IS NULL;\n\n-- Soft delete\nUPDATE users SET deleted_at = NOW() WHERE id = '123';\n\n-- Query only active records\nSELECT * FROM users WHERE deleted_at IS NULL;\n\n-- Include deleted records\nSELECT * FROM users;  -- Shows all\n```\n\n### Audit Trail\n\n```sql\nCREATE TABLE audit_log (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  table_name VARCHAR(50) NOT NULL,\n  record_id UUID NOT NULL,\n  action VARCHAR(10) NOT NULL,  -- INSERT, UPDATE, DELETE\n  old_values JSONB,\n  new_values JSONB,\n  changed_by UUID REFERENCES users(id),\n  changed_at TIMESTAMP DEFAULT NOW()\n);\n\nCREATE INDEX idx_audit_log_table_record ON audit_log(table_name, record_id);\n\n-- Trigger to log changes\nCREATE OR REPLACE FUNCTION audit_trigger_func()\nRETURNS TRIGGER AS $$\nBEGIN\n  IF (TG_OP = 'DELETE') THEN\n    INSERT INTO audit_log (table_name, record_id, action, old_values, changed_by)\n    VALUES (TG_TABLE_NAME, OLD.id, 'DELETE', row_to_json(OLD), current_setting('app.current_user_id')::UUID);\n    RETURN OLD;\n  ELSIF (TG_OP = 'UPDATE') THEN\n    INSERT INTO audit_log (table_name, record_id, action, old_values, new_values, changed_by)\n    VALUES (TG_TABLE_NAME, NEW.id, 'UPDATE', row_to_json(OLD), row_to_json(NEW), current_setting('app.current_user_id')::UUID);\n    RETURN NEW;\n  ELSIF (TG_OP = 'INSERT') THEN\n    INSERT INTO audit_log (table_name, record_id, action, new_values, changed_by)\n    VALUES (TG_TABLE_NAME, NEW.id, 'INSERT', row_to_json(NEW), current_setting('app.current_user_id')::UUID);\n    RETURN NEW;\n  END IF;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER users_audit_trigger\nAFTER INSERT OR UPDATE OR DELETE ON users\nFOR EACH ROW EXECUTE FUNCTION audit_trigger_func();\n```\n\n## Anti-Patterns\n\n### ❌ God Table\n\n```sql\n-- Avoid tables with 100+ columns\nCREATE TABLE users (\n  id UUID,\n  -- 100 more columns of mixed concerns\n  billing_address TEXT,\n  shipping_address TEXT,\n  payment_method VARCHAR(50),\n  subscription_tier VARCHAR(20),\n  -- ...\n);\n\n-- ✅ Split into focused tables\nCREATE TABLE users (id UUID, email VARCHAR, name VARCHAR);\nCREATE TABLE user_addresses (user_id UUID, type VARCHAR, address TEXT);\nCREATE TABLE user_subscriptions (user_id UUID, tier VARCHAR, status VARCHAR);\n```\n\n### ❌ Entity-Attribute-Value (EAV)\n\n```sql\n-- ❌ Flexible but unqueryable\nCREATE TABLE entity_attributes (\n  entity_id UUID,\n  attribute_name VARCHAR(50),\n  attribute_value TEXT\n);\n\n-- ✅ Use JSONB for flexible schema\nCREATE TABLE products (\n  id UUID PRIMARY KEY,\n  name VARCHAR(200),\n  price DECIMAL(10, 2),\n  attributes JSONB\n);\n\nCREATE INDEX idx_products_attributes ON products USING GIN (attributes);\n\nSELECT * FROM products WHERE attributes @> '{\"color\": \"red\"}';\n```\n\n### ❌ UUID as VARCHAR\n\n```sql\n-- ❌ Wastes space and performance\nCREATE TABLE users (\n  id VARCHAR(36) PRIMARY KEY  -- 36 bytes\n);\n\n-- ✅ Use native UUID type\nCREATE TABLE users (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid()  -- 16 bytes\n);\n```\n\n## References\n\n- [Evolutionary Database Design](https://martinfowler.com/articles/evodb.html)\n- [Polyglot Persistence](https://martinfowler.com/bliki/PolyglotPersistence.html)\n- [Use The Index, Luke](https://use-the-index-luke.com/)\n- [PostgreSQL Performance](https://www.postgresql.org/docs/current/performance-tips.html)\n",
    "original/architecture/domain-driven-design.md": "# Domain-Driven Design (DDD) Guidelines\n\n## Overview\n\nDomain-Driven Design is a strategic approach to developing software for complex domains. It emphasizes collaboration between technical and domain experts, focusing on a shared understanding of the problem space.\n\n## Core Concepts\n\n### Ubiquitous Language\n\n**Definition:** A common language shared by developers and domain experts, used consistently in code, conversations, and documentation.\n\n**Purpose:**\n- Eliminate translation between technical and business terminology\n- Reduce misunderstandings\n- Make code more expressive and maintainable\n\n**Best Practices:**\n✅ Use domain terms in class/method names\n✅ Avoid technical jargon when business terms exist\n✅ Update code when language evolves\n✅ Document terms in a glossary\n\n❌ Don't use generic names (Manager, Handler, Processor)\n❌ Don't create technical abstractions that obscure domain concepts\n\n### Bounded Context\n\n**Definition:** A boundary within which a particular model is defined and applicable. Each context maintains its own unified model and ubiquitous language.\n\n**Purpose:**\n- Divide large systems into manageable sections\n- Recognize that total unification isn't feasible or cost-effective\n- Maintain model integrity within boundaries\n\n**Identifying Boundaries:**\n- Human culture and language differences\n- Organizational structure and team communication patterns\n- Technical representation differences\n- Conceptual distinctions within the domain\n\n**Example:**\nIn an electricity utility:\n- \"Meter\" in customer service = customer relationship\n- \"Meter\" in field operations = physical equipment\n- \"Meter\" in billing = usage recording device\n\nThese are different bounded contexts.\n\n### Context Mapping\n\n**Definition:** Mechanisms to translate between different Bounded Contexts that share common concepts but model them distinctly.\n\n**Patterns:**\n\n**Shared Kernel:**\n- Two contexts share a subset of the domain model\n- Requires coordination between teams\n- Changes require mutual agreement\n\n**Customer-Supplier:**\n- Downstream context depends on upstream\n- Upstream team provides what downstream needs\n- Clear customer-supplier relationship\n\n**Conformist:**\n- Downstream conforms to upstream model\n- Used when upstream won't accommodate changes\n- Reduces integration complexity\n\n**Anti-Corruption Layer:**\n- Isolate your model from external systems\n- Translate between your model and external concepts\n- Protects domain purity\n\n**Open Host Service:**\n- Define protocol for accessing your subsystem\n- Often REST API or message-based integration\n- Make it easy for other contexts to integrate\n\n**Published Language:**\n- Well-documented shared language between contexts\n- Often XML schemas or JSON formats\n- Reduces coupling through standardization\n\n## Strategic Design\n\n### Core Domain\n\n**Definition:** The primary area of focus that provides competitive advantage.\n\n**Characteristics:**\n- Most valuable to the business\n- Requires best developers and attention\n- Custom-built, not purchased\n- Where innovation happens\n\n**Investment Strategy:**\nInvest heavily in core domain with:\n- Best team members\n- Most time and resources\n- Sophisticated modeling\n- Rich ubiquitous language\n\n### Supporting Subdomain\n\n**Definition:** Necessary but not core to competitive advantage.\n\n**Characteristics:**\n- Important but not differentiating\n- May be purchased or built simply\n- Less modeling sophistication needed\n\n### Generic Subdomain\n\n**Definition:** Common functionality without business differentiation.\n\n**Characteristics:**\n- Solved problems (auth, logging, email)\n- Should use off-the-shelf solutions\n- Minimal custom development\n- Don't waste effort here\n\n## Tactical Design Patterns\n\n### Entities\n\n**Definition:** Objects with identity that persists over time.\n\n**Characteristics:**\n- Defined by identity, not attributes\n- Mutable\n- Continuity through lifecycle\n\n```typescript\nclass Order {\n  constructor(\n    private readonly id: OrderId,\n    private items: OrderItem[],\n    private status: OrderStatus\n  ) {}\n\n  addItem(item: OrderItem) {\n    if (this.status !== OrderStatus.Draft) {\n      throw new Error('Cannot modify confirmed order');\n    }\n    this.items.push(item);\n  }\n}\n```\n\n### Value Objects\n\n**Definition:** Objects defined by their attributes with no conceptual identity.\n\n**Characteristics:**\n- Immutable\n- Defined by values, not identity\n- Can be freely replaced\n- Often shared\n\n```typescript\nclass Money {\n  constructor(\n    readonly amount: number,\n    readonly currency: Currency\n  ) {}\n\n  add(other: Money): Money {\n    if (this.currency !== other.currency) {\n      throw new Error('Currency mismatch');\n    }\n    return new Money(this.amount + other.amount, this.currency);\n  }\n}\n```\n\n### Aggregates\n\n**Definition:** Cluster of entities and value objects with defined boundary and root entity.\n\n**Characteristics:**\n- Root entity controls access\n- Maintains invariants\n- Unit of consistency\n- Transaction boundary\n\n```typescript\nclass Order {\n  private items: OrderItem[] = [];\n\n  addItem(product: Product, quantity: number) {\n    // Aggregate ensures invariants\n    if (this.totalItems() + quantity > MAX_ITEMS) {\n      throw new Error('Too many items');\n    }\n\n    const item = new OrderItem(product, quantity);\n    this.items.push(item);\n  }\n\n  // Only Order can modify its items\n  private totalItems(): number {\n    return this.items.reduce((sum, item) => sum + item.quantity, 0);\n  }\n}\n```\n\n### Domain Events\n\n**Definition:** Something that happened in the domain that domain experts care about.\n\n**Characteristics:**\n- Past tense naming (OrderPlaced, PaymentReceived)\n- Immutable\n- Carries relevant information\n- May trigger side effects\n\n```typescript\nclass OrderPlacedEvent {\n  constructor(\n    readonly orderId: OrderId,\n    readonly customerId: CustomerId,\n    readonly total: Money,\n    readonly occurredAt: Date\n  ) {}\n}\n```\n\n### Repositories\n\n**Definition:** Provides illusion of in-memory collection of aggregates.\n\n**Characteristics:**\n- Persistence abstraction\n- Works with aggregate roots only\n- Provides query methods\n\n```typescript\ninterface OrderRepository {\n  findById(id: OrderId): Promise<Order | null>;\n  save(order: Order): Promise<void>;\n  findByCustomer(customerId: CustomerId): Promise<Order[]>;\n}\n```\n\n### Domain Services\n\n**Definition:** Operations that don't naturally fit within entities or value objects.\n\n**Characteristics:**\n- Stateless\n- Operates on domain objects\n- Captures domain concepts\n\n```typescript\nclass TransferMoneyService {\n  transfer(from: Account, to: Account, amount: Money) {\n    from.withdraw(amount);\n    to.deposit(amount);\n    // Coordinates between aggregates\n  }\n}\n```\n\n## Best Practices\n\n### Model-Driven Design\n\n✅ **DO:**\n- Model reflects domain expert knowledge\n- Use ubiquitous language in code\n- Iterate model with domain experts\n- Refactor toward deeper insight\n\n❌ **DON'T:**\n- Let database schema drive model\n- Use anemic domain models (just getters/setters)\n- Separate model from implementation\n- Create models in isolation from domain experts\n\n### Aggregate Design\n\n✅ **DO:**\n- Keep aggregates small\n- Reference other aggregates by ID only\n- Use eventual consistency between aggregates\n- Enforce invariants within aggregate\n\n❌ **DON'T:**\n- Create large aggregates with nested entities\n- Hold references to other aggregate roots\n- Require immediate consistency across aggregates\n- Put unrelated concepts in same aggregate\n\n### Bounded Context Integration\n\n✅ **DO:**\n- Make boundaries explicit\n- Use context maps\n- Implement anti-corruption layers\n- Publish integration events\n\n❌ **DON'T:**\n- Share domain model code between contexts\n- Assume same concepts mean same things\n- Create tight coupling between contexts\n- Ignore context boundaries\n\n## Common Pitfalls\n\n❌ **Anemic Domain Models:** Just data structures with no behavior\n❌ **God Objects:** Aggregates that do everything\n❌ **Ignoring Context Boundaries:** One model to rule them all\n❌ **Technical Abstractions:** Generic, meaningless names\n❌ **Premature Patterns:** Applying DDD to simple CRUD\n❌ **Isolating Developers:** Not collaborating with domain experts\n\n## When to Use DDD\n\n✅ **Good For:**\n- Complex business domains\n- Long-lived applications\n- Domains with ambiguous or evolving rules\n- Projects where domain understanding is competitive advantage\n\n❌ **Not Needed For:**\n- Simple CRUD applications\n- Technical/infrastructure systems\n- Well-understood commodity domains\n- Short-lived prototypes\n\n## Continuous Learning\n\nDDD is a journey of continuous discovery:\n- Regular conversations with domain experts\n- Refactoring toward deeper insight\n- Evolving ubiquitous language\n- Discovering implicit concepts\n- Clarifying boundaries\n",
    "original/architecture/event-driven-architecture.md": "# Event-Driven Architecture Patterns\n\n## Core Concepts\n\n### Events vs Commands\n\n```typescript\n// Command: Imperative, request for action\ninterface CreateOrderCommand {\n  userId: string;\n  items: OrderItem[];\n  shippingAddress: Address;\n}\n\n// Event: Past tense, something that happened\ninterface OrderCreatedEvent {\n  orderId: string;\n  userId: string;\n  items: OrderItem[];\n  timestamp: Date;\n}\n\n// Commands can be rejected\nconst handleCreateOrder = async (command: CreateOrderCommand) => {\n  if (command.items.length === 0) {\n    throw new Error('Cannot create empty order'); // Rejected\n  }\n  // Process command...\n  return publishEvent(new OrderCreatedEvent(/* ... */));\n};\n\n// Events are facts, cannot be rejected\nconst handleOrderCreated = async (event: OrderCreatedEvent) => {\n  // React to what happened\n  await updateInventory(event.items);\n  await sendConfirmationEmail(event.userId);\n};\n```\n\n### Event Structure\n\n```typescript\ninterface DomainEvent {\n  eventId: string;\n  eventType: string;\n  aggregateId: string;\n  aggregateType: string;\n  version: number;\n  timestamp: Date;\n  data: unknown;\n  metadata?: {\n    userId?: string;\n    correlationId?: string;\n    causationId?: string;\n  };\n}\n\n// Example event\nconst orderCreatedEvent: DomainEvent = {\n  eventId: 'evt_123',\n  eventType: 'OrderCreated',\n  aggregateId: 'order_456',\n  aggregateType: 'Order',\n  version: 1,\n  timestamp: new Date(),\n  data: {\n    userId: 'user_789',\n    total: 150.00,\n    items: [/* ... */]\n  },\n  metadata: {\n    userId: 'user_789',\n    correlationId: 'corr_123', // Groups related events\n    causationId: 'cmd_456'      // What caused this event\n  }\n};\n```\n\n## Event Sourcing\n\n### Aggregate with Event Sourcing\n\n```typescript\nabstract class AggregateRoot {\n  private uncommittedEvents: DomainEvent[] = [];\n  protected version = 0;\n\n  protected applyEvent(event: DomainEvent): void {\n    this.apply(event);\n    this.uncommittedEvents.push(event);\n    this.version++;\n  }\n\n  protected abstract apply(event: DomainEvent): void;\n\n  getUncommittedEvents(): DomainEvent[] {\n    return [...this.uncommittedEvents];\n  }\n\n  markEventsAsCommitted(): void {\n    this.uncommittedEvents = [];\n  }\n\n  loadFromHistory(events: DomainEvent[]): void {\n    events.forEach(event => {\n      this.apply(event);\n      this.version++;\n    });\n  }\n}\n\n// Order aggregate\nclass Order extends AggregateRoot {\n  private id: string;\n  private userId: string;\n  private items: OrderItem[] = [];\n  private status: OrderStatus = OrderStatus.PENDING;\n  private total = 0;\n\n  static create(userId: string, items: OrderItem[]): Order {\n    const order = new Order();\n    order.applyEvent({\n      eventId: generateId(),\n      eventType: 'OrderCreated',\n      aggregateId: generateId(),\n      aggregateType: 'Order',\n      version: 1,\n      timestamp: new Date(),\n      data: { userId, items }\n    });\n    return order;\n  }\n\n  ship(trackingNumber: string): void {\n    if (this.status !== OrderStatus.PAID) {\n      throw new Error('Can only ship paid orders');\n    }\n\n    this.applyEvent({\n      eventId: generateId(),\n      eventType: 'OrderShipped',\n      aggregateId: this.id,\n      aggregateType: 'Order',\n      version: this.version + 1,\n      timestamp: new Date(),\n      data: { trackingNumber }\n    });\n  }\n\n  protected apply(event: DomainEvent): void {\n    switch (event.eventType) {\n      case 'OrderCreated':\n        this.id = event.aggregateId;\n        this.userId = event.data.userId;\n        this.items = event.data.items;\n        this.total = this.items.reduce((sum, item) => sum + item.price, 0);\n        break;\n\n      case 'OrderPaid':\n        this.status = OrderStatus.PAID;\n        break;\n\n      case 'OrderShipped':\n        this.status = OrderStatus.SHIPPED;\n        break;\n\n      case 'OrderCancelled':\n        this.status = OrderStatus.CANCELLED;\n        break;\n    }\n  }\n}\n```\n\n### Event Store\n\n```typescript\ninterface EventStore {\n  save(aggregateId: string, events: DomainEvent[], expectedVersion: number): Promise<void>;\n  getEvents(aggregateId: string): Promise<DomainEvent[]>;\n  getAllEvents(afterVersion?: number): Promise<DomainEvent[]>;\n}\n\nclass InMemoryEventStore implements EventStore {\n  private events = new Map<string, DomainEvent[]>();\n\n  async save(aggregateId: string, events: DomainEvent[], expectedVersion: number): Promise<void> {\n    const existing = this.events.get(aggregateId) || [];\n\n    if (existing.length !== expectedVersion) {\n      throw new Error('Concurrency conflict');\n    }\n\n    this.events.set(aggregateId, [...existing, ...events]);\n  }\n\n  async getEvents(aggregateId: string): Promise<DomainEvent[]> {\n    return this.events.get(aggregateId) || [];\n  }\n\n  async getAllEvents(afterVersion: number = 0): Promise<DomainEvent[]> {\n    return Array.from(this.events.values())\n      .flat()\n      .filter(e => e.version > afterVersion)\n      .sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());\n  }\n}\n\n// Repository using event store\nclass OrderRepository {\n  constructor(private eventStore: EventStore) {}\n\n  async save(order: Order): Promise<void> {\n    const events = order.getUncommittedEvents();\n\n    await this.eventStore.save(\n      order.getId(),\n      events,\n      order.getVersion() - events.length\n    );\n\n    order.markEventsAsCommitted();\n  }\n\n  async findById(orderId: string): Promise<Order | null> {\n    const events = await this.eventStore.getEvents(orderId);\n\n    if (events.length === 0) {\n      return null;\n    }\n\n    const order = new Order();\n    order.loadFromHistory(events);\n\n    return order;\n  }\n}\n```\n\n## CQRS (Command Query Responsibility Segregation)\n\n### Separate Read and Write Models\n\n```typescript\n// Write Model (Commands)\nclass OrderCommandHandler {\n  constructor(\n    private orderRepo: OrderRepository,\n    private eventBus: EventBus\n  ) {}\n\n  async handleCreateOrder(command: CreateOrderCommand): Promise<string> {\n    const order = Order.create(command.userId, command.items);\n\n    await this.orderRepo.save(order);\n\n    // Publish events for read model updates\n    order.getUncommittedEvents().forEach(event => {\n      this.eventBus.publish(event);\n    });\n\n    return order.getId();\n  }\n\n  async handleShipOrder(command: ShipOrderCommand): Promise<void> {\n    const order = await this.orderRepo.findById(command.orderId);\n\n    if (!order) {\n      throw new Error('Order not found');\n    }\n\n    order.ship(command.trackingNumber);\n\n    await this.orderRepo.save(order);\n\n    order.getUncommittedEvents().forEach(event => {\n      this.eventBus.publish(event);\n    });\n  }\n}\n\n// Read Model (Queries)\ninterface OrderReadModel {\n  id: string;\n  userId: string;\n  status: string;\n  total: number;\n  itemCount: number;\n  createdAt: Date;\n  shippedAt?: Date;\n}\n\nclass OrderQueryHandler {\n  constructor(private db: Database) {}\n\n  async getOrder(orderId: string): Promise<OrderReadModel | null> {\n    return this.db.query(\n      'SELECT * FROM order_read_model WHERE id = ?',\n      [orderId]\n    );\n  }\n\n  async getUserOrders(userId: string): Promise<OrderReadModel[]> {\n    return this.db.query(\n      'SELECT * FROM order_read_model WHERE user_id = ? ORDER BY created_at DESC',\n      [userId]\n    );\n  }\n}\n\n// Projection (Event → Read Model)\nclass OrderProjection {\n  constructor(private db: Database) {}\n\n  async handleOrderCreated(event: OrderCreatedEvent): Promise<void> {\n    await this.db.query(`\n      INSERT INTO order_read_model (id, user_id, status, total, item_count, created_at)\n      VALUES (?, ?, ?, ?, ?, ?)\n    `, [\n      event.aggregateId,\n      event.data.userId,\n      'PENDING',\n      event.data.total,\n      event.data.items.length,\n      event.timestamp\n    ]);\n  }\n\n  async handleOrderShipped(event: OrderShippedEvent): Promise<void> {\n    await this.db.query(`\n      UPDATE order_read_model\n      SET status = 'SHIPPED', shipped_at = ?\n      WHERE id = ?\n    `, [event.timestamp, event.aggregateId]);\n  }\n}\n```\n\n## Message Queue Integration\n\n### RabbitMQ Example\n\n```typescript\nimport amqp from 'amqplib';\n\nclass MessageQueue {\n  private connection: amqp.Connection;\n  private channel: amqp.Channel;\n\n  async connect(): Promise<void> {\n    this.connection = await amqp.connect('amqp://localhost');\n    this.channel = await this.connection.createChannel();\n  }\n\n  async publish(exchange: string, routingKey: string, event: DomainEvent): Promise<void> {\n    await this.channel.assertExchange(exchange, 'topic', { durable: true });\n\n    this.channel.publish(\n      exchange,\n      routingKey,\n      Buffer.from(JSON.stringify(event)),\n      { persistent: true }\n    );\n  }\n\n  async subscribe(\n    exchange: string,\n    routingKey: string,\n    handler: (event: DomainEvent) => Promise<void>\n  ): Promise<void> {\n    await this.channel.assertExchange(exchange, 'topic', { durable: true });\n\n    const queue = await this.channel.assertQueue('', { exclusive: true });\n    await this.channel.bindQueue(queue.queue, exchange, routingKey);\n\n    this.channel.consume(queue.queue, async (msg) => {\n      if (msg) {\n        const event = JSON.parse(msg.content.toString());\n\n        try {\n          await handler(event);\n          this.channel.ack(msg);\n        } catch (error) {\n          console.error('Error handling event:', error);\n          this.channel.nack(msg, false, true); // Requeue\n        }\n      }\n    });\n  }\n}\n\n// Usage\nconst queue = new MessageQueue();\nawait queue.connect();\n\n// Publish events\nawait queue.publish('orders', 'order.created', orderCreatedEvent);\n\n// Subscribe to events\nawait queue.subscribe('orders', 'order.*', async (event) => {\n  console.log('Received event:', event);\n  await handleEvent(event);\n});\n```\n\n### AWS EventBridge Example\n\n```typescript\nimport { EventBridge } from '@aws-sdk/client-eventbridge';\n\nclass EventBridgePublisher {\n  private client: EventBridge;\n\n  constructor() {\n    this.client = new EventBridge({ region: 'us-east-1' });\n  }\n\n  async publish(event: DomainEvent): Promise<void> {\n    await this.client.putEvents({\n      Entries: [{\n        Source: 'order-service',\n        DetailType: event.eventType,\n        Detail: JSON.stringify(event.data),\n        EventBusName: 'default',\n        Time: event.timestamp\n      }]\n    });\n  }\n}\n\n// Lambda handler for consuming events\nexport const handler = async (event: any) => {\n  console.log('Received event:', event.detail);\n\n  const domainEvent: DomainEvent = {\n    eventType: event['detail-type'],\n    data: event.detail,\n    timestamp: new Date(event.time)\n  };\n\n  await processEvent(domainEvent);\n};\n```\n\n## Pub/Sub Pattern\n\n### In-Memory Event Bus\n\n```typescript\ntype EventHandler = (event: DomainEvent) => Promise<void>;\n\nclass EventBus {\n  private handlers = new Map<string, EventHandler[]>();\n\n  subscribe(eventType: string, handler: EventHandler): void {\n    if (!this.handlers.has(eventType)) {\n      this.handlers.set(eventType, []);\n    }\n\n    this.handlers.get(eventType)!.push(handler);\n  }\n\n  async publish(event: DomainEvent): Promise<void> {\n    const handlers = this.handlers.get(event.eventType) || [];\n\n    await Promise.all(\n      handlers.map(handler =>\n        handler(event).catch(error => {\n          console.error(`Error in event handler for ${event.eventType}:`, error);\n        })\n      )\n    );\n  }\n}\n\n// Usage\nconst eventBus = new EventBus();\n\n// Subscribe to events\neventBus.subscribe('OrderCreated', async (event) => {\n  await sendConfirmationEmail(event.data.userId);\n});\n\neventBus.subscribe('OrderCreated', async (event) => {\n  await updateInventory(event.data.items);\n});\n\neventBus.subscribe('OrderCreated', async (event) => {\n  await updateAnalytics(event);\n});\n\n// Publish event\nawait eventBus.publish(orderCreatedEvent);\n```\n\n## Saga Pattern\n\n### Orchestration Saga\n\n```typescript\nclass OrderSaga {\n  constructor(\n    private paymentService: PaymentService,\n    private inventoryService: InventoryService,\n    private shippingService: ShippingService,\n    private eventBus: EventBus\n  ) {}\n\n  async execute(order: Order): Promise<void> {\n    try {\n      // Step 1: Reserve inventory\n      await this.inventoryService.reserve(order.items);\n\n      // Step 2: Process payment\n      const payment = await this.paymentService.charge(order.total);\n\n      // Step 3: Schedule shipping\n      await this.shippingService.schedule(order.id);\n\n      // Success: Publish completion event\n      await this.eventBus.publish({\n        eventType: 'OrderCompleted',\n        aggregateId: order.id,\n        data: { paymentId: payment.id }\n      });\n\n    } catch (error) {\n      // Compensating transactions (rollback)\n      await this.compensate(order);\n      throw error;\n    }\n  }\n\n  private async compensate(order: Order): Promise<void> {\n    try {\n      await this.inventoryService.releaseReservation(order.items);\n      await this.paymentService.refund(order.id);\n    } catch (error) {\n      console.error('Compensation failed:', error);\n      // Log for manual intervention\n    }\n  }\n}\n```\n\n### Choreography Saga\n\n```typescript\n// Each service reacts to events independently\n\n// Inventory Service\nclass InventoryService {\n  constructor(private eventBus: EventBus) {\n    this.eventBus.subscribe('OrderCreated', this.handleOrderCreated.bind(this));\n    this.eventBus.subscribe('PaymentFailed', this.handlePaymentFailed.bind(this));\n  }\n\n  private async handleOrderCreated(event: OrderCreatedEvent): Promise<void> {\n    try {\n      await this.reserve(event.data.items);\n\n      await this.eventBus.publish({\n        eventType: 'InventoryReserved',\n        aggregateId: event.aggregateId,\n        data: { items: event.data.items }\n      });\n    } catch (error) {\n      await this.eventBus.publish({\n        eventType: 'InventoryReservationFailed',\n        aggregateId: event.aggregateId,\n        data: { error: error.message }\n      });\n    }\n  }\n\n  private async handlePaymentFailed(event: PaymentFailedEvent): Promise<void> {\n    await this.releaseReservation(event.aggregateId);\n  }\n}\n\n// Payment Service\nclass PaymentService {\n  constructor(private eventBus: EventBus) {\n    this.eventBus.subscribe('InventoryReserved', this.handleInventoryReserved.bind(this));\n  }\n\n  private async handleInventoryReserved(event: InventoryReservedEvent): Promise<void> {\n    try {\n      const payment = await this.charge(event.data.total);\n\n      await this.eventBus.publish({\n        eventType: 'PaymentProcessed',\n        aggregateId: event.aggregateId,\n        data: { paymentId: payment.id }\n      });\n    } catch (error) {\n      await this.eventBus.publish({\n        eventType: 'PaymentFailed',\n        aggregateId: event.aggregateId,\n        data: { error: error.message }\n      });\n    }\n  }\n}\n```\n\n## Event Versioning\n\n### Handling Event Schema Evolution\n\n```typescript\n// V1 Event\ninterface OrderCreatedV1 {\n  eventType: 'OrderCreated';\n  version: 1;\n  data: {\n    userId: string;\n    items: OrderItem[];\n  };\n}\n\n// V2 Event (added shipping address)\ninterface OrderCreatedV2 {\n  eventType: 'OrderCreated';\n  version: 2;\n  data: {\n    userId: string;\n    items: OrderItem[];\n    shippingAddress: Address;\n  };\n}\n\n// Upcasting: Convert old events to new format\nclass EventUpcaster {\n  upcast(event: DomainEvent): DomainEvent {\n    if (event.eventType === 'OrderCreated' && event.version === 1) {\n      return {\n        ...event,\n        version: 2,\n        data: {\n          ...event.data,\n          shippingAddress: getDefaultAddress(event.data.userId)\n        }\n      };\n    }\n\n    return event;\n  }\n}\n\n// Handle multiple versions\nclass OrderProjection {\n  async handleOrderCreated(event: DomainEvent): Promise<void> {\n    const upcastedEvent = this.upcaster.upcast(event);\n\n    switch (upcastedEvent.version) {\n      case 1:\n        return this.handleOrderCreatedV1(upcastedEvent as OrderCreatedV1);\n      case 2:\n        return this.handleOrderCreatedV2(upcastedEvent as OrderCreatedV2);\n      default:\n        throw new Error(`Unsupported event version: ${upcastedEvent.version}`);\n    }\n  }\n}\n```\n\n## Benefits and Drawbacks\n\n### ✅ Benefits\n\n- **Scalability**: Read and write models can scale independently\n- **Audit Trail**: Complete history of all changes\n- **Temporal Queries**: Reconstruct state at any point in time\n- **Loose Coupling**: Services communicate via events\n- **Flexibility**: Add new event handlers without changing existing code\n\n### ❌ Drawbacks\n\n- **Eventual Consistency**: Read model may lag behind write model\n- **Complexity**: More moving parts than traditional CRUD\n- **Learning Curve**: Requires mindset shift\n- **Debugging**: Distributed system issues\n- **Event Schema Evolution**: Handling versioning\n\n### When to Use\n\n**Use CQRS/Event Sourcing when:**\n- Complex business logic with many state changes\n- Need complete audit trail\n- Different optimization requirements for reads vs writes\n- Working in specific bounded contexts (not entire system)\n\n**Avoid when:**\n- Simple CRUD applications\n- Team lacks experience with pattern\n- Eventual consistency is unacceptable\n\n## References\n\n- [CQRS](https://martinfowler.com/bliki/CQRS.html)\n- [Event Sourcing](https://martinfowler.com/eaaDev/EventSourcing.html)\n- [Domain Events](https://martinfowler.com/eaaDev/DomainEvent.html)\n- [Saga Pattern](https://microservices.io/patterns/data/saga.html)\n",
    "original/architecture/feature-toggles.md": "# Feature Toggles (Feature Flags) Guidelines\n\n## Overview\n\nFeature toggles allow modifying system behavior without code changes through configuration management. They enable trunk-based development, A/B testing, graceful degradation, and controlled feature rollout.\n\n## Toggle Categories\n\n### 1. Release Toggles\n**Purpose:** Enable trunk-based development by allowing incomplete features to ship as dormant code\n\n**Characteristics:**\n- Separate feature release from code deployment\n- Typically transient (days to weeks)\n- Static configuration\n- Low dynamism\n\n**Use Cases:**\n- Continuous deployment with incomplete features\n- Dark launching\n- Gradual feature rollout\n\n### 2. Experiment Toggles\n**Purpose:** Support A/B testing and multivariate analysis\n\n**Characteristics:**\n- Highly dynamic (per-request decisions)\n- Based on user cohorts\n- Short-lived (hours to weeks)\n- Requires analytics integration\n\n**Use Cases:**\n- A/B testing\n- Multivariate experiments\n- User experience optimization\n\n### 3. Ops Toggles\n**Purpose:** Control operational behavior for system stability\n\n**Characteristics:**\n- Manual operator control\n- Short to long-lived\n- Static to semi-dynamic\n- \"Kill switch\" functionality\n\n**Use Cases:**\n- Graceful degradation under load\n- Circuit breakers\n- Performance tuning\n- Emergency shutdowns\n\n### 4. Permissioning Toggles\n**Purpose:** Gate features by user type or permissions\n\n**Characteristics:**\n- Long-lived (years)\n- Highly dynamic (per-request)\n- Based on user identity/roles\n- Integrated with auth system\n\n**Use Cases:**\n- Premium features\n- Beta access\n- Internal tools\n- Canary deployments\n\n## Implementation Patterns\n\n### Decouple Decision Points from Logic\n\n❌ **Avoid:**\n```typescript\nfunction processOrder(order: Order) {\n  if (featureFlags.get('new-pricing')) {\n    return newPricingService.calculate(order);\n  }\n  return legacyPricingService.calculate(order);\n}\n```\n\n✅ **Prefer:**\n```typescript\nclass FeatureDecisions {\n  getPricingService(): PricingService {\n    return this.flags.get('new-pricing')\n      ? new NewPricingService()\n      : new LegacyPricingService();\n  }\n}\n\nfunction processOrder(order: Order, decisions: FeatureDecisions) {\n  return decisions.getPricingService().calculate(order);\n}\n```\n\n### Inversion of Control\n\n❌ **Avoid:**\n```typescript\nclass OrderProcessor {\n  process(order: Order) {\n    const useNewFlow = FeatureFlags.global.get('new-flow');\n    // ...\n  }\n}\n```\n\n✅ **Prefer:**\n```typescript\nclass OrderProcessor {\n  constructor(private useNewFlow: boolean) {}\n\n  process(order: Order) {\n    if (this.useNewFlow) {\n      // ...\n    }\n  }\n}\n\n// At composition root\nconst processor = new OrderProcessor(\n  featureDecisions.isNewFlowEnabled()\n);\n```\n\n### Strategy Pattern Over Conditionals\n\n❌ **Avoid:**\n```typescript\nfunction handlePayment(order: Order) {\n  if (featureFlags.get('payment-v2')) {\n    // v2 logic\n  } else if (featureFlags.get('payment-v1-enhanced')) {\n    // v1 enhanced logic\n  } else {\n    // legacy logic\n  }\n}\n```\n\n✅ **Prefer:**\n```typescript\ninterface PaymentStrategy {\n  process(order: Order): Promise<PaymentResult>;\n}\n\nclass PaymentProcessor {\n  constructor(private strategy: PaymentStrategy) {}\n\n  async process(order: Order) {\n    return this.strategy.process(order);\n  }\n}\n```\n\n## Configuration Management\n\n### Progression of Sophistication\n\n**1. Hardcoded/Commented Code**\n- Requires redeployment\n- Suitable only for developer-managed short-term toggles\n\n**2. Environment Variables/Parameters**\n- Configuration without rebuilding\n- Still requires redeployment\n- Good for ops toggles\n\n**3. Configuration Files**\n- YAML/JSON in source control\n- Supports environment-specific overrides\n- May require redeployment\n\n**4. Application Database**\n- Centralized store with admin UI\n- Runtime reconfiguration across fleet\n- No redeployment needed\n\n**5. Distributed Systems**\n- Zookeeper, etcd, Consul\n- Real-time cluster-wide synchronization\n- Automatic propagation\n- Best for large-scale systems\n\n### Per-Request Overrides\n\nAllow toggle state modification via:\n- Cookies\n- Query parameters\n- HTTP headers\n\n**Use Cases:**\n- Testing without affecting other users\n- Developer debugging\n- QA verification\n\n⚠️ **Security Consideration:** Introduces security surface; implement proper access controls\n\n## Managing Toggle Lifecycle\n\n### Treat Toggles as Inventory\n\nFeature toggles have carrying costs and should be kept to minimum.\n\n### Best Practices\n\n✅ **Create Removal Tasks:**\nCreate backlog items for toggle removal alongside creation\n\n✅ **Set Expiration Dates:**\nInclude creation dates and expected lifetime in config\n\n✅ **Implement Time Bombs:**\nFail tests or prevent startup if toggles exceed expiration\n\n✅ **Cap Total Toggles:**\nEnforce maximum limits; require removing old before adding new\n\n### Example Configuration\n\n```yaml\nfeatures:\n  new-checkout:\n    enabled: true\n    created: 2024-12-01\n    expires: 2025-01-15\n    owner: checkout-team\n    description: \"New streamlined checkout flow\"\n    type: release-toggle\n\n  premium-dashboard:\n    enabled: true\n    created: 2024-06-01\n    owner: product-team\n    description: \"Premium user dashboard\"\n    type: permissioning-toggle\n```\n\n## Testing Strategies\n\n### Test Multiple States\n\n✅ **Test:**\n- Toggle ON (new behavior)\n- Toggle OFF (legacy behavior)\n- Expected production state\n\n❌ **Avoid:**\n- Testing every combination (combinatorial explosion)\n- Only testing one state\n\n### Semantic Conventions\n\n✅ **Adopt Standard:**\n- OFF = legacy behavior\n- ON = new behavior\n\nPrevents surprise regressions and clarifies intent\n\n### Dynamic Reconfiguration in Tests\n\n```typescript\ndescribe('Order Processing', () => {\n  it('uses new flow when enabled', async () => {\n    await featureFlags.set('new-flow', true);\n    const result = await processOrder(order);\n    expect(result).toMatchNewFlowBehavior();\n  });\n\n  it('uses legacy flow when disabled', async () => {\n    await featureFlags.set('new-flow', false);\n    const result = await processOrder(order);\n    expect(result).toMatchLegacyBehavior();\n  });\n});\n```\n\n### Restrict Override Access\n\n- Limit dynamic reconfiguration to automated tests\n- Require authentication for debugging overrides\n- Log all toggle state changes\n- Audit override usage\n\n## Placement Considerations\n\n### Edge Services\nPlace per-request toggles (Experiment, Permissioning) at system edges:\n- API gateways\n- Frontend applications\n- BFFs (Backend for Frontend)\n\nWhere user context is available\n\n### Core Services\nTechnical toggles controlling internal implementation:\n- Reside within the service they modify\n- Not exposed at system edges\n- Managed by service owners\n\n## Additional Best Practices\n\n### Expose Configuration\n\n```typescript\napp.get('/meta/features', (req, res) => {\n  res.json({\n    features: {\n      'new-checkout': featureFlags.get('new-checkout'),\n      'premium-dashboard': featureFlags.get('premium-dashboard')\n    },\n    version: '1.2.3',\n    build: '2024-12-06-1234'\n  });\n});\n```\n\n### Structured Configuration\n\nInclude in config files:\n- Human-readable descriptions\n- Creation dates\n- Contact information\n- Toggle type/category\n- Expected lifespan\n\n### Manage by Category\n\nDifferent toggle types require different management:\n- **Release:** Aggressive cleanup\n- **Experiment:** Short-term, analytics-driven\n- **Ops:** Long-term, operator-controlled\n- **Permissioning:** Very long-term, user-driven\n\n## Common Pitfalls\n\n❌ **Toggle Debt:** Accumulating too many toggles over time\n❌ **Nested Conditionals:** Complex if/else chains\n❌ **Testing Explosion:** Trying to test all combinations\n❌ **Permanent Toggles:** Keeping release toggles indefinitely\n❌ **Global State:** Using global feature flag accessors everywhere\n❌ **Poor Naming:** Unclear toggle purposes\n❌ **Missing Documentation:** No context for future developers\n\n## Anti-Patterns to Avoid\n\n❌ Feature flags scattered throughout codebase\n❌ No expiration strategy\n❌ Testing only one toggle state\n❌ Using feature flags for configuration\n❌ Nested feature flag checks\n❌ No audit trail of toggle changes\n❌ Permanent \"temporary\" toggles\n",
    "original/architecture/gui-architecture-patterns.md": "# GUI Architecture Patterns\n\n## Overview\n\nGUI architecture patterns help manage presentation complexity by separating concerns between display logic, user interaction, and domain logic. Different patterns suit different complexity levels and testing requirements.\n\n## Pattern Selection Guide\n\n| Pattern | Domain Separation | Testability | Complexity | Best For |\n|---------|------------------|-------------|------------|----------|\n| Forms & Controls | Weak | Low | Low | Simple data entry |\n| MVC | Strong | High | Medium | Multiple views of same data |\n| MVP (Supervising) | Strong | High | Medium | Balanced complexity |\n| MVP (Passive) | Strong | Very High | Medium-High | Maximum testability |\n| MVVM/Presentation Model | Strong | Very High | Medium-High | Complex view logic |\n\n## Model-View-Controller (MVC)\n\n### Core Principle\nMake strong separation between presentation and domain logic.\n\n### Structure\n- **Model:** Domain objects independent of UI\n- **View:** Displays model state\n- **Controller:** Responds to user input\n- Uses Observer Synchronization (model notifies views)\n\n### Best For\n- Complex applications with multiple presentations\n- Systems where multiple views display same domain objects\n- Applications requiring clean domain/UI separation\n\n### Trade-offs\n✅ Supports multiple simultaneous views\n✅ Domain logic remains reusable\n✅ Clear separation of concerns\n\n❌ Observer behavior hard to understand and debug\n❌ Implicit coupling through events\n\n## Model-View-Presenter (MVP)\n\n### Core Principle\nUser gestures handed off by widgets to a Supervising Controller.\n\n### Structure\n- **Model:** Domain logic\n- **View:** Widget structures only (no behavior)\n- **Presenter:** Handles all user input, coordinates model updates\n- Presenter operates at form level, not widget level\n\n### Variants\n\n**Supervising Controller:**\n- Views handle simple mappings\n- Presenter manages complex logic\n- Balance between simplicity and separation\n\n**Passive View:**\n- Presenter controls all widget updates\n- Views become \"humble objects\"\n- Maximum testability\n\n### Best For\n- Teams prioritizing testability\n- Applications with complex user interactions\n- Test-driven development\n\n### Trade-offs\n✅ Excellent testability\n✅ Clear responsibility boundaries\n✅ Easy to mock dependencies\n\n❌ More boilerplate code\n❌ Views require more wiring\n\n## MVVM (Model-View-ViewModel) / Presentation Model\n\n### Core Principle\nCreate a model designed specifically for presentation layer.\n\n### Structure\n- **Model:** Domain objects\n- **ViewModel/Presentation Model:** View logic and state\n- **View:** Binds to ViewModel properties\n- UI never directly accesses domain\n\n### Handles\n- View state management (selections, focus)\n- Presentation logic (conditional display, validation states)\n- Enables comprehensive testing without UI framework\n\n### Best For\n- Applications with extensive view logic\n- Data binding frameworks (WPF, Angular, React)\n- Maximum test coverage requirements\n\n### Trade-offs\n✅ Nearly all behavior testable in isolation\n✅ Clean separation between view and domain\n✅ Supports data binding well\n\n❌ Additional layer adds complexity\n❌ Risk of anemic domain models\n\n## Humble View\n\n### Core Principle\nMinimize behavior in objects that are awkward to test.\n\n### Strategies\n\n**With Passive View:**\n- Presenter handles all population and state management\n- Widgets become minimal\n\n**With Presentation Model:**\n- Model manages all decisions\n- Widgets simply bind to properties\n\n### Trade-offs\n✅ Maximum testability\n✅ Moves risky behavior into testable classes\n\n❌ Requires more test doubles\n❌ May increase boilerplate\n\n### Best For\n- Test-driven development\n- Continuous integration environments\n- Teams valuing test coverage\n\n## Forms and Controls\n\n### Core Principle\nApplication-specific forms use generic controls.\n\n### Structure\n- Forms contain layout and event handlers\n- Generic controls handle display\n- Data binding synchronizes screen and session state\n\n### Best For\n- Simple UIs with straightforward data flows\n- Rapid development\n- Small applications\n\n### Trade-offs\n✅ Quick to implement\n✅ Minimal abstraction\n\n❌ Business logic couples to UI\n❌ Poor testability\n❌ Limited reusability\n\n## Best Practices Across All Patterns\n\n### Separation of Concerns\n- Keep presentation logic separate from domain logic\n- Domain should be UI-agnostic\n- Views should be dumb, focusing only on display\n\n### Testability\n- Design for testing from the start\n- Use dependency injection\n- Create seams for mocking\n- Test presenters/view models without UI framework\n\n### Data Binding\n- Use observer pattern or reactive frameworks\n- Ensure one-way or two-way binding is explicit\n- Avoid memory leaks from event subscriptions\n\n### State Management\n- Centralize view state in presenter/view model\n- Keep domain state in model\n- Don't duplicate state between layers\n\n## Implementation Guidelines\n\n### Choosing MVC\n```typescript\nclass UserController {\n  constructor(private model: UserModel, private view: UserView) {\n    this.model.on('change', () => this.view.render());\n  }\n\n  handleUpdate(data: UserData) {\n    this.model.update(data);\n  }\n}\n```\n\n### Choosing MVP\n```typescript\nclass UserPresenter {\n  constructor(private view: IUserView, private model: UserModel) {}\n\n  async loadUser(id: string) {\n    const user = await this.model.getUser(id);\n    this.view.displayUser(user.name, user.email);\n  }\n\n  handleSubmit(name: string, email: string) {\n    this.model.updateUser({ name, email });\n  }\n}\n```\n\n### Choosing MVVM\n```typescript\nclass UserViewModel {\n  name = observable('');\n  email = observable('');\n  isValid = computed(() => this.validateEmail(this.email.value));\n\n  async save() {\n    await this.model.updateUser({\n      name: this.name.value,\n      email: this.email.value\n    });\n  }\n}\n```\n\n## Common Pitfalls\n\n❌ **Mixing Patterns:** Inconsistent pattern usage across application\n❌ **Fat Views:** Putting business logic in view layer\n❌ **Anemic Models:** Moving all logic to presenters/view models\n❌ **Over-Engineering:** Using complex patterns for simple UIs\n❌ **Tight Coupling:** Views directly accessing domain models\n❌ **Poor Abstractions:** Views knowing too much about presenter internals\n\n## Testing Strategy\n\n### Unit Testing\n- Test presenters/view models in isolation\n- Mock view interfaces\n- Verify domain model interactions\n- Test state management logic\n\n### Integration Testing\n- Test view + presenter together\n- Verify data binding works\n- Check event propagation\n- Test navigation flows\n\n### UI Testing\n- Minimal UI tests (use Humble View approach)\n- Focus on visual appearance, not logic\n- Test accessibility and responsiveness\n",
    "original/architecture/layered-architecture.md": "# Layered Architecture Guidelines\n\n## Overview\n\nLayered architecture separates applications into distinct layers with clear responsibilities and dependencies flowing in one direction. The most common pattern is the three-layer architecture: Presentation, Domain, and Data Access.\n\n## Core Layers\n\n### Presentation Layer (UI)\n**Responsibilities:**\n- Handle HTTP requests and responses\n- Manage UI behavior and interactions\n- Render HTML or JSON responses\n- Abstract away data sources through function calls\n\n**What Belongs Here:**\n- View templates and components\n- UI controllers and handlers\n- Input validation and sanitization\n- Session management\n- User authentication checks\n\n**What Doesn't Belong:**\n- Business logic or calculations\n- Direct database queries\n- Data transformation rules\n\n### Domain Layer (Business Logic)\n**Responsibilities:**\n- Contain validations and calculations\n- Represent core application logic\n- Be independent of UI or persistence\n- Treat data sources as abstract interfaces\n\n**What Belongs Here:**\n- Business rules and workflows\n- Domain models and entities\n- Service interfaces\n- Application use cases\n- Business validation logic\n\n**What Doesn't Belong:**\n- UI rendering logic\n- Database queries or SQL\n- HTTP request handling\n- Framework-specific code\n\n### Data Access Layer\n**Responsibilities:**\n- Manage persistent data in databases or remote services\n- Handle technical details of storage and retrieval\n- Provide abstract functions to domain layer\n- Implement repository patterns\n\n**What Belongs Here:**\n- Database queries and commands\n- ORM configurations\n- Data mapping logic\n- Connection management\n- Cache implementations\n\n**What Doesn't Belong:**\n- Business logic\n- UI concerns\n- Direct controller access\n\n## Key Principles\n\n### Reduce Cognitive Load\nAllows thinking about three topics relatively independently, reducing scope of attention needed at any given time.\n\n### Dependency Flow\nDependencies run top-to-bottom: Presentation → Domain → Data Source\n\n**Hexagonal Architecture Variation:**\nIntroduce mappers between domain and data to eliminate domain dependencies on data sources entirely.\n\n### Non-Sequential Development\nLayers need not be built in order; iteration across layers is normal and expected.\n\n### Substitutability\nSeparation enables multiple presentations (web, mobile, CLI, API) sharing identical domain logic without duplication.\n\n### Testability\nLayer boundaries create seams that afford testing, allowing domain logic testing without UI gymnastics.\n\n## Best Practices\n\n✅ **DO:**\n- Keep layers loosely coupled through interfaces\n- Make layer boundaries explicit in folder structure\n- Test each layer independently\n- Use dependency injection at layer boundaries\n- Keep business logic in domain layer only\n- Create clear abstractions between layers\n\n❌ **DON'T:**\n- Separate development teams by layers (create cross-functional teams instead)\n- Skip layers (e.g., presentation directly accessing data layer)\n- Put business logic in presentation or data layers\n- Create circular dependencies between layers\n- Over-apply at large scale (use domain-oriented modules at highest level)\n- Confuse logical layers with physical deployment\n\n## Common Mistakes\n\n### Team Anti-Pattern\nSeparating development teams by layers creates friction and reduces cross-layer understanding. Teams should be cross-functional, even if individuals specialize.\n\n### Over-Application\nThis pattern works at small granularity. Larger systems should use domain-oriented modules at the highest level, with internal layering within modules.\n\n### Logical vs Physical Confusion\nLayers are logical constructs, not physical. They can deploy together or separately depending on architecture needs.\n\n## Layer Communication Patterns\n\n### Top-Down Communication\n- Higher layers call lower layers through well-defined interfaces\n- Use dependency injection to avoid tight coupling\n- Pass data through DTOs or domain models\n\n### Bottom-Up Notifications\n- Use observer pattern for lower layers to notify higher layers\n- Implement event-driven architecture for loose coupling\n- Consider message queues for asynchronous updates\n\n## Testing Strategy\n\n### Unit Testing\n- Test each layer in isolation\n- Mock dependencies from other layers\n- Focus on layer-specific responsibilities\n\n### Integration Testing\n- Test interactions between adjacent layers\n- Verify data flows correctly across boundaries\n- Ensure abstractions work as intended\n\n### End-to-End Testing\n- Test full request/response cycle through all layers\n- Verify system behavior as a whole\n- Catch integration issues\n\n## Folder Structure Example\n\n```\nsrc/\n├── presentation/       # Controllers, views, API endpoints\n│   ├── controllers/\n│   ├── views/\n│   └── middleware/\n├── domain/            # Business logic, models, services\n│   ├── models/\n│   ├── services/\n│   └── interfaces/\n└── data/              # Repositories, database access\n    ├── repositories/\n    ├── migrations/\n    └── seeds/\n```\n\n## When to Use Layered Architecture\n\n✅ **Good For:**\n- Applications with clear separation of concerns\n- Projects where multiple UIs share business logic\n- Systems requiring high testability\n- Teams new to architecture patterns\n- Monolithic applications\n\n❌ **Not Ideal For:**\n- Simple CRUD applications (may be overkill)\n- Microservices (use within each service, not across)\n- Event-driven systems (consider different patterns)\n- Systems with complex domain logic (consider DDD)\n\n## Variants\n\n### Three-Tier Architecture\nPhysical separation: Client tier, Application tier, Database tier\n\n### N-Tier Architecture\nAdditional layers for specific concerns (e.g., caching, messaging)\n\n### Hexagonal Architecture (Ports and Adapters)\nDomain at center, infrastructure at edges, connected through ports\n\n### Clean Architecture\nSimilar to hexagonal with explicit dependency inversion rules\n",
    "original/architecture/microservices-architecture.md": "# Microservices Architecture Guidelines\n\n## Overview\n\nMicroservices are a suite of small services, each running in its own process and communicating with lightweight mechanisms. Each service is independently deployable, replaceable, and upgradeable.\n\n## Core Characteristics\n\n### Componentization via Services\n- Services are independently replaceable and upgradeable units\n- Communicate through remote mechanisms (HTTP, RPC) rather than in-memory calls\n- Enable independent deployment without full system rebuilds\n\n### Organization Around Business Capabilities\n- Structure teams and services around business functions, not technology layers\n- Cross-functional teams own full-stack implementations\n- Embodies Conway's Law: system design mirrors organizational communication\n\n### Products, Not Projects\n- Teams maintain services throughout their lifecycle\n- \"You build, you run it\" philosophy\n- Developers engage directly with production behavior and user feedback\n\n### Smart Endpoints, Dumb Pipes\n- Intelligence resides in service logic, not communication infrastructure\n- Avoid complex Enterprise Service Buses with sophisticated routing\n- Use simple protocols: HTTP REST APIs or lightweight messaging\n\n### Decentralized Governance\n- Teams select appropriate technology for their service's needs\n- Standards emerge from successful implementations\n- Share battle-tested internal tools without rigid enforcement\n\n### Decentralized Data Management\n- Each service manages its own database\n- Different services may use different database technologies (polyglot persistence)\n- Different bounded contexts have different data model views\n\n### Infrastructure Automation\n- CI/CD pipelines essential for reducing deployment risk\n- Automated testing and deployment\n- Make it easy to do the right thing\n\n### Design for Failure\n- Services may fail; systems must tolerate unavailability gracefully\n- Implement circuit breaker patterns, timeouts, and bulkhead isolation\n- Test resilience by deliberately inducing failures\n\n### Evolutionary Design\n- Service boundaries should be refactorable as understanding evolves\n- Services often intentionally replaceable rather than perpetually evolved\n- Keep frequently-changing code together\n\n## Communication Patterns\n\n### Synchronous vs Asynchronous\n- Synchronous calls create multiplicative downtime across services\n- Prefer asynchronous messaging to decouple service dependencies\n- Limit single synchronous call per user request\n\n### Service Integration\n- Use Tolerant Reader pattern for independent service contract evolution\n- Consumer-Driven Contracts define expectations before implementation\n- Minimize versioning through flexible service design\n\n## Data Management\n\n### Transactionless Coordination\n- Distributed transactions difficult; emphasize eventual consistency\n- Use compensating operations to handle inconsistencies\n- Speed often outweighs perfect consistency\n\n## Size Guidelines\n\n- \"Two Pizza Team\" model: services sized for teams of ~12 people\n- Range from service-per-person to service-per-dozen-person\n- Size depends on organizational context\n\n## When NOT to Use Microservices\n\n- Startups or teams without maturity in modular architecture\n- Systems where component boundaries remain unclear\n- Organizations lacking infrastructure automation capabilities\n- Teams unable to manage distributed system complexity\n\n## Best Practices\n\n✅ **DO:**\n- Begin with a monolith, keep it modular, split into microservices when needed\n- Implement comprehensive monitoring of service health\n- Use semantic monitoring for business metrics\n- Design for independent deployment\n- Employ circuit breakers and timeouts\n- Practice chaos engineering\n\n❌ **DON'T:**\n- Create tight coupling between services\n- Share databases between services\n- Build microservices without proper team skills\n- Neglect operational complexity\n- Ignore the cost of distributed systems\n- Prematurely decompose before understanding boundaries\n\n## Common Pitfalls\n\n### Complexity Migration\n- Refactoring across service boundaries significantly harder than within monoliths\n- Risk shifting component complexity to inter-service connections\n- Messy boundaries create less explicit, harder-to-control complexity\n\n### Team Capability Requirements\n- Success depends on team skill\n- Poor teams create poor systems regardless of architecture\n\n### Component Boundary Errors\n- Getting initial service boundaries right is difficult\n- Interface changes require coordination and backward compatibility\n- Remote calls make refactoring harder than in-process calls\n\n## Operational Considerations\n\n- Sophisticated monitoring essential for individual service health\n- Real-time dashboards detect emergent behavior issues\n- Independent service deployment enables faster, targeted releases\n- Requires mature DevOps practices and culture\n",
    "original/architecture/modular-monolith.md": "# Modular Monolith Architecture\n\n## Overview\n\nA modular monolith is a software architecture where the application is built as a single deployable unit, but internally structured into well-defined, loosely coupled modules with clear boundaries. This approach combines the simplicity of monolithic deployment with the maintainability benefits of modular design.\n\n## Core Philosophy: Monolith First\n\n### Why Start with a Monolith\n\n**Martin Fowler's empirical observation:** \"Almost all successful microservice stories have started with a monolith that got too big and was broken up.\"\n\n**Key Reasons:**\n\n1. **Microservice Premium Cost**: Microservices impose significant overhead in managing multiple services, deployment pipelines, distributed tracing, and inter-service communication. This complexity only pays off for sufficiently complex systems.\n\n2. **YAGNI Principle**: When launching applications, uncertainty about market success is high. A successful but poorly designed monolith beats an unsuccessful sophisticated microservices architecture.\n\n3. **Boundary Discovery**: Establishing stable service boundaries is extremely difficult initially. Any refactoring across service boundaries is much harder than within a monolith. Start with a monolith to explore and discover correct boundaries before they become architecturally rigid.\n\n4. **Speed & Feedback**: Initial speed and tight feedback loops matter most when validating product-market fit.\n\n### When Monolith First Doesn't Apply\n\n- **System Replacement**: Replacing existing systems where boundaries are already well-understood\n- **Existing Expertise**: Teams with proven microservices experience\n- **Known Scale Requirements**: Clear need for independent scaling from day one\n\n---\n\n## Modular Monolith Structure\n\n### High-Level Organization\n\n```\nproject-root/\n├── apps/\n│   └── api/                      # Main application\n│       ├── src/\n│       │   ├── app/              # Application bootstrap\n│       │   ├── modules/          # Business modules (bounded contexts)\n│       │   │   ├── auth/\n│       │   │   ├── user/\n│       │   │   ├── booking/\n│       │   │   ├── payment/\n│       │   │   ├── notification/\n│       │   │   └── ...\n│       │   ├── common/           # Shared infrastructure\n│       │   │   ├── decorators/\n│       │   │   ├── guards/\n│       │   │   ├── interceptors/\n│       │   │   └── interfaces/\n│       │   └── prisma/           # Database service (global)\n│       └── main.ts\n├── libs/                         # Shared libraries (optional)\n│   └── shared-types/             # Shared DTOs and types\n├── prisma/\n│   ├── schema.prisma\n│   └── migrations/\n└── package.json\n```\n\n### Module Structure (Per Business Capability)\n\nEach module follows consistent layered architecture:\n\n```\nmodules/booking/\n├── entities/              # Domain models and DTOs\n│   ├── booking.entity.ts\n│   ├── create-booking.dto.ts\n│   └── booking-response.dto.ts\n├── repositories/          # Data access layer\n│   └── booking.repository.ts\n├── services/              # Business logic\n│   ├── booking.service.ts\n│   └── availability.service.ts\n├── controllers/           # HTTP/API layer\n│   └── bookings.controller.ts\n└── booking.module.ts      # Module definition\n```\n\n---\n\n## Module Design Principles\n\n### 1. High Cohesion, Low Coupling\n\n**Each module should:**\n- Encapsulate a single business capability (bounded context)\n- Have clearly defined public interfaces\n- Hide implementation details\n- Minimize dependencies on other modules\n\n❌ **Bad (Tight Coupling):**\n```typescript\n// OrderService directly accessing UserRepository\n@Injectable()\nexport class OrderService {\n  constructor(private userRepo: UserRepository) {} // Direct dependency\n\n  async createOrder(userId: string) {\n    const user = await this.userRepo.findById(userId); // Crosses module boundary\n  }\n}\n```\n\n✅ **Good (Loose Coupling via Service):**\n```typescript\n// OrderService depends on UserService interface\n@Injectable()\nexport class OrderService {\n  constructor(private userService: UserService) {} // Service dependency\n\n  async createOrder(userId: string) {\n    const user = await this.userService.findById(userId); // Through public API\n  }\n}\n```\n\n### 2. Separated Interface Pattern\n\nDefine interfaces in consuming module, implement in providing module.\n\n```typescript\n// modules/order/interfaces/user-provider.interface.ts\nexport interface UserProvider {\n  findById(id: string): Promise<User>;\n  validateUser(id: string): Promise<boolean>;\n}\n\n// modules/user/user.service.ts\n@Injectable()\nexport class UserService implements UserProvider {\n  async findById(id: string): Promise<User> {\n    return this.userRepo.findById(id);\n  }\n\n  async validateUser(id: string): Promise<boolean> {\n    const user = await this.findById(id);\n    return user && user.isActive;\n  }\n}\n\n// modules/user/user.module.ts\n@Module({\n  providers: [UserService],\n  exports: [UserService], // Export for other modules\n})\nexport class UserModule {}\n```\n\n### 3. No Direct Cross-Module Database Access\n\n**Never** query another module's tables directly.\n\n❌ **Bad:**\n```typescript\n// In BookingService, querying user table directly\nconst user = await this.prisma.user.findUnique({ where: { id: userId } });\n```\n\n✅ **Good:**\n```typescript\n// Use UserService\nconst user = await this.userService.findById(userId);\n```\n\n### 4. Dependency Direction\n\n**Dependencies should point inward:** Common utilities can be used by modules, but modules should not depend on each other's internals.\n\n```\n┌─────────────────────────────────────┐\n│         Modules (Business Logic)     │\n│  ┌──────┐ ┌──────┐ ┌──────┐         │\n│  │ User │ │ Order│ │ Pay  │         │\n│  └──┬───┘ └───┬──┘ └──┬───┘         │\n│     │         │        │             │\n│     └─────────┼────────┘             │\n│               ▼                      │\n│      ┌────────────────┐              │\n│      │ Common/Shared  │              │\n│      │  (Guards, etc) │              │\n│      └────────────────┘              │\n└─────────────────────────────────────┘\n```\n\n---\n\n## Real-World Example: Booking System\n\n### Module Catalog\n\n```typescript\n// app.module.ts - Root module\n@Module({\n  imports: [\n    ConfigModule.forRoot({ isGlobal: true }),\n    PrismaModule,           // Shared database service\n    LocationModule,         // Business module\n    UsersModule,            // Business module\n    AuthModule,             // Business module\n    AuditModule,            // Cross-cutting concern\n    RolesModule,            // Business module\n    ServicesModule,         // Business module\n    ResourceModule,         // Business module\n    StaffModule,            // Business module\n    BookingsModule,         // Business module\n    AppConfigModule,        // Business module\n  ],\n})\nexport class AppModule {}\n```\n\n### Module Definition Example\n\n```typescript\n// modules/user/users.module.ts\nimport { Module, forwardRef } from '@nestjs/common';\nimport { UsersController } from './controllers/users.controller';\nimport { RolesController } from './controllers/roles.controller';\nimport { InvitationsController } from './controllers/invitations.controller';\nimport { UserService } from './services/user.service';\nimport { RoleService } from './services/role.service';\nimport { InvitationService } from './services/invitation.service';\nimport { UserRepository } from './repositories/user.repository';\nimport { RoleRepository } from './repositories/role.repository';\nimport { RefreshTokenRepository } from './repositories/refresh-token.repository';\nimport { InvitationRepository } from './repositories/invitation.repository';\nimport { RolesModule } from '../roles/roles.module';\nimport { PrismaModule } from '../../prisma/prisma.module';\nimport { AuthModule } from '../auth/auth.module';\nimport { NotificationsModule } from '../notifications/notifications.module';\n\n@Module({\n  imports: [\n    RolesModule,\n    PrismaModule,\n    NotificationsModule,\n    forwardRef(() => AuthModule), // Handle circular dependency\n  ],\n  controllers: [\n    UsersController,\n    RolesController,\n    InvitationsController,\n  ],\n  providers: [\n    UserService,\n    RoleService,\n    InvitationService,\n    UserRepository,\n    RoleRepository,\n    RefreshTokenRepository,\n    InvitationRepository,\n  ],\n  exports: [\n    UserService,           // Export for other modules\n    RoleService,\n    InvitationService,\n    UserRepository,\n    RoleRepository,\n    RefreshTokenRepository,\n    InvitationRepository,\n  ],\n})\nexport class UsersModule {}\n```\n\n### Service Layer Example\n\n```typescript\n// modules/bookings/services/booking.service.ts\nimport { Injectable, BadRequestException } from '@nestjs/common';\nimport { BookingRepository } from '../repositories/booking.repository';\nimport { CreateBookingDto, BookingDto } from '@shared/types';\nimport { PrismaService } from '../../../prisma/prisma.service';\nimport { AvailabilityService } from './availability.service';\n\n@Injectable()\nexport class BookingService {\n  constructor(\n    private bookingRepository: BookingRepository,\n    private prisma: PrismaService,\n    private availabilityService: AvailabilityService, // Internal module service\n  ) {}\n\n  async getBookingsForCalendar(dto: GetBookingsDto): Promise<{\n    data: BookingCalendarDto[];\n    pagination: PaginationDto;\n  }> {\n    const startDate = new Date(dto.startDate);\n    const endDate = new Date(dto.endDate);\n\n    if (startDate >= endDate) {\n      throw new BadRequestException('Start date must be before end date');\n    }\n\n    const page = dto.page || 1;\n    const limit = Math.min(dto.limit || 100, 100);\n\n    const filters = {\n      locationId: dto.locationId,\n      resourceId: dto.resourceId,\n      staffId: dto.staffId,\n      status: dto.status,\n    };\n\n    const [bookings, total] = await Promise.all([\n      this.bookingRepository.findByDateRange(startDate, endDate, filters, page, limit),\n      this.bookingRepository.count(startDate, endDate, filters),\n    ]);\n\n    return {\n      data: bookings.map(b => this.mapToCalendarDto(b)),\n      pagination: {\n        page,\n        limit,\n        total,\n        totalPages: Math.ceil(total / limit),\n        hasNext: page * limit < total,\n        hasPrev: page > 1,\n      },\n    };\n  }\n\n  private mapToCalendarDto(booking: any): BookingCalendarDto {\n    // Map database entity to DTO\n    return { /* ... */ };\n  }\n}\n```\n\n### Repository Layer Example\n\n```typescript\n// modules/bookings/repositories/booking.repository.ts\nimport { Injectable } from '@nestjs/common';\nimport { PrismaService } from '../../../prisma/prisma.service';\nimport { Booking } from '@prisma/client';\n\nexport interface BookingFilters {\n  locationId?: string;\n  resourceId?: string;\n  staffId?: string;\n  status?: string;\n}\n\n@Injectable()\nexport class BookingRepository {\n  constructor(private prisma: PrismaService) {}\n\n  async findByDateRange(\n    startDate: Date,\n    endDate: Date,\n    filters: BookingFilters,\n    page: number,\n    limit: number,\n  ): Promise<Booking[]> {\n    return this.prisma.booking.findMany({\n      where: {\n        startTime: { gte: startDate },\n        endTime: { lte: endDate },\n        ...this.buildFilters(filters),\n      },\n      skip: (page - 1) * limit,\n      take: limit,\n      include: {\n        lines: {\n          include: {\n            serviceOption: {\n              include: { service: true },\n            },\n          },\n        },\n      },\n      orderBy: { startTime: 'asc' },\n    });\n  }\n\n  async count(\n    startDate: Date,\n    endDate: Date,\n    filters: BookingFilters,\n  ): Promise<number> {\n    return this.prisma.booking.count({\n      where: {\n        startTime: { gte: startDate },\n        endTime: { lte: endDate },\n        ...this.buildFilters(filters),\n      },\n    });\n  }\n\n  private buildFilters(filters: BookingFilters) {\n    const where: any = {};\n    if (filters.locationId) where.locationId = filters.locationId;\n    if (filters.resourceId) where.resourceId = filters.resourceId;\n    if (filters.staffId) where.staffId = filters.staffId;\n    if (filters.status) where.status = filters.status;\n    return where;\n  }\n}\n```\n\n### Controller Layer Example\n\n```typescript\n// modules/bookings/controllers/bookings.controller.ts\nimport { Controller, Get, Post, Body, Query, UseGuards } from '@nestjs/common';\nimport { BookingService } from '../services/booking.service';\nimport { CreateBookingDto, GetBookingsDto } from '@shared/types';\nimport { JwtAuthGuard } from '../../../common/guards/jwt-auth.guard';\nimport { CurrentUser } from '../../../common/decorators/current-user.decorator';\nimport { ApiTags, ApiBearerAuth, ApiOperation } from '@nestjs/swagger';\n\n@ApiTags('Bookings')\n@Controller('api/v1/bookings')\n@UseGuards(JwtAuthGuard)\n@ApiBearerAuth()\nexport class BookingsController {\n  constructor(private bookingService: BookingService) {}\n\n  @Get('calendar')\n  @ApiOperation({ summary: 'Get bookings for calendar view' })\n  async getCalendarBookings(@Query() dto: GetBookingsDto) {\n    return this.bookingService.getBookingsForCalendar(dto);\n  }\n\n  @Post()\n  @ApiOperation({ summary: 'Create new booking' })\n  async createBooking(\n    @Body() dto: CreateBookingDto,\n    @CurrentUser() user: JwtPayload,\n  ) {\n    return this.bookingService.createBooking(dto, user);\n  }\n}\n```\n\n---\n\n## Common Infrastructure\n\n### Shared Utilities (src/common/)\n\n```typescript\n// common/decorators/current-user.decorator.ts\nimport { createParamDecorator, ExecutionContext } from '@nestjs/common';\n\nexport const CurrentUser = createParamDecorator(\n  (data: unknown, ctx: ExecutionContext) => {\n    const request = ctx.switchToHttp().getRequest();\n    return request.user;\n  },\n);\n\n// common/decorators/require-roles.decorator.ts\nimport { SetMetadata } from '@nestjs/common';\n\nexport const ROLES_KEY = 'roles';\nexport const RequireRoles = (...roles: string[]) =>\n  SetMetadata(ROLES_KEY, roles);\n\n// common/guards/jwt-auth.guard.ts\nimport { Injectable, ExecutionContext } from '@nestjs/common';\nimport { AuthGuard } from '@nestjs/passport';\nimport { Reflector } from '@nestjs/core';\n\n@Injectable()\nexport class JwtAuthGuard extends AuthGuard('jwt') {\n  constructor(private reflector: Reflector) {\n    super();\n  }\n\n  canActivate(context: ExecutionContext) {\n    const isPublic = this.reflector.get<boolean>(\n      'isPublic',\n      context.getHandler(),\n    );\n    if (isPublic) {\n      return true;\n    }\n    return super.canActivate(context);\n  }\n}\n\n// common/interceptors/audit.interceptor.ts\nimport { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';\nimport { Observable } from 'rxjs';\nimport { tap } from 'rxjs/operators';\n\n@Injectable()\nexport class AuditInterceptor implements NestInterceptor {\n  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {\n    const request = context.switchToHttp().getRequest();\n    const { method, url, user } = request;\n\n    return next.handle().pipe(\n      tap(() => {\n        // Log audit event\n        console.log(`[AUDIT] ${method} ${url} - User: ${user?.id}`);\n      }),\n    );\n  }\n}\n```\n\n---\n\n## Module Communication Patterns\n\n### 1. Service Injection (Recommended)\n\n```typescript\n@Module({\n  imports: [UserModule], // Import module\n  providers: [OrderService],\n})\nexport class OrderModule {}\n\n@Injectable()\nexport class OrderService {\n  constructor(private userService: UserService) {} // Inject service\n\n  async createOrder(userId: string, items: OrderItem[]) {\n    const user = await this.userService.findById(userId);\n    // ... create order\n  }\n}\n```\n\n### 2. Domain Events (For Decoupling)\n\n```typescript\n// shared/events/user-created.event.ts\nexport class UserCreatedEvent {\n  constructor(\n    public readonly userId: string,\n    public readonly email: string,\n  ) {}\n}\n\n// modules/user/user.service.ts\nimport { EventEmitter2 } from '@nestjs/event-emitter';\n\n@Injectable()\nexport class UserService {\n  constructor(private eventEmitter: EventEmitter2) {}\n\n  async createUser(dto: CreateUserDto): Promise<User> {\n    const user = await this.userRepo.create(dto);\n\n    // Emit event instead of calling NotificationService directly\n    this.eventEmitter.emit(\n      'user.created',\n      new UserCreatedEvent(user.id, user.email),\n    );\n\n    return user;\n  }\n}\n\n// modules/notification/notification.listener.ts\nimport { OnEvent } from '@nestjs/event-emitter';\n\n@Injectable()\nexport class NotificationListener {\n  constructor(private notificationService: NotificationService) {}\n\n  @OnEvent('user.created')\n  async handleUserCreated(event: UserCreatedEvent) {\n    await this.notificationService.sendWelcomeEmail(event.email);\n  }\n}\n```\n\n### 3. Handling Circular Dependencies\n\nUse `forwardRef()` when modules depend on each other:\n\n```typescript\n@Module({\n  imports: [\n    forwardRef(() => AuthModule), // Break circular dependency\n    UserModule,\n  ],\n})\nexport class UserModule {}\n\n@Module({\n  imports: [\n    forwardRef(() => UserModule),\n  ],\n})\nexport class AuthModule {}\n```\n\n---\n\n## Database Strategy\n\n### Shared Database with Module Boundaries\n\n```typescript\n// prisma/schema.prisma\nmodel User {\n  id        String   @id @default(uuid())\n  email     String   @unique\n  name      String\n  // ... user fields\n\n  bookings  Booking[] // Relation to Booking module\n}\n\nmodel Booking {\n  id        String   @id @default(uuid())\n  userId    String\n  user      User     @relation(fields: [userId], references: [id])\n  // ... booking fields\n}\n```\n\n**Rules:**\n- Modules can define their own tables\n- Foreign keys can exist across module boundaries\n- Never query another module's tables directly\n- Use service layer for cross-module data access\n\n---\n\n## Migration Strategy to Microservices\n\n### Gradual Extraction\n\nWhen a module becomes too large or needs independent scaling:\n\n1. **Identify Bounded Context**: Choose a well-defined module (e.g., Payment)\n2. **Extract API**: Define clean REST/gRPC interface\n3. **Deploy as Service**: Run alongside monolith\n4. **Route Traffic**: Use API gateway or service mesh\n5. **Migrate Data**: Extract module's database tables\n\n### Example: Extracting Payment Module\n\n**Before (Monolith):**\n```typescript\n@Module({\n  imports: [PaymentModule],\n})\nexport class OrderModule {}\n\n@Injectable()\nexport class OrderService {\n  constructor(private paymentService: PaymentService) {}\n}\n```\n\n**After (Microservice):**\n```typescript\n@Module({\n  providers: [PaymentClient], // HTTP client\n})\nexport class OrderModule {}\n\n@Injectable()\nexport class OrderService {\n  constructor(private paymentClient: PaymentClient) {} // Remote call\n\n  async createOrder(items: OrderItem[]) {\n    const payment = await this.paymentClient.processPayment({\n      amount: total,\n      method: 'card',\n    }); // HTTP call to payment microservice\n  }\n}\n```\n\n---\n\n## Best Practices\n\n### Module Design\n\n✅ **DO:**\n- Design modules around business capabilities (bounded contexts)\n- Keep modules independently testable\n- Export only what's necessary (minimal public API)\n- Use DTOs for module boundaries\n- Document module dependencies\n- Use events for loose coupling\n\n❌ **DON'T:**\n- Create circular dependencies without forwardRef\n- Access other modules' repositories directly\n- Share entities across modules\n- Create \"util\" or \"common\" modules that grow indefinitely\n- Let modules know about internal structure of other modules\n\n### Testing Strategy\n\n```typescript\n// Unit test - mock dependencies\ndescribe('BookingService', () => {\n  let service: BookingService;\n  let repo: jest.Mocked<BookingRepository>;\n\n  beforeEach(async () => {\n    const module = await Test.createTestingModule({\n      providers: [\n        BookingService,\n        {\n          provide: BookingRepository,\n          useValue: { findById: jest.fn() },\n        },\n      ],\n    }).compile();\n\n    service = module.get(BookingService);\n    repo = module.get(BookingRepository);\n  });\n\n  it('should find booking by id', async () => {\n    repo.findById.mockResolvedValue(mockBooking);\n    const result = await service.findById('123');\n    expect(result).toEqual(mockBooking);\n  });\n});\n\n// Integration test - test module interactions\ndescribe('BookingModule (Integration)', () => {\n  let app: INestApplication;\n\n  beforeAll(async () => {\n    const module = await Test.createTestingModule({\n      imports: [BookingModule, PrismaModule],\n    }).compile();\n\n    app = module.createNestApplication();\n    await app.init();\n  });\n\n  it('should create booking', async () => {\n    return request(app.getHttpServer())\n      .post('/bookings')\n      .send(createBookingDto)\n      .expect(201);\n  });\n});\n```\n\n---\n\n## Common Pitfalls\n\n❌ **Distributed Monolith**: Extracting services too early without clear boundaries\n❌ **God Module**: One module that knows about everything\n❌ **Anemic Modules**: Modules with no business logic (just CRUD)\n❌ **Database Coupling**: Modules directly accessing other modules' tables\n❌ **Tight Coupling**: Services calling other modules' controllers directly\n❌ **No Boundaries**: Shared entities and logic across modules\n❌ **Premature Microservices**: Splitting before understanding domain\n\n---\n\n## Key Takeaways\n\n1. **Start with Monolith**: Begin as modular monolith, extract microservices when needed\n2. **Module = Bounded Context**: Each module represents a business capability\n3. **Strong Boundaries**: Modules communicate via services, never direct database access\n4. **Layered Architecture**: Controllers → Services → Repositories\n5. **Loose Coupling**: Use events for cross-module communication\n6. **Shared Infrastructure**: Common guards, decorators, interceptors\n7. **Migration Ready**: Design for future extraction to microservices\n8. **Test Independently**: Each module should be testable in isolation\n\n**Remember:** \"Almost all successful microservice stories have started with a monolith that got too big and was broken up\" - Martin Fowler\n",
    "original/architecture/serverless-architecture.md": "# Serverless Architecture\n\n## Overview\n\nServerless architecture is a cloud computing execution model where cloud providers dynamically manage server infrastructure allocation and scaling. Despite the name, servers still exist—the distinction is that organizations don't manage them.\n\n**Core Philosophy:** Focus on business logic while delegating infrastructure management to cloud providers.\n\n## Definitions\n\n### Backend as a Service (BaaS)\n\nThird-party cloud-hosted applications and services that manage server-side logic and state, eliminating the need to build and maintain backend infrastructure.\n\n**Common Service Categories:**\n- **Authentication & Authorization**: User management, OAuth, SSO\n- **Databases**: Managed NoSQL/SQL with client SDKs\n- **Storage**: Object storage, CDN, media processing\n- **Analytics & Monitoring**: Application insights, user behavior tracking\n- **Messaging**: Push notifications, email, SMS\n\n**Architecture Pattern:**\n- Rich clients (SPAs, mobile apps) communicate directly with cloud services\n- Client-side logic handles routing and UI state\n- Server-side business rules enforced through service configuration\n\n### Functions as a Service (FaaS)\n\nDeveloper-written code that runs in stateless, event-triggered, ephemeral containers fully managed by cloud vendors.\n\n**Key Characteristics:**\n- **Event-Driven**: Triggered by HTTP requests, database changes, file uploads, scheduled events, message queues\n- **Automatic Scaling**: Platform handles scaling from zero to thousands of concurrent executions\n- **Stateless Compute**: Each invocation is independent; no guaranteed state persistence\n- **Pay-Per-Execution**: Billing based on actual compute time and memory used\n\n---\n\n## Core Principles\n\n### 1. Statelessness\n\n**Constraint:** Functions cannot reliably persist local state between invocations. Container lifecycles are managed by the platform.\n\n❌ **Anti-pattern (In-Memory State):**\n```typescript\n// Don't rely on in-memory cache persisting\nlet cache: Map<string, any> = new Map();\n\nexport const handler = async (event) => {\n  // Cache may be empty due to cold start or container recycling\n  if (!cache.has(event.key)) {\n    cache.set(event.key, await fetchData(event.key));\n  }\n  return cache.get(event.key);\n};\n```\n\n✅ **Correct (Externalized State):**\n```typescript\n// Use external state store (Redis, DynamoDB, etc.)\nexport const handler = async (event) => {\n  const cached = await stateStore.get(event.key);\n\n  if (!cached) {\n    const data = await fetchData(event.key);\n    await stateStore.set(event.key, data, { ttl: 3600 });\n    return data;\n  }\n\n  return cached;\n};\n```\n\n**State Storage Options:**\n- **Caching**: Redis, Memcached\n- **Databases**: DynamoDB, Firestore, PostgreSQL\n- **Object Storage**: S3, Cloud Storage\n- **Session Management**: Managed session services\n\n### 2. Execution Time Limits\n\nAll FaaS platforms impose maximum execution time limits (typically ranging from seconds to minutes).\n\n**Implications:**\n- Long-running batch jobs require chunking or alternative approaches\n- Video/media processing may need orchestration across multiple functions\n- Background jobs should be split into smaller units\n\n**Strategies for Long Operations:**\n```typescript\n// Use orchestration (Step Functions, Workflows)\n// 1. Break into smaller steps\n// 2. Chain functions via messages\n// 3. Store intermediate state externally\n// 4. Use dedicated batch processing services for truly long tasks\n\n// Example: Processing large dataset\nexport const processChunk = async (event) => {\n  const { batchId, offset, limit } = event;\n\n  const records = await fetchRecords(offset, limit);\n  await processRecords(records);\n\n  // Trigger next chunk if more data exists\n  if (records.length === limit) {\n    await queue.send({ batchId, offset: offset + limit, limit });\n  }\n};\n```\n\n### 3. Cold Starts\n\n**Definition:** Initialization delay when creating a new function container.\n\n**Factors Affecting Cold Start Performance:**\n- Language runtime characteristics\n- Package size and dependency count\n- Network configuration (VPC adds latency)\n- Memory allocation settings\n- Platform optimizations\n\n**Mitigation Strategies:**\n\n```typescript\n// 1. Minimize dependencies\n// Instead of importing entire SDK\nimport AWS from 'aws-sdk'; // ❌ Large bundle\n\n// Import only what's needed\nimport { DynamoDB } from '@aws-sdk/client-dynamodb'; // ✅ Smaller\n\n// 2. Initialize outside handler (reused across warm invocations)\nconst db = new Database(config); // Initialize once\n\nexport const handler = async (event) => {\n  // Use initialized client\n  return db.query(event.query);\n};\n\n// 3. Lazy load heavy dependencies\nlet heavyLib: any;\nexport const handler = async (event) => {\n  if (event.requiresHeavyLib && !heavyLib) {\n    heavyLib = await import('heavy-library');\n  }\n  // ...\n};\n\n// 4. Provisioned capacity (platform feature, costs extra)\n// Pre-warmed containers always ready\n```\n\n**When Cold Starts Matter:**\n- Synchronous user-facing APIs (latency-sensitive)\n- Real-time data processing\n- Infrequently called functions\n\n**When Cold Starts Don't Matter:**\n- Asynchronous background processing\n- High-throughput services (containers stay warm)\n- Scheduled batch jobs\n\n### 4. API Gateway Pattern\n\nHTTP requests typically route through an API gateway layer before reaching functions.\n\n**API Gateway Responsibilities:**\n- Route mapping and request routing\n- Authentication and authorization\n- Request validation\n- Response transformation\n- Rate limiting and throttling\n- CORS configuration\n\n❌ **Anti-pattern (Business Logic in Gateway):**\n```yaml\n# Complex transformation logic in configuration\nrequestTemplate: |\n  {\n    \"action\": #if($input.params('type') == 'premium')\"priority\"#else\"standard\"#end,\n    \"discount\": #if($input.params('coupon')==\"SAVE20\")0.2#else0#end\n  }\n```\n\n✅ **Correct (Simple Passthrough):**\n```yaml\nrequestTemplate: |\n  {\n    \"type\": \"$input.params('type')\",\n    \"coupon\": \"$input.params('coupon')\"\n  }\n```\n\n```typescript\n// Business logic in testable function code\nexport const handler = async (event) => {\n  const action = event.type === 'premium' ? 'priority' : 'standard';\n  const discount = event.coupon === 'SAVE20' ? 0.2 : 0;\n\n  return processRequest(action, discount);\n};\n```\n\n---\n\n## Benefits\n\n### Operational Benefits\n\n**1. No Infrastructure Management**\n- No server provisioning or capacity planning\n- No OS patching or security updates\n- No infrastructure monitoring or alerting\n- Platform handles availability and fault tolerance\n\n**2. Automatic Scaling**\n```\nTraditional: Manual scaling rules, pre-provisioned capacity\nServerless: Instant scaling from 0 to N concurrent executions\n\nExample: API receives 10 req/sec → platform runs 10 function instances\n          Spike to 1,000 req/sec → platform runs 1,000 instances (automatic)\n          Back to 10 req/sec → platform scales down (automatic)\n```\n\n**3. Built-in High Availability**\n- Functions deployed across multiple availability zones\n- Platform handles failover and redundancy\n- No manual disaster recovery configuration\n\n### Economic Benefits\n\n**1. Pay-Per-Use Pricing**\n```\nTraditional server: Pay for capacity regardless of utilization\nServerless: Pay only for actual execution time\n\nExample scenarios:\n- Occasional webhook: 100 calls/month → minimal cost\n- Spiky traffic: Pay for peaks only, not constant high capacity\n- Development/staging: Zero cost when not in use\n```\n\n**2. Fine-Grained Optimization**\n```\nPerformance improvement = Cost reduction\n\nExample: Optimize function from 500ms to 250ms execution\nResult: 50% cost savings (direct correlation)\n```\n\n**3. No Over-Provisioning**\n- Eliminates paying for idle capacity\n- No \"planning for peak\" waste\n- Cost scales linearly with usage\n\n### Development Benefits\n\n**1. Simplified Deployment**\n- Package code as zip/container\n- Deploy via CLI or CI/CD\n- No complex orchestration required\n- Built-in versioning and rollback\n\n**2. Faster Experimentation**\n```typescript\n// Deploy new feature in minutes\nexport const handler = async (event) => {\n  if (event.experimentGroup === 'beta') {\n    return experimentalFeature(event);\n  }\n  return existingFeature(event);\n};\n```\n\n**3. Microservices Without Orchestration**\n- Each function is independently deployable\n- No service discovery complexity\n- Platform-managed routing\n\n---\n\n## Drawbacks & Limitations\n\n### Vendor Lock-In\n\n**Problem:** Each cloud provider has different APIs, deployment models, and service integrations.\n\n```typescript\n// AWS Lambda signature\nexport const handler = async (\n  event: APIGatewayProxyEvent,\n  context: Context\n): Promise<APIGatewayProxyResult> => { /* ... */ };\n\n// Azure Functions signature (different)\nexport default async function (\n  context: Context,\n  req: HttpRequest\n): Promise<void> { /* ... */ };\n\n// Google Cloud Functions signature (different)\nexport const handler = (req: Request, res: Response) => { /* ... */ };\n```\n\n**Migration Complexity:**\n- Rewrite function signatures and event handling\n- Update deployment configurations and tooling\n- Migrate dependent services (databases, queues, auth)\n- Retrain team on new platform\n\n**Mitigation Strategy:**\n```typescript\n// Abstraction layer (adds complexity vs benefit trade-off)\ninterface UniversalEvent {\n  body: any;\n  headers: Record<string, string>;\n  queryParams: Record<string, string>;\n}\n\n// Business logic (platform-agnostic)\nasync function processRequest(event: UniversalEvent) {\n  // Core logic independent of platform\n}\n\n// Platform adapters\nexport const awsHandler = (event: AWSEvent) => {\n  return processRequest(normalizeAWSEvent(event));\n};\n\nexport const azureHandler = (context, req) => {\n  return processRequest(normalizeAzureEvent(req));\n};\n```\n\n### Security Concerns\n\n**1. Expanded Attack Surface**\n- Multiple third-party service integrations\n- Client-to-service direct access (BaaS)\n- IAM policy complexity\n- Function proliferation\n\n**2. IAM Misconfiguration Risk**\n```typescript\n// ❌ Overly permissive (common mistake)\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"*\",\n  \"Resource\": \"*\"\n}\n\n// ✅ Principle of least privilege\n{\n  \"Effect\": \"Allow\",\n  \"Action\": [\"s3:GetObject\", \"s3:PutObject\"],\n  \"Resource\": \"arn:aws:s3:::my-bucket/uploads/*\"\n}\n```\n\n**3. Client-Side Security Challenges (BaaS)**\n```typescript\n// All validation must be in database rules, not client code\n// Client code can be bypassed/modified\n\n// ✅ Enforce security server-side (Firebase example)\n// firestore.rules\nrules_version = '2';\nservice cloud.firestore {\n  match /users/{userId} {\n    allow read: if request.auth != null;\n    allow write: if request.auth.uid == userId\n      && !request.resource.data.diff(resource.data).affectedKeys().hasAny(['role', 'permissions']);\n  }\n}\n```\n\n### Testing Complexity\n\n**Challenge:** Integration testing with real cloud services.\n\n**Unit Testing:** Works normally\n```typescript\ndescribe('calculateTotal', () => {\n  it('should sum item prices', () => {\n    const total = calculateTotal([{ price: 10 }, { price: 20 }]);\n    expect(total).toBe(30);\n  });\n});\n```\n\n**Integration Testing:** Requires cloud environment\n```typescript\n// Option 1: Local emulators (limited fidelity)\n// Option 2: Separate cloud account for testing (recommended)\n// Option 3: Shared test environment (collision risks)\n\ndescribe('orderFunction (integration)', () => {\n  it('should persist order to database', async () => {\n    // Requires real database or high-fidelity emulator\n    const result = await handler(createOrderEvent);\n    const order = await db.get(result.orderId);\n    expect(order.status).toBe('created');\n\n    // Cleanup required\n    await db.delete(result.orderId);\n  });\n});\n```\n\n### Debugging Challenges\n\n**Limited Debugging Capabilities:**\n- No interactive debuggers in production\n- Ephemeral containers make state inspection difficult\n- Rely primarily on logging and distributed tracing\n- Vendor tools vary in maturity\n\n**Best Practice: Comprehensive Logging**\n```typescript\n// Structured logging with context\nexport const handler = async (event, context) => {\n  logger.addContext({\n    requestId: context.requestId,\n    userId: event.userId\n  });\n\n  logger.info('Processing order', { itemCount: event.items.length });\n\n  try {\n    const result = await processOrder(event);\n    logger.info('Order created', { orderId: result.id });\n    return result;\n  } catch (error) {\n    logger.error('Order failed', { error, event });\n    throw error;\n  }\n};\n```\n\n### Monitoring Complexity\n\n**Challenges:**\n- Distributed system observability\n- Multiple services and function interactions\n- Platform-provided metrics may be basic\n- Requires distributed tracing infrastructure\n\n**Essential Monitoring:**\n- Execution duration and errors\n- Cold start frequency\n- Throttling and concurrency limits\n- Cost per function\n- Distributed request tracing\n\n### Resource Limits\n\n**Common Constraints:**\n- Maximum execution time (function-level timeout)\n- Memory allocation limits\n- Concurrent execution limits (account-level)\n- Package size limits\n- Payload size limits (request/response)\n\n**Self-Inflicted Issues:**\n```\nExample: Account concurrency limit = 1,000\n\nScenario:\n- Production functions using 500 concurrent executions\n- Load test generates 800 concurrent executions\n- Result: Production throttled (500 + 800 > 1,000 limit)\n\nSolution: Reserved capacity for critical functions\n```\n\n---\n\n## Use Cases\n\n### Ideal Scenarios\n\n**1. Event-Driven Processing**\n```typescript\n// File upload triggers processing\nexport const handler = async (event: S3Event) => {\n  const bucket = event.Records[0].s3.bucket.name;\n  const key = event.Records[0].s3.object.key;\n\n  const file = await s3.getObject({ Bucket: bucket, Key: key });\n  const processed = await processFile(file.Body);\n\n  await s3.putObject({\n    Bucket: bucket,\n    Key: `processed/${key}`,\n    Body: processed\n  });\n};\n```\n\n**2. API Backends**\n```typescript\n// RESTful API with automatic scaling\nexport const getUsers = async (event) => {\n  const users = await db.query('SELECT * FROM users');\n  return {\n    statusCode: 200,\n    body: JSON.stringify({ data: users })\n  };\n};\n\nexport const createUser = async (event) => {\n  const userData = JSON.parse(event.body);\n  const user = await db.insert('users', userData);\n  return {\n    statusCode: 201,\n    body: JSON.stringify({ data: user })\n  };\n};\n```\n\n**3. Scheduled Tasks**\n```typescript\n// Cron-triggered function\n// Schedule: Every day at 2 AM\nexport const handler = async () => {\n  // Cleanup expired sessions\n  await db.delete('sessions', { expiresAt: { lt: new Date() } });\n\n  // Send daily reports\n  await emailService.sendDailyReport();\n};\n```\n\n**4. Stream Processing**\n```typescript\n// Message queue triggers function\nexport const handler = async (event: SQSEvent) => {\n  for (const record of event.Records) {\n    const message = JSON.parse(record.body);\n    await processMessage(message);\n  }\n};\n```\n\n**5. Webhooks**\n```typescript\n// Receive third-party webhooks\nexport const handler = async (event) => {\n  const signature = event.headers['x-webhook-signature'];\n\n  // Verify signature\n  if (!verifySignature(event.body, signature)) {\n    return { statusCode: 401, body: 'Invalid signature' };\n  }\n\n  const payload = JSON.parse(event.body);\n  await handleWebhookEvent(payload);\n\n  return { statusCode: 200, body: 'OK' };\n};\n```\n\n### Anti-Patterns\n\n**❌ Latency-Critical Real-Time Systems**\n- Sub-100ms response requirements\n- High-frequency trading\n- Real-time gaming servers\n\n**❌ Long-Running Batch Operations**\n- Multi-hour video encoding\n- Large-scale data migrations\n- Complex scientific simulations\n\n**❌ Stateful Applications**\n- Applications requiring extensive in-memory caching\n- Session-heavy applications\n- WebSocket servers with persistent connections\n\n**❌ Constant High-Volume Traffic**\n- When traffic is consistently high, traditional servers may be more cost-effective\n- Calculate cost comparison before committing\n\n---\n\n## Architectural Patterns\n\n### 1. BaaS + FaaS Hybrid\n\n```typescript\n// Client: Direct database access (simple operations)\nconst products = await db.collection('products')\n  .where('category', '==', 'electronics')\n  .get();\n\n// Client: Call function (complex business logic)\nconst searchResults = await functions.call('complexSearch', {\n  query: 'wireless headphones',\n  filters: { priceMax: 100, brand: ['Sony', 'Bose'] }\n});\n\n// Function: Complex server-side logic\nexport const complexSearch = async (data) => {\n  // Use advanced search service\n  // Apply business rules\n  // Return processed results\n};\n```\n\n### 2. Fan-Out Pattern\n\n```typescript\n// Single event triggers multiple functions\n\n// Publisher\nawait eventBus.publish('order.created', { orderId, userId, items });\n\n// Subscriber 1: Email notification\nexport const emailHandler = async (event) => {\n  await emailService.sendConfirmation(event.userId);\n};\n\n// Subscriber 2: Analytics tracking\nexport const analyticsHandler = async (event) => {\n  await analytics.trackPurchase(event);\n};\n\n// Subscriber 3: Inventory update\nexport const inventoryHandler = async (event) => {\n  await inventory.decrementStock(event.items);\n};\n```\n\n### 3. Orchestration Pattern\n\n```typescript\n// Workflow coordination across multiple functions\n// Each step is a separate function\n\n// Step 1: Validate\nexport const validateOrder = async (order) => {\n  // Validation logic\n  return { valid: true, order };\n};\n\n// Step 2: Process payment\nexport const processPayment = async (validatedOrder) => {\n  const payment = await stripe.charge(validatedOrder.total);\n  return { ...validatedOrder, paymentId: payment.id };\n};\n\n// Step 3: Create shipment\nexport const createShipment = async (paidOrder) => {\n  const shipment = await shipping.create(paidOrder);\n  return { ...paidOrder, trackingNumber: shipment.tracking };\n};\n\n// Workflow engine coordinates: validate → payment → shipment\n```\n\n### 4. Backend for Frontend (BFF)\n\n```typescript\n// Separate functions optimized for each client type\n\n// Mobile API (minimal payload)\nexport const getMobileUserProfile = async (event) => {\n  const user = await userService.get(event.userId);\n  return {\n    id: user.id,\n    name: user.name,\n    avatar: user.avatar.thumbnailUrl // Mobile-optimized\n  };\n};\n\n// Web API (rich data)\nexport const getWebUserProfile = async (event) => {\n  const [user, orders, preferences] = await Promise.all([\n    userService.get(event.userId),\n    orderService.getUserOrders(event.userId),\n    preferenceService.get(event.userId)\n  ]);\n\n  return { user, orders, preferences }; // Comprehensive\n};\n```\n\n---\n\n## Best Practices\n\n### Design Principles\n\n**1. Single Responsibility**\n```typescript\n// ❌ God function doing everything\nexport const handler = async (event) => {\n  // Validate, process payment, send email, update inventory...\n};\n\n// ✅ Focused functions\nexport const processPayment = async (event) => {\n  // Only payment processing\n};\n\nexport const sendConfirmation = async (event) => {\n  // Only email sending\n};\n```\n\n**2. Idempotency**\n```typescript\n// Functions should be safely retriable\nexport const handler = async (event) => {\n  const requestId = event.requestId;\n\n  // Check if already processed\n  const existing = await db.get('processed_requests', requestId);\n  if (existing) {\n    return existing.result; // Return cached result\n  }\n\n  const result = await processRequest(event);\n\n  // Store result with request ID\n  await db.put('processed_requests', requestId, result);\n\n  return result;\n};\n```\n\n**3. Graceful Degradation**\n```typescript\nexport const handler = async (event) => {\n  try {\n    const enhanced = await thirdPartyService.enrich(event.data);\n    return processWithEnhancement(enhanced);\n  } catch (error) {\n    logger.warn('Enhancement failed, using basic processing', { error });\n    return processBasic(event.data); // Fallback\n  }\n};\n```\n\n### Security\n\n**1. Input Validation**\n```typescript\nimport { z } from 'zod';\n\nconst orderSchema = z.object({\n  userId: z.string().uuid(),\n  items: z.array(z.object({\n    productId: z.string(),\n    quantity: z.number().min(1).max(100)\n  }))\n});\n\nexport const handler = async (event) => {\n  const validated = orderSchema.parse(JSON.parse(event.body));\n  return createOrder(validated);\n};\n```\n\n**2. Secrets Management**\n```typescript\n// ❌ Hardcoded secrets\nconst apiKey = 'sk_live_1234567890';\n\n// ✅ Environment variables from secure store\nconst apiKey = process.env.API_KEY; // From AWS Secrets Manager, etc.\n```\n\n**3. Principle of Least Privilege**\n```typescript\n// Only grant permissions function actually needs\n// Function permissions:\n// - Read from specific S3 bucket\n// - Write to specific DynamoDB table\n// - No administrative access\n```\n\n### Performance\n\n**1. Connection Reuse**\n```typescript\n// Initialize outside handler (reused across warm invocations)\nconst dbClient = new DatabaseClient({\n  connection: {\n    keepAlive: true,\n    keepAliveInitialDelay: 60000\n  }\n});\n\nexport const handler = async (event) => {\n  // Reuse connection\n  return dbClient.query(event.query);\n};\n```\n\n**2. Parallel Operations**\n```typescript\n// ❌ Sequential (slow)\nconst user = await userService.get(userId);\nconst orders = await orderService.getByUser(userId);\nconst preferences = await preferenceService.get(userId);\n\n// ✅ Parallel (fast)\nconst [user, orders, preferences] = await Promise.all([\n  userService.get(userId),\n  orderService.getByUser(userId),\n  preferenceService.get(userId)\n]);\n```\n\n**3. Optimize Package Size**\n```typescript\n// ❌ Import entire library\nimport _ from 'lodash';\n\n// ✅ Import specific functions\nimport { sortBy, groupBy } from 'lodash';\n\n// Or use tree-shakeable alternative\nimport sortBy from 'lodash-es/sortBy';\n```\n\n### Monitoring\n\n**1. Structured Logging**\n```typescript\nexport const handler = async (event, context) => {\n  logger.info('Function invoked', {\n    requestId: context.requestId,\n    userId: event.userId,\n    action: event.action\n  });\n\n  // Log with context throughout execution\n};\n```\n\n**2. Custom Metrics**\n```typescript\nexport const handler = async (event) => {\n  const startTime = Date.now();\n\n  try {\n    const result = await processOrder(event);\n\n    metrics.record('OrderProcessed', 1);\n    metrics.record('ProcessingTime', Date.now() - startTime);\n\n    return result;\n  } catch (error) {\n    metrics.record('OrderFailed', 1);\n    throw error;\n  }\n};\n```\n\n**3. Distributed Tracing**\n```typescript\n// Enable tracing to track requests across functions\n// Correlate logs and metrics by request ID\n```\n\n---\n\n## When to Use Serverless\n\n### Ideal Candidates\n\n✅ **Variable Traffic Patterns**\n- Unpredictable spikes\n- Seasonal variations\n- Low baseline with occasional bursts\n\n✅ **Event-Driven Workloads**\n- File processing pipelines\n- Real-time data transformations\n- Webhook handlers\n- Message queue consumers\n\n✅ **Rapid Experimentation**\n- Prototypes and MVPs\n- A/B testing new features\n- Short-lived marketing campaigns\n\n✅ **API Backends**\n- RESTful APIs\n- GraphQL resolvers\n- Mobile app backends\n\n✅ **Scheduled Jobs**\n- Periodic data synchronization\n- Report generation\n- Cleanup tasks\n\n### Poor Fit\n\n❌ **Latency-Sensitive Applications**\n- Sub-100ms response requirements\n- Real-time gaming\n- High-frequency trading\n\n❌ **Long-Running Tasks**\n- Video encoding (multi-hour)\n- Large ETL jobs\n- Complex simulations\n\n❌ **Stateful Applications**\n- Applications requiring significant in-memory state\n- Traditional WebSocket servers\n- Session-heavy applications\n\n❌ **Constant High Load**\n- When traffic is consistently high, traditional infrastructure may be more cost-effective\n\n❌ **Vendor Independence Requirements**\n- On-premise-only policies\n- Multi-cloud portability needs\n- Regulatory constraints on cloud usage\n\n---\n\n## Migration Strategies\n\n### 1. Greenfield (New Projects)\n\nStart serverless by default for event-driven and API workloads.\n\n### 2. Strangler Fig Pattern\n\nGradually migrate existing applications:\n```\n1. Route subset of traffic to serverless functions\n2. Migrate feature by feature\n3. Keep monolith for complex stateful operations\n4. Eventually retire monolith when appropriate\n```\n\n### 3. Hybrid Approach\n\nUse serverless alongside traditional infrastructure:\n```\n- Serverless: Event processing, webhooks, APIs\n- Traditional: Core application, long-running jobs, stateful services\n```\n\n### 4. Edge Cases Only\n\nUse serverless for specific workloads while keeping main application traditional:\n```\n- Main app: Kubernetes cluster\n- Serverless: Image resizing, PDF generation, scheduled cleanup\n```\n\n---\n\n## Common Pitfalls\n\n❌ **Ignoring Cold Starts**: Not optimizing for cold start performance\n❌ **Over-Engineering Abstractions**: Complex vendor-agnostic layers that add little value\n❌ **Configuration Over Code**: Business logic in API gateway config\n❌ **No Reserved Capacity**: Production throttled by test workloads\n❌ **Insufficient Logging**: Can't debug production issues\n❌ **Stateful Assumptions**: Relying on in-memory state\n❌ **Missing Timeouts**: Functions running longer than necessary\n❌ **No Cost Monitoring**: Surprise bills from inefficient functions\n❌ **Security Neglect**: Overly permissive IAM policies\n\n---\n\n## Key Takeaways\n\n1. **Serverless ≠ No Servers**: Infrastructure still exists, you just don't manage it\n2. **Two Paradigms**: BaaS (managed services) and FaaS (event-driven functions)\n3. **Stateless by Nature**: External state storage required\n4. **Automatic Scaling**: From zero to thousands of instances\n5. **Pay-Per-Use**: Cost directly correlates with usage\n6. **Vendor Lock-In**: Real consideration, plan mitigation strategy\n7. **Cold Starts**: Optimize package size and consider provisioned capacity\n8. **Cloud-Native Testing**: Integration tests in actual cloud environment\n9. **Security Complexity**: Multiple services = expanded attack surface\n10. **Not Universal**: Evaluate fit before adoption\n\n**Decision Framework:**\n\n```\nUse Serverless When:\n├─ Traffic is variable or unpredictable\n├─ Event-driven architecture fits the use case\n├─ Development speed is priority\n├─ Operational overhead must be minimized\n└─ Cost optimization for low/variable usage is important\n\nAvoid Serverless When:\n├─ Sub-100ms latency requirements\n├─ Long-running operations (hours)\n├─ Heavy stateful requirements\n├─ Vendor independence is critical\n└─ Consistent high load (traditional may be cheaper)\n```\n\n**Remember:** Serverless is an architectural choice with specific trade-offs, not a universal solution. Success requires understanding constraints, accepting vendor dependencies, and matching workloads to platform strengths.\n\n## Further Reading\n\n**Official Documentation:**\n- AWS Lambda Developer Guide\n- Google Cloud Functions Documentation\n- Azure Functions Documentation\n- Cloudflare Workers Docs\n\n**Platform-Specific Limits:** Consult official documentation for current:\n- Execution time limits\n- Memory limits\n- Concurrency limits\n- Package size restrictions\n- Payload size limits\n- Pricing models\n\n**Community Resources:**\n- Serverless Framework Documentation\n- AWS SAM Documentation\n- Serverless Patterns Collection\n- Cloud provider architecture blogs\n",
    "original/architecture/solid-principles.md": "# SOLID Principles Guidelines\n\n## Overview\n\nSOLID is an acronym for five design principles that make software designs more understandable, flexible, and maintainable. Introduced by Robert C. Martin (Uncle Bob), these principles form the foundation of good object-oriented design.\n\n## S - Single Responsibility Principle (SRP)\n\n### Definition\n\n**\"A class should have one, and only one, reason to change.\"**\n\nEach module, class, or function should have responsibility over a single part of functionality, and that responsibility should be entirely encapsulated by the class.\n\n### Why It Matters\n\n- **Maintainability:** Changes to one responsibility don't affect others\n- **Testability:** Easier to test focused, single-purpose code\n- **Understandability:** Clear, obvious purpose\n\n### Examples\n\n❌ **Violates SRP:**\n```typescript\nclass User {\n  constructor(public name: string, public email: string) {}\n\n  save() {\n    // Database logic\n    const db = new Database();\n    db.insert('users', this);\n  }\n\n  sendEmail(message: string) {\n    // Email logic\n    const mailer = new Mailer();\n    mailer.send(this.email, message);\n  }\n\n  generateReport(): string {\n    // Reporting logic\n    return `User Report: ${this.name}`;\n  }\n}\n```\n\n**Problems:** Class has three reasons to change (database, email, reporting)\n\n✅ **Follows SRP:**\n```typescript\nclass User {\n  constructor(public name: string, public email: string) {}\n}\n\nclass UserRepository {\n  save(user: User) {\n    const db = new Database();\n    db.insert('users', user);\n  }\n}\n\nclass EmailService {\n  sendToUser(user: User, message: string) {\n    const mailer = new Mailer();\n    mailer.send(user.email, message);\n  }\n}\n\nclass UserReportGenerator {\n  generate(user: User): string {\n    return `User Report: ${user.name}`;\n  }\n}\n```\n\n### Best Practices\n\n✅ **DO:**\n- One class = one responsibility\n- Extract cohesive functionality into separate classes\n- Name classes after their single responsibility\n\n❌ **DON'T:**\n- Create \"god objects\" that do everything\n- Mix business logic with infrastructure concerns\n- Combine unrelated functionality\n\n---\n\n## O - Open/Closed Principle (OCP)\n\n### Definition\n\n**\"Software entities should be open for extension but closed for modification.\"**\n\nYou should be able to add new functionality without changing existing code.\n\n### Why It Matters\n\n- **Stability:** Existing code doesn't break when adding features\n- **Flexibility:** Easy to extend behavior\n- **Risk Reduction:** Less chance of introducing bugs\n\n### Examples\n\n❌ **Violates OCP:**\n```typescript\nclass PaymentProcessor {\n  processPayment(type: string, amount: number) {\n    if (type === 'credit-card') {\n      // Process credit card\n    } else if (type === 'paypal') {\n      // Process PayPal\n    } else if (type === 'bitcoin') {\n      // Process Bitcoin - MODIFIED existing code\n    }\n  }\n}\n```\n\n**Problem:** Adding new payment type requires modifying existing code\n\n✅ **Follows OCP:**\n```typescript\ninterface PaymentMethod {\n  process(amount: number): Promise<PaymentResult>;\n}\n\nclass CreditCardPayment implements PaymentMethod {\n  async process(amount: number): Promise<PaymentResult> {\n    // Credit card logic\n  }\n}\n\nclass PayPalPayment implements PaymentMethod {\n  async process(amount: number): Promise<PaymentResult> {\n    // PayPal logic\n  }\n}\n\nclass BitcoinPayment implements PaymentMethod {\n  async process(amount: number): Promise<PaymentResult> {\n    // Bitcoin logic - NEW class, no modification\n  }\n}\n\nclass PaymentProcessor {\n  constructor(private method: PaymentMethod) {}\n\n  async process(amount: number): Promise<PaymentResult> {\n    return this.method.process(amount);\n  }\n}\n```\n\n### Best Practices\n\n✅ **DO:**\n- Use interfaces and abstract classes\n- Employ strategy pattern for variation\n- Use dependency injection\n- Design for extension points\n\n❌ **DON'T:**\n- Use long if/else or switch statements for type checking\n- Modify existing classes for new behavior\n- Hard-code dependencies\n\n---\n\n## L - Liskov Substitution Principle (LSP)\n\n### Definition\n\n**\"Subtypes must be substitutable for their base types without altering program correctness.\"**\n\nIf S is a subtype of T, then objects of type T can be replaced with objects of type S without breaking the program.\n\n### Why It Matters\n\n- **Polymorphism:** True object-oriented behavior\n- **Reliability:** Subtypes honor base type contracts\n- **Predictability:** No surprising behavior changes\n\n### Examples\n\n❌ **Violates LSP:**\n```typescript\nclass Rectangle {\n  constructor(protected width: number, protected height: number) {}\n\n  setWidth(width: number) {\n    this.width = width;\n  }\n\n  setHeight(height: number) {\n    this.height = height;\n  }\n\n  getArea(): number {\n    return this.width * this.height;\n  }\n}\n\nclass Square extends Rectangle {\n  setWidth(width: number) {\n    this.width = width;\n    this.height = width; // Violates expectation\n  }\n\n  setHeight(height: number) {\n    this.width = height; // Violates expectation\n    this.height = height;\n  }\n}\n\n// This breaks LSP\nfunction resize(rectangle: Rectangle) {\n  rectangle.setWidth(5);\n  rectangle.setHeight(4);\n  console.log(rectangle.getArea()); // Expects 20\n}\n\nresize(new Square(3)); // Outputs 16, not 20!\n```\n\n✅ **Follows LSP:**\n```typescript\ninterface Shape {\n  getArea(): number;\n}\n\nclass Rectangle implements Shape {\n  constructor(private width: number, private height: number) {}\n\n  getArea(): number {\n    return this.width * this.height;\n  }\n}\n\nclass Square implements Shape {\n  constructor(private size: number) {}\n\n  getArea(): number {\n    return this.size * this.size;\n  }\n}\n```\n\n### Best Practices\n\n✅ **DO:**\n- Ensure derived classes honor base class contracts\n- Validate that subtypes can replace base types\n- Avoid strengthening preconditions in subtypes\n- Avoid weakening postconditions in subtypes\n\n❌ **DON'T:**\n- Override methods to do nothing or throw errors\n- Change expected behavior in subtypes\n- Break base class invariants\n- Use inheritance for code reuse only\n\n---\n\n## I - Interface Segregation Principle (ISP)\n\n### Definition\n\n**\"Clients should not be forced to depend on interfaces they don't use.\"**\n\nMany specific interfaces are better than one general-purpose interface.\n\n### Why It Matters\n\n- **Cohesion:** Interfaces represent specific capabilities\n- **Flexibility:** Easier to implement small interfaces\n- **Decoupling:** Clients depend only on what they need\n\n### Examples\n\n❌ **Violates ISP:**\n```typescript\ninterface Worker {\n  work(): void;\n  eat(): void;\n  sleep(): void;\n}\n\nclass Human implements Worker {\n  work() { /* ... */ }\n  eat() { /* ... */ }\n  sleep() { /* ... */ }\n}\n\nclass Robot implements Worker {\n  work() { /* ... */ }\n  eat() { throw new Error('Robots don\\'t eat'); } // Forced to implement\n  sleep() { throw new Error('Robots don\\'t sleep'); } // Forced to implement\n}\n```\n\n✅ **Follows ISP:**\n```typescript\ninterface Workable {\n  work(): void;\n}\n\ninterface Eatable {\n  eat(): void;\n}\n\ninterface Sleepable {\n  sleep(): void;\n}\n\nclass Human implements Workable, Eatable, Sleepable {\n  work() { /* ... */ }\n  eat() { /* ... */ }\n  sleep() { /* ... */ }\n}\n\nclass Robot implements Workable {\n  work() { /* ... */ }\n  // Only implements what it needs\n}\n```\n\n### Best Practices\n\n✅ **DO:**\n- Create focused, cohesive interfaces\n- Use interface composition\n- Design interfaces from client perspective\n- Keep interfaces small\n\n❌ **DON'T:**\n- Create fat interfaces with many methods\n- Force implementations to throw \"not implemented\" errors\n- Add methods to interfaces that only some implementers need\n\n---\n\n## D - Dependency Inversion Principle (DIP)\n\n### Definition\n\n**\"High-level modules should not depend on low-level modules. Both should depend on abstractions.\"**\n\n**\"Abstractions should not depend on details. Details should depend on abstractions.\"**\n\n### Why It Matters\n\n- **Flexibility:** Easy to swap implementations\n- **Testability:** Easy to mock dependencies\n- **Decoupling:** High-level policy independent of details\n\n### Examples\n\n❌ **Violates DIP:**\n```typescript\nclass MySQLDatabase {\n  save(data: any) {\n    // MySQL specific code\n  }\n}\n\nclass UserService {\n  private database = new MySQLDatabase(); // Direct dependency\n\n  saveUser(user: User) {\n    this.database.save(user);\n  }\n}\n```\n\n**Problem:** UserService tightly coupled to MySQL\n\n✅ **Follows DIP:**\n```typescript\ninterface Database {\n  save(data: any): void;\n}\n\nclass MySQLDatabase implements Database {\n  save(data: any) {\n    // MySQL specific code\n  }\n}\n\nclass PostgreSQLDatabase implements Database {\n  save(data: any) {\n    // PostgreSQL specific code\n  }\n}\n\nclass UserService {\n  constructor(private database: Database) {} // Depends on abstraction\n\n  saveUser(user: User) {\n    this.database.save(user);\n  }\n}\n\n// Composition root\nconst database = new MySQLDatabase();\nconst userService = new UserService(database);\n```\n\n### Best Practices\n\n✅ **DO:**\n- Define interfaces in high-level modules\n- Inject dependencies through constructors\n- Depend on abstractions, not concretions\n- Use dependency injection containers\n\n❌ **DON'T:**\n- Use `new` keyword in business logic\n- Hard-code dependencies\n- Let abstractions depend on implementation details\n- Create dependencies on concrete classes\n\n---\n\n## Applying SOLID Together\n\n### Real-World Example\n\n```typescript\n// Domain (high-level)\ninterface OrderRepository {\n  save(order: Order): Promise<void>;\n  findById(id: string): Promise<Order | null>;\n}\n\ninterface PaymentGateway {\n  charge(amount: Money): Promise<PaymentResult>;\n}\n\n// Use Case (high-level, depends on abstractions - DIP)\nclass CreateOrderUseCase {\n  constructor(\n    private orderRepo: OrderRepository, // ISP - focused interface\n    private paymentGateway: PaymentGateway // ISP - focused interface\n  ) {}\n\n  async execute(request: CreateOrderRequest): Promise<OrderResult> { // SRP - one responsibility\n    const order = Order.create(request.items); // OCP - extend through new Orders\n    const payment = await this.paymentGateway.charge(order.total);\n\n    if (payment.successful) {\n      await this.orderRepo.save(order);\n      return { success: true, orderId: order.id };\n    }\n\n    return { success: false, error: 'Payment failed' };\n  }\n}\n\n// Infrastructure (low-level, implements abstractions - DIP, LSP)\nclass PostgreSQLOrderRepository implements OrderRepository {\n  async save(order: Order): Promise<void> {\n    // PostgreSQL implementation\n  }\n\n  async findById(id: string): Promise<Order | null> {\n    // PostgreSQL implementation\n  }\n}\n\nclass StripePaymentGateway implements PaymentGateway {\n  async charge(amount: Money): Promise<PaymentResult> {\n    // Stripe implementation\n  }\n}\n```\n\n## Benefits of SOLID\n\n✅ **Maintainability:** Easier to understand and modify\n✅ **Testability:** Easier to write unit tests\n✅ **Flexibility:** Easy to extend and adapt\n✅ **Reusability:** Components can be reused\n✅ **Scalability:** Architecture supports growth\n✅ **Collaboration:** Clear boundaries and contracts\n\n## Common Pitfalls\n\n❌ Over-engineering simple solutions\n❌ Creating abstractions prematurely\n❌ Too many small classes (analysis paralysis)\n❌ Violating principles in the name of \"pragmatism\"\n❌ Not refactoring when violations accumulate\n❌ Treating SOLID as dogma rather than guidelines\n\n## When to Apply SOLID\n\n✅ **Always Consider:**\n- SRP when designing classes\n- OCP when identifying variation points\n- DIP for major dependencies\n\n⚠️ **Apply Judiciously:**\n- LSP if using inheritance\n- ISP if interfaces grow large\n- Full SOLID in complex domains\n\n❌ **Don't Over-Apply:**\n- Simple scripts or utilities\n- Prototypes or experiments\n- Very stable, simple code\n\n## Key Takeaways\n\n1. **SRP:** One class, one responsibility\n2. **OCP:** Extend behavior without modifying code\n3. **LSP:** Subtypes must be substitutable\n4. **ISP:** Prefer many small interfaces\n5. **DIP:** Depend on abstractions, not concretions\n\n**Remember:** SOLID principles are guidelines, not laws. Apply them thoughtfully based on context and complexity.\n",
    "original/development-practices/api-versioning.md": "# API Design & Versioning Strategies\n\n## API Versioning Strategies\n\n### URL Path Versioning\n\n```typescript\n// Version in URL path\napp.get('/api/v1/users', getUsersV1);\napp.get('/api/v2/users', getUsersV2);\n\n// ✅ Pros: Clear, cacheable, easy to route\n// ❌ Cons: URL changes, forces new version for all endpoints\n```\n\n### Header Versioning\n\n```typescript\napp.get('/api/users', (req, res) => {\n  const version = req.headers['api-version'] || '1';\n\n  if (version === '2') {\n    return getUsersV2(req, res);\n  }\n\n  return getUsersV1(req, res);\n});\n\n// Request:\n// GET /api/users\n// API-Version: 2\n\n// ✅ Pros: Clean URLs, selective versioning\n// ❌ Cons: Harder to test/cache, not visible in browser\n```\n\n### Accept Header Versioning (Content Negotiation)\n\n```typescript\napp.get('/api/users', (req, res) => {\n  const acceptHeader = req.headers['accept'];\n\n  if (acceptHeader?.includes('application/vnd.myapp.v2+json')) {\n    return getUsersV2(req, res);\n  }\n\n  return getUsersV1(req, res);\n});\n\n// Request:\n// GET /api/users\n// Accept: application/vnd.myapp.v2+json\n\n// ✅ Pros: RESTful, follows HTTP standards\n// ❌ Cons: Complex, harder to debug\n```\n\n### Query Parameter Versioning\n\n```typescript\napp.get('/api/users', (req, res) => {\n  const version = req.query.version || '1';\n\n  if (version === '2') {\n    return getUsersV2(req, res);\n  }\n\n  return getUsersV1(req, res);\n});\n\n// Request: GET /api/users?version=2\n\n// ✅ Pros: Easy to test, visible\n// ❌ Cons: URL pollution, not RESTful\n```\n\n### Recommended: URL Path Versioning\n\n```typescript\n// Clear structure with version namespacing\nconst v1Router = express.Router();\nconst v2Router = express.Router();\n\n// V1 endpoints\nv1Router.get('/users', async (req, res) => {\n  const users = await db.getUsers();\n  res.json(users.map(u => ({\n    id: u.id,\n    name: u.name,\n    email: u.email\n  })));\n});\n\n// V2 endpoints (expanded response)\nv2Router.get('/users', async (req, res) => {\n  const users = await db.getUsers();\n  res.json(users.map(u => ({\n    id: u.id,\n    fullName: u.name,  // Renamed field\n    email: u.email,\n    profile: {         // Nested structure\n      avatar: u.avatar_url,\n      bio: u.bio\n    },\n    createdAt: u.created_at\n  })));\n});\n\napp.use('/api/v1', v1Router);\napp.use('/api/v2', v2Router);\n```\n\n## Backward Compatibility\n\n### Additive Changes (Safe)\n\n```typescript\n// ✅ Adding optional fields\ninterface UserV1 {\n  id: string;\n  name: string;\n  email: string;\n}\n\ninterface UserV2 extends UserV1 {\n  avatar?: string;     // Optional - backward compatible\n  createdAt?: Date;    // Optional - backward compatible\n}\n\n// ✅ Adding new endpoints\napp.get('/api/v1/users/:id/preferences', getPreferences);  // New, doesn't break existing\n\n// ✅ Adding optional query parameters\napp.get('/api/v1/users', (req, res) => {\n  const { role } = req.query;  // Optional filter, defaults work without it\n  // ...\n});\n```\n\n### Breaking Changes (Require New Version)\n\n```typescript\n// ❌ Removing fields\ninterface UserV1 {\n  id: string;\n  name: string;\n  email: string;\n  phone: string;  // Removed in V2 - BREAKING\n}\n\n// ❌ Changing field types\ninterface UserV1 {\n  createdAt: string;  // ISO string\n}\n\ninterface UserV2 {\n  createdAt: number;  // Unix timestamp - BREAKING\n}\n\n// ❌ Renaming fields\ninterface UserV1 {\n  name: string;\n}\n\ninterface UserV2 {\n  fullName: string;  // Renamed - BREAKING\n}\n\n// ❌ Changing required vs optional\ninterface UserV1 {\n  avatar?: string;  // Optional\n}\n\ninterface UserV2 {\n  avatar: string;  // Now required - BREAKING\n}\n```\n\n### Deprecation Strategy\n\n```typescript\n// 1. Announce deprecation\napp.get('/api/v1/users', (req, res) => {\n  res.setHeader('X-API-Warn', 'Deprecated: Use /api/v2/users instead. V1 will be removed on 2025-12-31');\n  res.setHeader('Sunset', 'Sat, 31 Dec 2025 23:59:59 GMT');  // RFC 8594\n\n  // Return V1 response\n});\n\n// 2. Provide migration path\n// Documentation:\n// V1 → V2 Migration Guide:\n// - `name` field renamed to `fullName`\n// - `createdAt` changed from string to Unix timestamp\n// - New optional `profile` object added\n\n// 3. Maintain for grace period (6-12 months)\n\n// 4. Remove deprecated version\n// Delete V1 routes, return 410 Gone\napp.all('/api/v1/*', (req, res) => {\n  res.status(410).json({\n    error: 'API version 1 has been retired. Please use /api/v2'\n  });\n});\n```\n\n## Evolutionary API Design\n\n### Expand-Contract Pattern\n\n```typescript\n// Phase 1: Expand (support both old and new)\ninterface User {\n  name: string;         // Old field\n  fullName?: string;    // New field\n}\n\napp.get('/api/v1/users/:id', async (req, res) => {\n  const user = await db.getUser(req.params.id);\n\n  res.json({\n    id: user.id,\n    name: user.full_name,          // Old field (still populated)\n    fullName: user.full_name,       // New field (also populated)\n    email: user.email\n  });\n});\n\n// Phase 2: Migrate clients to new field\n\n// Phase 3: Contract (remove old field in next version)\napp.get('/api/v2/users/:id', async (req, res) => {\n  const user = await db.getUser(req.params.id);\n\n  res.json({\n    id: user.id,\n    fullName: user.full_name,  // Only new field\n    email: user.email\n  });\n});\n```\n\n### Parallel Run\n\n```typescript\n// Run old and new implementations side-by-side\nconst getUsersV1 = async (req, res) => {\n  const users = await db.query('SELECT id, name FROM users');\n  res.json(users);\n};\n\nconst getUsersV2 = async (req, res) => {\n  const users = await db.query(`\n    SELECT id, name, email, created_at\n    FROM users\n    JOIN user_profiles ON users.id = user_profiles.user_id\n  `);\n  res.json(users);\n};\n\napp.get('/api/v1/users', getUsersV1);\napp.get('/api/v2/users', getUsersV2);\n\n// Both versions available during transition\n```\n\n## GraphQL Versioning\n\n### Schema Evolution (No Versioning Needed)\n\n```graphql\n# Original schema\ntype User {\n  id: ID!\n  name: String!\n  email: String!\n}\n\n# Evolved schema (backward compatible)\ntype User {\n  id: ID!\n  name: String!  @deprecated(reason: \"Use fullName instead\")\n  fullName: String!\n  email: String!\n  avatar: String  # New optional field\n  profile: UserProfile  # New optional nested type\n}\n\ntype UserProfile {\n  bio: String\n  website: String\n}\n```\n\n```typescript\n// Resolvers handle both old and new fields\nconst resolvers = {\n  User: {\n    name: (user) => user.full_name,      // Legacy support\n    fullName: (user) => user.full_name,  // New field\n    avatar: (user) => user.avatar_url,\n    profile: (user) => ({\n      bio: user.bio,\n      website: user.website\n    })\n  }\n};\n\n// Clients request only what they need\nquery {\n  user(id: \"123\") {\n    fullName  # New clients use fullName\n    email\n    profile {\n      bio\n    }\n  }\n}\n```\n\n## API Documentation\n\n### OpenAPI/Swagger\n\n```yaml\nopenapi: 3.0.0\ninfo:\n  title: User API\n  version: 2.0.0\n  description: User management API\n\nservers:\n  - url: https://api.example.com/v2\n    description: Production API v2\n\npaths:\n  /users:\n    get:\n      summary: List users\n      parameters:\n        - in: query\n          name: role\n          schema:\n            type: string\n            enum: [admin, user, guest]\n          description: Filter by user role\n        - in: query\n          name: limit\n          schema:\n            type: integer\n            default: 20\n            minimum: 1\n            maximum: 100\n      responses:\n        '200':\n          description: Successful response\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  users:\n                    type: array\n                    items:\n                      $ref: '#/components/schemas/User'\n                  pagination:\n                    $ref: '#/components/schemas/Pagination'\n\ncomponents:\n  schemas:\n    User:\n      type: object\n      required:\n        - id\n        - fullName\n        - email\n      properties:\n        id:\n          type: string\n          format: uuid\n        fullName:\n          type: string\n        email:\n          type: string\n          format: email\n        avatar:\n          type: string\n          format: uri\n          nullable: true\n        createdAt:\n          type: string\n          format: date-time\n```\n\n## Hypermedia (HATEOAS)\n\n### Self-Describing APIs\n\n```typescript\n// Include links to related resources\napp.get('/api/v1/users/:id', async (req, res) => {\n  const user = await db.getUser(req.params.id);\n\n  res.json({\n    id: user.id,\n    name: user.name,\n    email: user.email,\n    _links: {\n      self: { href: `/api/v1/users/${user.id}` },\n      orders: { href: `/api/v1/users/${user.id}/orders` },\n      preferences: { href: `/api/v1/users/${user.id}/preferences` },\n      avatar: { href: user.avatar_url }\n    }\n  });\n});\n\n// HAL format example\n{\n  \"id\": \"123\",\n  \"name\": \"John Doe\",\n  \"email\": \"john@example.com\",\n  \"_links\": {\n    \"self\": { \"href\": \"/api/v1/users/123\" },\n    \"orders\": { \"href\": \"/api/v1/users/123/orders\" }\n  },\n  \"_embedded\": {\n    \"recentOrders\": [\n      {\n        \"id\": \"order-1\",\n        \"total\": 99.99,\n        \"_links\": {\n          \"self\": { \"href\": \"/api/v1/orders/order-1\" }\n        }\n      }\n    ]\n  }\n}\n```\n\n## Rate Limiting\n\n### Token Bucket Algorithm\n\n```typescript\nclass RateLimiter {\n  private tokens = new Map<string, { count: number; resetAt: number }>();\n\n  constructor(\n    private limit: number = 100,\n    private windowMs: number = 60000\n  ) {}\n\n  async checkLimit(key: string): Promise<{ allowed: boolean; remaining: number }> {\n    const now = Date.now();\n    const bucket = this.tokens.get(key);\n\n    if (!bucket || now > bucket.resetAt) {\n      this.tokens.set(key, {\n        count: this.limit - 1,\n        resetAt: now + this.windowMs\n      });\n      return { allowed: true, remaining: this.limit - 1 };\n    }\n\n    if (bucket.count > 0) {\n      bucket.count--;\n      return { allowed: true, remaining: bucket.count };\n    }\n\n    return { allowed: false, remaining: 0 };\n  }\n}\n\n// Middleware\nconst rateLimiter = new RateLimiter(100, 60000); // 100 req/min\n\napp.use(async (req, res, next) => {\n  const key = req.ip || 'anonymous';\n  const { allowed, remaining } = await rateLimiter.checkLimit(key);\n\n  res.setHeader('X-RateLimit-Limit', '100');\n  res.setHeader('X-RateLimit-Remaining', remaining.toString());\n  res.setHeader('X-RateLimit-Reset', Date.now() + 60000);\n\n  if (!allowed) {\n    return res.status(429).json({\n      error: 'Too many requests',\n      retryAfter: 60\n    });\n  }\n\n  next();\n});\n```\n\n## Error Responses\n\n### Consistent Error Format\n\n```typescript\ninterface APIError {\n  error: {\n    code: string;\n    message: string;\n    details?: unknown;\n    timestamp: string;\n    path: string;\n    requestId?: string;\n  };\n}\n\napp.use((err, req, res, next) => {\n  const statusCode = err.statusCode || 500;\n\n  res.status(statusCode).json({\n    error: {\n      code: err.code || 'INTERNAL_ERROR',\n      message: err.message,\n      details: err.details,\n      timestamp: new Date().toISOString(),\n      path: req.path,\n      requestId: req.id\n    }\n  });\n});\n\n// Usage\nthrow {\n  statusCode: 400,\n  code: 'VALIDATION_ERROR',\n  message: 'Invalid user input',\n  details: {\n    fields: {\n      email: 'Invalid email format',\n      age: 'Must be between 0 and 150'\n    }\n  }\n};\n```\n\n### HTTP Status Codes\n\n```typescript\n// 2xx Success\nres.status(200).json(data);          // OK\nres.status(201).json(created);       // Created\nres.status(204).send();              // No Content\n\n// 3xx Redirection\nres.status(301).redirect(newUrl);    // Moved Permanently\nres.status(304).send();              // Not Modified\n\n// 4xx Client Errors\nres.status(400).json({ error });     // Bad Request\nres.status(401).json({ error });     // Unauthorized\nres.status(403).json({ error });     // Forbidden\nres.status(404).json({ error });     // Not Found\nres.status(409).json({ error });     // Conflict\nres.status(422).json({ error });     // Unprocessable Entity\nres.status(429).json({ error });     // Too Many Requests\n\n// 5xx Server Errors\nres.status(500).json({ error });     // Internal Server Error\nres.status(502).json({ error });     // Bad Gateway\nres.status(503).json({ error });     // Service Unavailable\n```\n\n## API Pagination\n\n### Cursor-Based Pagination\n\n```typescript\napp.get('/api/v1/users', async (req, res) => {\n  const { cursor, limit = 20 } = req.query;\n\n  const users = await db.query(`\n    SELECT * FROM users\n    WHERE ${cursor ? 'id > ?' : 'TRUE'}\n    ORDER BY id\n    LIMIT ?\n  `, cursor ? [cursor, limit] : [limit]);\n\n  const nextCursor = users.length === limit ? users[users.length - 1].id : null;\n\n  res.json({\n    data: users,\n    pagination: {\n      cursor: nextCursor,\n      hasMore: nextCursor !== null\n    },\n    _links: {\n      self: { href: `/api/v1/users?limit=${limit}${cursor ? `&cursor=${cursor}` : ''}` },\n      next: nextCursor ? { href: `/api/v1/users?limit=${limit}&cursor=${nextCursor}` } : null\n    }\n  });\n});\n```\n\n## API Security\n\n### API Keys\n\n```typescript\nconst validateAPIKey = async (req, res, next) => {\n  const apiKey = req.headers['x-api-key'];\n\n  if (!apiKey) {\n    return res.status(401).json({ error: 'API key required' });\n  }\n\n  const client = await db.findClientByAPIKey(apiKey);\n\n  if (!client) {\n    return res.status(401).json({ error: 'Invalid API key' });\n  }\n\n  if (!client.is_active) {\n    return res.status(403).json({ error: 'API key deactivated' });\n  }\n\n  req.client = client;\n  next();\n};\n\napp.use('/api/v1', validateAPIKey);\n```\n\n### OAuth 2.0\n\n```typescript\nimport passport from 'passport';\nimport { Strategy as OAuth2Strategy } from 'passport-oauth2';\n\npassport.use(new OAuth2Strategy({\n  authorizationURL: 'https://provider.com/oauth/authorize',\n  tokenURL: 'https://provider.com/oauth/token',\n  clientID: process.env.OAUTH_CLIENT_ID,\n  clientSecret: process.env.OAUTH_CLIENT_SECRET,\n  callbackURL: 'https://myapp.com/auth/callback'\n}, (accessToken, refreshToken, profile, done) => {\n  // Verify and create/update user\n  return done(null, profile);\n}));\n\napp.get('/auth/oauth',\n  passport.authenticate('oauth2'));\n\napp.get('/auth/callback',\n  passport.authenticate('oauth2', { failureRedirect: '/login' }),\n  (req, res) => {\n    res.redirect('/dashboard');\n  });\n```\n\n## Anti-Patterns\n\n### ❌ Breaking Changes Without Version Bump\n\n```typescript\n// ❌ Changing response format in same version\n// V1 before:\n{ \"name\": \"John\" }\n\n// V1 after (BREAKING):\n{ \"fullName\": \"John\" }  // Breaks existing clients\n\n// ✅ Create new version instead\n// V1: { \"name\": \"John\" }\n// V2: { \"fullName\": \"John\" }\n```\n\n### ❌ Over-Versioning\n\n```typescript\n// ❌ Too many versions\n/api/v1/users\n/api/v2/users\n/api/v3/users\n/api/v4/users  // Maintenance nightmare\n\n// ✅ Consolidate and deprecate\n/api/v2/users  (supports most features)\n/api/v3/users  (latest)\n```\n\n### ❌ Leaking Implementation Details\n\n```typescript\n// ❌ Database structure exposed\nGET /api/users_table?user_id=123\n\n// ✅ Resource-oriented\nGET /api/users/123\n```\n\n## References\n\n- [REST API Design](https://martinfowler.com/articles/richardsonMaturityModel.html)\n- [API Versioning](https://www.troyhunt.com/your-api-versioning-is-wrong-which-is/)\n- [GraphQL Best Practices](https://graphql.org/learn/best-practices/)\n- [OpenAPI Specification](https://swagger.io/specification/)\n",
    "original/development-practices/clean-code-style-guide.md": "# Clean Code & Style Guide\n\n## Code as Documentation\n\n### Self-Explanatory Code\n\n```\n❌ Redundant comments (stating the obvious)\n// Increment counter by 1\ncounter++\n\n// Create new user object\nuser = new User()\n\n// Loop through all items\nfor item in items:\n    // Process each item\n    process(item)\n\n✅ Code explains itself\nactiveUsers = users.filter(u => u.isActive)\ntotalRevenue = orders.sum(order => order.total)\n```\n\n### When to Comment (WHY, not WHAT)\n\n```\n❌ Comments describing WHAT the code does\n// Get the user from the database\nuser = database.findUser(userId)\n\n// Check if user is admin\nif user.role == 'admin':\n    // Allow access\n    return true\n\n✅ Comments explaining WHY (business logic, edge cases)\n// Skip validation for legacy users migrated before 2020\n// These users have inconsistent data formats that would fail validation\nif user.createdAt < Date('2020-01-01'):\n    return processLegacyUser(user)\n\n// Use exponential backoff to avoid overwhelming the payment gateway\n// after it returns 429 rate limit errors\nretryWithBackoff(chargePayment, maxAttempts=3, baseDelay=1000)\n\n// Temporary workaround for bug in third-party library v2.3.1\n// TODO: Remove when upgrading to v2.4.0 (fixes issue #1234)\nsanitizedData = data.replace('\\u0000', '')\n```\n\n### Comment Types That Add Value\n\n```\n1. Complex algorithms or business logic\n/**\n * Calculates shipping cost using zone-based pricing with volume discounts.\n *\n * Zone 1 (local):     $5 base + $0.50/lb\n * Zone 2 (regional):  $10 base + $1.00/lb\n * Zone 3 (national):  $15 base + $1.50/lb\n *\n * Volume discounts applied for orders over 20 lbs:\n * - 10% discount for 20-50 lbs\n * - 15% discount for 50+ lbs\n */\nfunction calculateShippingCost(weight, zone):\n    // Implementation\n\n2. Non-obvious constraints or requirements\n// Phone numbers must be stored in E.164 format to ensure\n// compatibility with our SMS provider's API\nphoneRegex = /^\\+[1-9]\\d{1,14}$/\n\n3. Performance considerations\n// Using HashMap instead of linear search for O(1) lookups\n// This dataset can contain 100,000+ items\nuserMap = new HashMap(users.map(u => [u.id, u]))\n\n4. Security considerations\n// Sanitize HTML to prevent XSS attacks\n// Even though input is validated, defense in depth requires output encoding\nsanitized = sanitizeHTML(userInput)\n\n5. Deprecation warnings\n/**\n * @deprecated Use createUserV2() instead. Will be removed in v3.0.0\n * Reason: Does not support new authentication flow\n */\nfunction createUser(data):\n    // Legacy implementation\n```\n\n### Avoid Commented-Out Code\n\n```\n❌ Dead code in comments\nfunction processOrder(order):\n    # tax = calculateTax(order)\n    # shipping = calculateShipping(order)\n    # return order.total + tax + shipping\n\n    return order.total  # Which calculation is correct?\n\n✅ Remove dead code, use version control\nfunction processOrder(order):\n    return order.total\n\n# If you need to reference old implementation:\n# See commit abc123 for previous tax calculation approach\n```\n\n## Naming Conventions\n\n### Variables and Functions\n\n```\nUse descriptive names in your language's convention:\n- camelCase (JavaScript, Java, C#)\n- snake_case (Python, Ruby, Rust)\n- PascalCase for types/classes\n\n❌ Bad names\nd = Date.now()           # What is 'd'?\ntmp = user.name          # Temporary what?\ndata = fetchData()       # What data?\nflag = true              # What flag?\n\n✅ Descriptive names\ncurrentDate = Date.now()\noriginalUserName = user.name\ncustomerOrders = fetchCustomerOrders()\nisEmailVerified = true\n\nBoolean variables: use is/has/can/should prefix\nisValid = validate(input)\nhasPermission = checkPermission(user, resource)\ncanEdit = user.role == 'admin'\nshouldRetry = error.code == 'TIMEOUT'\n\nCollections: use plural names\nusers = getUsers()\nactiveOrders = orders.filter(o => o.status == 'active')\n```\n\n### Constants\n\n```\nUse UPPER_SNAKE_CASE for constants (most languages)\n\nMAX_RETRY_ATTEMPTS = 3\nDEFAULT_TIMEOUT_MS = 5000\nAPI_BASE_URL = 'https://api.example.com'\n\nEnum-like constants (structure depends on language)\nORDER_STATUS = {\n    PENDING: 'pending',\n    PROCESSING: 'processing',\n    SHIPPED: 'shipped',\n    DELIVERED: 'delivered',\n    CANCELLED: 'cancelled'\n}\n\nHTTP_STATUS = {\n    OK: 200,\n    CREATED: 201,\n    BAD_REQUEST: 400,\n    UNAUTHORIZED: 401,\n    NOT_FOUND: 404,\n    INTERNAL_ERROR: 500\n}\n```\n\n### Classes and Types\n\n```\nUse PascalCase for classes and types (most languages)\n\nclass UserService:\n    def __init__(self, userRepository):\n        self.userRepository = userRepository\n\nclass User:\n    id: String\n    name: String\n    email: String\n\nAvoid unnecessary prefixes\n❌ IUser, CUser, TUser\n✅ User\n```\n\n### Files and Modules\n\n```\nMatch your language's convention:\n- kebab-case: user-service.js, order-repository.py\n- snake_case: user_service.py, order_repository.rb\n- PascalCase: UserService.cs, OrderRepository.java\n\nMatch file name to primary export:\nuser_service.py exports UserService class\norder_repository.rb exports OrderRepository class\n```\n\n## Code Structure\n\n### Function Length\n\n```\n❌ Function too long (>50 lines)\nfunction processOrder(orderId):\n    # 200 lines of code doing validation, payment, inventory, shipping...\n\n✅ Extract into smaller, focused functions\nfunction processOrder(orderId):\n    order = fetchOrder(orderId)\n\n    validateOrder(order)\n    reserveInventory(order.items)\n    processPayment(order)\n    scheduleShipping(order)\n    sendConfirmation(order.customer.email)\n\n    return order\n\nKeep functions under 50 lines\nIf longer, extract logic into helper functions\n```\n\n### Nesting Depth\n\n```\n❌ Too much nesting (>3 levels)\nif user:\n    if user.isActive:\n        if user.hasPermission('edit'):\n            if resource.isAvailable:\n                # Deep nesting is hard to follow\n\n✅ Guard clauses to reduce nesting\nif not user:\n    return\nif not user.isActive:\n    return\nif not user.hasPermission('edit'):\n    return\nif not resource.isAvailable:\n    return\n\n# Clear logic flow at top level\n\n✅ Extract complex conditions\nfunction canEditResource(user, resource):\n    return user and \\\n           user.isActive and \\\n           user.hasPermission('edit') and \\\n           resource.isAvailable\n\nif canEditResource(user, resource):\n    # Single level of nesting\n```\n\n### File Length\n\n```\n❌ God file (1000+ lines)\n# user_service.py\nclass UserService:\n    # 50 methods handling users, auth, permissions, notifications...\n\n✅ Split into focused modules\n# user_service.py (~200 lines)\nclass UserService:\n    def createUser(self):\n        pass\n    def updateUser(self):\n        pass\n    def deleteUser(self):\n        pass\n\n# auth_service.py (~150 lines)\nclass AuthService:\n    def login(self):\n        pass\n    def logout(self):\n        pass\n\n# permission_service.py (~100 lines)\nclass PermissionService:\n    def checkPermission(self):\n        pass\n\nKeep files under 300 lines\nOne class per file (except closely related types)\n```\n\n### File Organization\n\n```\nConsistent structure within files:\n\n1. Imports/includes (grouped and ordered)\n   - Standard library\n   - External dependencies\n   - Internal modules\n\n2. Constants and type definitions\n\n3. Helper functions (if needed)\n\n4. Main exports/classes\n\n5. Module initialization (if applicable)\n```\n\n## Logging Best Practices\n\n### Structured Logging\n\n```\n✅ Include relevant context\nlog.info(\"User login successful\", {\n    userId: user.id,\n    email: user.email,\n    ipAddress: request.ip,\n    userAgent: request.userAgent,\n    timestamp: currentTime()\n})\n\nlog.error(\"Payment processing failed\", {\n    orderId: order.id,\n    userId: order.userId,\n    amount: order.total,\n    error: error.message,\n    stackTrace: error.stack,\n    paymentGateway: 'stripe'\n})\n\n❌ Unstructured logging\nprint(\"User logged in\")              # No context\nprint(\"Error: \" + error.toString())  # Limited info\n```\n\n### Log Levels\n\n```\nUse appropriate log levels:\n\nERROR: Application errors requiring attention\nlog.error(\"Database connection failed\", {\n    error: error.message,\n    host: dbConfig.host,\n    retryCount: 3\n})\n\nWARN: Potentially harmful situations\nlog.warn(\"API rate limit approaching\", {\n    currentRate: 950,\n    limit: 1000,\n    userId: user.id\n})\n\nINFO: Important business events\nlog.info(\"Order placed\", {\n    orderId: order.id,\n    userId: user.id,\n    total: order.total\n})\n\nDEBUG: Detailed diagnostic information (development only)\nlog.debug(\"Cache hit\", {\n    key: cacheKey,\n    ttl: 3600\n})\n\n❌ Don't use print/console in production\nprint(\"User created\")  # Use proper logger instead\n```\n\n### What to Log\n\n```\n✅ Log these events\nlog.info(\"User authentication\", {userId: id, method: 'oauth'})\nlog.info(\"Payment processed\", {orderId: id, amount: amt})\nlog.info(\"File uploaded\", {userId: id, filename: name, size: bytes})\nlog.error(\"External API call failed\", {service: svc, error: err})\n\n❌ Don't log sensitive data\nlog.info(\"User login\", {\n    email: user.email,\n    password: user.password  # NEVER log passwords!\n})\n\nlog.debug(\"API request\", {\n    headers: request.headers  # May contain auth tokens\n})\n\nlog.info(\"Payment details\", {\n    cardNumber: card.number  # NEVER log PII/PCI data\n})\n\n✅ Redact sensitive data\nlog.info(\"User login attempt\", {\n    email: user.email,\n    password: '[REDACTED]'\n})\n\nlog.info(\"Payment processed\", {\n    cardLast4: card.last4,  # Only last 4 digits\n    amount: payment.amount\n})\n```\n\n### Log Performance Impact\n\n```\n❌ Expensive operations in logs\nlog.debug(\"Processing items\", {\n    items: items.map(i => ({...i, details: getDetails(i)}))  # N database calls!\n})\n\n✅ Log only necessary data\nlog.debug(\"Processing items\", {\n    itemCount: items.length,\n    itemIds: items.map(i => i.id).take(10)  # Sample only\n})\n\n✅ Use log levels to control verbosity\nif logger.isDebugEnabled():\n    # Only compute expensive logs when needed\n    debugInfo = computeExpensiveDebugInfo()\n    log.debug(\"Detailed info\", debugInfo)\n```\n\n## Code Organization Patterns\n\n### Single Responsibility\n\n```\n❌ Class doing too much\nclass UserManager:\n    def createUser(self):\n        pass\n    def updateUser(self):\n        pass\n    def sendEmail(self):\n        pass\n    def hashPassword(self):\n        pass\n    def generateToken(self):\n        pass\n\n✅ Split by responsibility\nclass UserRepository:\n    def create(self, user):\n        pass\n    def update(self, id, data):\n        pass\n    def delete(self, id):\n        pass\n\nclass EmailService:\n    def send(self, to, template, data):\n        pass\n\nclass PasswordService:\n    def hash(self, password):\n        pass\n    def verify(self, password, hash):\n        pass\n\nclass AuthService:\n    def generateToken(self, userId):\n        pass\n    def validateToken(self, token):\n        pass\n```\n\n### DRY (Don't Repeat Yourself)\n\n```\n❌ Duplicated logic\nfunction processUserOrder(order):\n    total = sum(item.price * item.quantity for item in order.items)\n    tax = total * 0.08\n    return total + tax\n\nfunction processGuestOrder(order):\n    total = sum(item.price * item.quantity for item in order.items)\n    tax = total * 0.08\n    return total + tax\n\n✅ Extract common logic\nfunction calculateOrderTotal(items):\n    subtotal = sum(item.price * item.quantity for item in items)\n    tax = subtotal * 0.08\n    return subtotal + tax\n\nfunction processUserOrder(order):\n    return calculateOrderTotal(order.items)\n\nfunction processGuestOrder(order):\n    return calculateOrderTotal(order.items)\n```\n\n### Avoid Premature Abstraction\n\n```\n❌ Over-engineered for simple case\nabstract class AbstractUserFactory:\n    abstract method createUser(type)\n\nclass ConcreteUserFactory extends AbstractUserFactory:\n    method createUser(type):\n        if type == 'regular':\n            return new RegularUser()\n        if type == 'admin':\n            return new AdminUser()\n\n✅ Simple is better when you only have 2 types\nfunction createUser(type, data):\n    if type == 'admin':\n        return new AdminUser(data)\n    return new RegularUser(data)\n\n# Add abstraction when you have 5+ types and complexity justifies it\n```\n\n## Code Quality Rules\n\n### Avoid Magic Numbers\n\n```\n❌ Magic numbers\nif user.age >= 18:\n    pass\nif len(items) > 100:\n    pass\nsetTimeout(callback, 5000)\n\n✅ Named constants\nLEGAL_AGE = 18\nMAX_BATCH_SIZE = 100\nDEFAULT_TIMEOUT_MS = 5000\n\nif user.age >= LEGAL_AGE:\n    pass\nif len(items) > MAX_BATCH_SIZE:\n    pass\nsetTimeout(callback, DEFAULT_TIMEOUT_MS)\n```\n\n### Positive Conditionals\n\n```\n❌ Double negatives are hard to read\nif not user.isNotActive:\n    # What does this mean?\n\n✅ Positive conditions\nif user.isActive:\n    # Clear\n\n❌ Negative variable names\nisNotValid = not validate(input)\nif isNotValid:\n    pass\n\n✅ Positive variable names\nisValid = validate(input)\nif not isValid:\n    pass\n```\n\n### Explicit Over Implicit\n\n```\n❌ Implicit checks\nif user:         # What if user is empty object?\n    pass\nif count:        # 0 is falsy but might be valid\n    pass\n\n✅ Explicit checks\nif user is not None:\n    pass\nif count > 0:\n    pass\n\n❌ Implicit returns\nfunction getUser(id):\n    user = db.find(id)\n    # Returns None/null if not found (implicit)\n\n✅ Explicit returns\nfunction getUser(id):\n    user = db.find(id)\n    return user if user else None  # Explicit null return\n```\n\n## General Guidelines\n\n### Type Safety (if language supports)\n\n```\n✅ Use type annotations where available\nfunction calculateTotal(items: List[Item]) -> float:\n    return sum(item.price for item in items)\n\n✅ Avoid dynamic/any types when possible\n❌ data: any\n✅ data: UserResponse\n\n✅ Use generics for reusable code\nclass Repository<T>:\n    def find(id: string) -> T:\n        pass\n```\n\n### Error Handling\n\n```\n✅ Handle errors explicitly\ntry:\n    result = dangerousOperation()\nexcept SpecificError as e:\n    logger.error(\"Operation failed\", {error: e})\n    raise CustomError(\"Failed to process\", cause=e)\n\n❌ Silent failures\ntry:\n    dangerousOperation()\nexcept:\n    pass  # Error swallowed - dangerous!\n\n❌ Generic errors\nraise Exception(\"Something went wrong\")\n\n✅ Specific errors\nraise ValidationError(\"Email must be valid\", field='email')\n```\n\n### Immutability When Possible\n\n```\n✅ Prefer immutable data\nCONST MAX_SIZE = 100        # Cannot be changed\nuser = {name: \"John\"}       # Create new object instead of mutating\n\n❌ Mutating shared state\nglobal_counter += 1         # Race conditions\nuser.name = \"Jane\"          # Side effects\n\n✅ Return new values\nfunction updateUser(user, newName):\n    return {...user, name: newName}  # New object\n```\n\n## Code Formatting\n\n### Automate Formatting\n\nUse language-specific formatters:\n- **Python**: Black, autopep8\n- **JavaScript/TypeScript**: Prettier, ESLint\n- **Java**: Google Java Format\n- **Go**: gofmt (built-in)\n- **Rust**: rustfmt (built-in)\n- **C#**: dotnet format\n- **Ruby**: RuboCop\n\n```\nDon't debate formatting in code reviews\nConfigure formatter, commit config to repo\nRun automatically on save/commit\nFocus reviews on logic, not style\n```\n\n### Consistent Indentation\n\n```\nUse your language's convention:\n- 2 spaces: JavaScript, Ruby, YAML\n- 4 spaces: Python, Java, C#\n- Tabs: Go, Makefiles\n\nConfigure editor to match team standard\nNever mix tabs and spaces\n```\n\n### Line Length\n\n```\nKeep lines under 80-120 characters\nBreak long lines at logical points\n\n❌ Too long\nresult = calculateTotal(order.items) + calculateTax(order.items, order.location) + calculateShipping(order.items, order.destination)\n\n✅ Logical breaks\nresult = (\n    calculateTotal(order.items) +\n    calculateTax(order.items, order.location) +\n    calculateShipping(order.items, order.destination)\n)\n```\n\n## Summary\n\n**Core Principles:**\n1. Code is read 10x more than written - optimize for readability\n2. Comment WHY, not WHAT - code explains what\n3. No redundant comments - self-documenting code\n4. Functions < 50 lines, files < 300 lines\n5. Nesting depth ≤ 3 levels\n6. Descriptive names over comments\n7. Extract, don't duplicate (DRY)\n8. Simple solutions over clever ones\n9. Explicit over implicit\n10. Automate formatting - don't debate style\n\n**Logging:**\n- Use structured logging with context\n- Appropriate log levels (ERROR, WARN, INFO, DEBUG)\n- Never log passwords, tokens, or sensitive data\n- Log business events, not debug statements in production\n\n**Quality:**\n- One responsibility per class/module\n- No magic numbers - use named constants\n- Positive conditionals over double negatives\n- Type safety when language supports it\n- Explicit error handling - no silent failures\n\n## References\n\n- [Clean Code by Robert C. Martin](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882)\n- [Code Complete by Steve McConnell](https://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670)\n- [The Art of Readable Code](https://www.amazon.com/Art-Readable-Code-Practical-Techniques/dp/0596802293)\n- [The Pragmatic Programmer](https://pragprog.com/titles/tpp20/the-pragmatic-programmer-20th-anniversary-edition/)\n",
    "original/development-practices/code-review-practices.md": "# Code Review Best Practices\n\n## Code Review Goals\n\n1. **Catch bugs early** before they reach production\n2. **Knowledge sharing** across the team\n3. **Maintain code quality** and consistency\n4. **Onboard new team members** through review process\n5. **Foster collaboration** and team cohesion\n\n## What to Review\n\n### Correctness\n\n```typescript\n// Check for logic errors\n// ❌ Off-by-one error\nfor (let i = 0; i <= items.length; i++) {  // Should be <, not <=\n  process(items[i]);\n}\n\n// ❌ Incorrect condition\nif (user.age >= 18 || user.hasParentalConsent) {  // Should be &&, not ||\n  allowPurchase();\n}\n\n// ❌ Missing null check\nconst userName = user.profile.name;  // Crash if profile is null\n```\n\n### Security Vulnerabilities\n\n```typescript\n// ❌ SQL injection\nconst query = `SELECT * FROM users WHERE email = '${email}'`;\n\n// ❌ XSS vulnerability\nelement.innerHTML = userInput;\n\n// ❌ Hardcoded secrets\nconst apiKey = 'sk-1234567890abcdef';\n\n// ❌ Missing authentication\napp.delete('/api/users/:id', async (req, res) => {\n  await db.deleteUser(req.params.id);  // No auth check!\n});\n```\n\n### Performance Issues\n\n```typescript\n// ❌ N+1 queries\nfor (const user of users) {\n  user.orders = await db.getOrders(user.id);  // N queries\n}\n\n// ❌ Inefficient algorithm\nconst hasDuplicate = (arr) => {\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = i + 1; j < arr.length; j++) {  // O(n²)\n      if (arr[i] === arr[j]) return true;\n    }\n  }\n  return false;\n};\n\n// ❌ Memory leak\nclass Component {\n  constructor() {\n    window.addEventListener('scroll', this.handleScroll);\n    // Never removed!\n  }\n}\n```\n\n### Code Clarity\n\n```typescript\n// ❌ Unclear variable names\nconst d = new Date();\nconst x = users.filter(u => u.a > 18);\n\n// ✅ Clear names\nconst currentDate = new Date();\nconst adultUsers = users.filter(user => user.age > 18);\n\n// ❌ Magic numbers\nif (status === 2) {  // What is 2?\n  // ...\n}\n\n// ✅ Named constants\nconst OrderStatus = {\n  PENDING: 1,\n  PROCESSING: 2,\n  SHIPPED: 3\n};\n\nif (status === OrderStatus.PROCESSING) {\n  // Clear intent\n}\n```\n\n### Error Handling\n\n```typescript\n// ❌ Silent failures\ntry {\n  await sendEmail(user.email);\n} catch (error) {\n  // Error swallowed\n}\n\n// ❌ Generic error messages\nthrow new Error('Something went wrong');\n\n// ✅ Proper error handling\ntry {\n  await sendEmail(user.email);\n} catch (error) {\n  logger.error('Email send failed', {\n    userId: user.id,\n    email: user.email,\n    error: error.message\n  });\n\n  throw new EmailDeliveryError(\n    `Failed to send email to ${user.email}`,\n    { userId: user.id, cause: error }\n  );\n}\n```\n\n### Testing\n\n```typescript\n// Check test coverage\n// ❌ Missing edge cases\nit('should calculate discount', () => {\n  expect(calculateDiscount(100)).toBe(10);\n  // Missing: negative numbers, zero, very large numbers\n});\n\n// ❌ Testing implementation details\nit('should call helper method', () => {\n  const spy = jest.spyOn(service, 'helperMethod');\n  service.doSomething();\n  expect(spy).toHaveBeenCalled();  // Brittle\n});\n\n// ✅ Comprehensive tests\ndescribe('calculateDiscount', () => {\n  it('should return 10% for orders over $100', () => {\n    expect(calculateDiscount(150)).toBe(15);\n  });\n\n  it('should return 0 for orders under $100', () => {\n    expect(calculateDiscount(50)).toBe(0);\n  });\n\n  it('should handle edge case at exactly $100', () => {\n    expect(calculateDiscount(100)).toBe(0);\n  });\n\n  it('should throw for negative amounts', () => {\n    expect(() => calculateDiscount(-10)).toThrow();\n  });\n});\n```\n\n## How to Give Feedback\n\n### Be Constructive\n\n```\n❌ \"This code is terrible\"\n✅ \"Consider using a Map instead of nested loops for O(1) lookups\"\n\n❌ \"You don't know how to write tests\"\n✅ \"These tests could be improved by testing the edge cases. For example, what happens when the input is empty?\"\n\n❌ \"This is wrong\"\n✅ \"This condition might not handle the case where user is null. Consider adding a null check here.\"\n```\n\n### Ask Questions\n\n```\nInstead of: \"This is inefficient\"\nTry: \"Have you considered using a Set here for faster lookups?\"\n\nInstead of: \"This won't work\"\nTry: \"What happens if the API returns null? Should we handle that case?\"\n\nInstead of: \"Bad naming\"\nTry: \"Could this variable name be more descriptive? Maybe 'activeUsers' instead of 'users'?\"\n```\n\n### Provide Context\n\n```\n❌ \"Use async/await\"\n\n✅ \"Consider using async/await instead of .then() chains for better readability:\n    ```typescript\n    // Current\n    fetchUser()\n      .then(user => fetchOrders(user.id))\n      .then(orders => processOrders(orders))\n\n    // Suggested\n    const user = await fetchUser();\n    const orders = await fetchOrders(user.id);\n    await processOrders(orders);\n    ```\"\n```\n\n### Distinguish Severity\n\n```markdown\n**Blocking (must fix):**\n- 🔴 Security vulnerability: SQL injection risk on line 45\n- 🔴 Bug: Off-by-one error will cause array out of bounds\n\n**Important (should fix):**\n- 🟠 Performance: N+1 query detected, consider using JOIN\n- 🟠 Missing error handling for API call\n\n**Suggestion (nice to have):**\n- 🟡 Nit: Consider extracting this into a separate function\n- 🟡 Style: This could be more readable with destructuring\n```\n\n### Praise Good Code\n\n```\n✅ \"Nice use of the Strategy pattern here!\"\n✅ \"Great test coverage on this feature\"\n✅ \"I like how this handles the edge case\"\n✅ \"This is much cleaner than the previous implementation\"\n```\n\n## Review Checklist\n\n### Functional Requirements\n- [ ] Does the code do what it's supposed to do?\n- [ ] Are edge cases handled?\n- [ ] Is the error handling appropriate?\n- [ ] Are there any obvious bugs?\n\n### Code Quality\n- [ ] Is the code easy to understand?\n- [ ] Are variable and function names clear?\n- [ ] Is there unnecessary complexity?\n- [ ] Can any code be reused instead of duplicated?\n- [ ] Are there magic numbers or hardcoded values?\n\n### Security\n- [ ] Is user input validated?\n- [ ] Are there SQL injection risks?\n- [ ] Are there XSS vulnerabilities?\n- [ ] Are secrets properly handled?\n- [ ] Is authentication/authorization checked?\n\n### Performance\n- [ ] Are there any obvious performance issues?\n- [ ] Are database queries optimized?\n- [ ] Is caching used appropriately?\n- [ ] Are there memory leaks?\n\n### Testing\n- [ ] Are there tests for new functionality?\n- [ ] Do tests cover edge cases?\n- [ ] Are tests meaningful (not just for coverage)?\n- [ ] Do all tests pass?\n\n### Documentation\n- [ ] Is complex logic documented?\n- [ ] Are API changes documented?\n- [ ] Are breaking changes clearly noted?\n\n## Code Review Workflow\n\n### Small Pull Requests\n\n```\n❌ Large PR:\n- 50 files changed\n- 2,000+ lines added\n- Multiple features mixed together\n→ Hard to review, easy to miss bugs\n\n✅ Small PR:\n- 3-5 files changed\n- 100-300 lines\n- Single focused change\n→ Easy to review thoroughly\n```\n\n### Self-Review First\n\nBefore requesting review:\n\n```typescript\n// 1. Review your own diff\n// Look for:\n// - Debugging console.logs left in\n// - Commented-out code\n// - TODOs that should be addressed\n// - Formatting inconsistencies\n\n// 2. Run tests locally\nnpm test\n\n// 3. Check for type errors\nnpm run typecheck\n\n// 4. Lint code\nnpm run lint\n\n// 5. Update documentation\n// - README if public API changed\n// - CHANGELOG for notable changes\n```\n\n### Description Template\n\n```markdown\n## What does this PR do?\nBrief description of the change\n\n## Why is this change needed?\nContext and motivation\n\n## How was this tested?\n- [ ] Unit tests added/updated\n- [ ] Manual testing performed\n- [ ] Integration tests pass\n\n## Screenshots (if applicable)\nBefore/after screenshots for UI changes\n\n## Deployment notes\nAny special deployment steps or migrations needed\n\n## Related issues\nCloses #123\n```\n\n### Review Timeline\n\n```\n- Small PR (<100 lines): Review within 4 hours\n- Medium PR (100-300 lines): Review within 1 day\n- Large PR (>300 lines): Break into smaller PRs\n\nSet team SLA for code reviews to keep momentum\n```\n\n## Automation\n\n### Pre-Commit Hooks\n\n```bash\n# .husky/pre-commit\n#!/bin/sh\nnpm run lint\nnpm run typecheck\nnpm test\n```\n\n### CI/CD Checks\n\n```yaml\n# .github/workflows/pr-checks.yml\nname: PR Checks\n\non: pull_request\n\njobs:\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - run: npm ci\n      - run: npm run lint\n\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - run: npm ci\n      - run: npm test\n\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - run: npm ci\n      - run: npm run build\n\n  security:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - run: npm audit\n      - uses: snyk/actions/node@master\n        env:\n          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}\n```\n\n### Automated Feedback\n\n```typescript\n// Danger.js - Automated code review\nimport { danger, warn, fail, message } from 'danger';\n\n// Warn if PR is too large\nconst bigPRThreshold = 500;\nif (danger.github.pr.additions + danger.github.pr.deletions > bigPRThreshold) {\n  warn(':exclamation: This PR is quite large. Consider breaking it into smaller PRs.');\n}\n\n// Fail if tests are missing\nconst hasAppChanges = danger.git.modified_files.some(f => f.startsWith('src/'));\nconst hasTestChanges = danger.git.modified_files.some(f => f.includes('.test.'));\n\nif (hasAppChanges && !hasTestChanges) {\n  fail('Tests are missing for app code changes');\n}\n\n// Remind about CHANGELOG\nconst hasChangelog = danger.git.modified_files.includes('CHANGELOG.md');\nif (!hasChangelog) {\n  warn('Consider updating CHANGELOG.md');\n}\n\n// Check for console.log\nconst jsFiles = danger.git.created_files.filter(f => f.endsWith('.ts') || f.endsWith('.js'));\nfor (const file of jsFiles) {\n  const content = await danger.github.utils.fileContents(file);\n  if (content.includes('console.log')) {\n    warn(`\\`console.log\\` found in ${file}`);\n  }\n}\n```\n\n## Review Anti-Patterns\n\n### ❌ Nitpicking\n\n```\nReviewer: \"Add a space after this comma\"\nReviewer: \"Use single quotes instead of double quotes\"\nReviewer: \"This line could be 79 characters instead of 80\"\n\n→ Use automated formatters (Prettier) instead\n```\n\n### ❌ Reviewing Line-by-Line\n\n```\n❌ Commenting on every single line\n→ Focus on high-level architecture and logic\n\n✅ Comment on:\n- Design decisions\n- Potential bugs\n- Security issues\n- Performance problems\n\nNot:\n- Formatting (automate it)\n- Style preferences (define team standard)\n```\n\n### ❌ Approval Without Review\n\n```\n❌ \"LGTM\" without actually reading code\n→ Defeats the purpose of code review\n\n✅ Actually review the code or don't approve\n```\n\n### ❌ Being Defensive\n\n```\nAuthor (defensive):\n\"This is the only way to do it\"\n\"The previous developer wrote it this way\"\n\"I don't have time to change this\"\n\n✅ Better response:\n\"Good point. I'll refactor this to use a Map\"\n\"I hadn't considered that edge case, will add a test\"\n\"That's a better approach, thanks for the suggestion\"\n```\n\n### ❌ Endless Debates\n\n```\nReviewer: \"Use tabs\"\nAuthor: \"Spaces are better\"\nReviewer: \"Tabs are more flexible\"\n...\n\n→ Define team standard, automate with Prettier\n→ Don't debate style in PR comments\n```\n\n## Pair Programming as Review\n\n### Real-Time Code Review\n\n```\nInstead of:\n1. Write code alone\n2. Submit PR\n3. Wait for review\n4. Address comments\n5. Repeat\n\nTry:\n1. Pair program with another developer\n2. Review happens in real-time\n3. Submit pre-reviewed PR\n4. Quick final check\n5. Merge\n\nBenefits:\n- Faster feedback\n- Knowledge sharing\n- Fewer review cycles\n- Better solutions through collaboration\n```\n\n## References\n\n- [Google's Code Review Guidelines](https://google.github.io/eng-practices/review/)\n- [Conventional Comments](https://conventionalcomments.org/)\n- [How to Review Code](https://mtlynch.io/human-code-reviews-1/)\n- [The Art of Giving and Receiving Code Reviews](https://www.alexandra-hill.com/2018/06/25/the-art-of-giving-and-receiving-code-reviews/)\n",
    "original/development-practices/deployment-delivery.md": "# Deployment & Delivery Best Practices\n\n## Environment Management\n\n### Environment Hierarchy\n\n```\nDevelopment → Staging → Production\n\nDevelopment (Dev):\n- Developers' local machines or shared dev server\n- Frequent changes, unstable\n- Mock external services when possible\n- Fast feedback loop\n\nStaging (Pre-Production):\n- Production-like environment\n- Test deployments before production\n- Integration with real external services (sandbox/test modes)\n- Performance and load testing\n\nProduction (Prod):\n- Live system serving real users\n- Stable, monitored, backed up\n- Minimal manual changes\n- Automated deployments only\n```\n\n### Environment Parity\n\n```\n✅ Keep environments as similar as possible\n\nDevelopment should mirror Production:\n- Same OS and runtime versions\n- Same database engine and version\n- Same configuration structure (different values)\n- Same infrastructure patterns\n\n❌ Environment drift causes bugs\nDev: SQLite\nStaging: MySQL\nProduction: PostgreSQL\n→ Different behaviors, hard to debug\n\n✅ Use containers for consistency\nDocker ensures same runtime everywhere:\n- Same base image across environments\n- Same dependencies and versions\n- Same file system structure\n```\n\n### Environment-Specific Configuration\n\n```\n❌ Hardcoded environment values\nif (hostname == 'prod-server-1') {\n    apiUrl = 'https://api.production.com'\n} else if (hostname == 'staging-server') {\n    apiUrl = 'https://api.staging.com'\n}\n\n✅ Environment variables\nAPI_URL = process.env.API_URL\nDATABASE_URL = process.env.DATABASE_URL\nLOG_LEVEL = process.env.LOG_LEVEL || 'info'\n\n✅ Configuration files per environment\nconfig/\n├── base.yml           # Common settings\n├── development.yml    # Dev overrides\n├── staging.yml        # Staging overrides\n└── production.yml     # Prod overrides\n\nLoad based on ENVIRONMENT variable:\nconfig = loadConfig(`config/${ENVIRONMENT}.yml`)\n```\n\n### Secrets Management\n\n```\n❌ Never commit secrets to version control\nDATABASE_PASSWORD=super_secret_123\nAPI_KEY=sk-1234567890abcdef\n\n✅ Use environment variables or secret management\n# .env.example (committed)\nDATABASE_PASSWORD=\nAPI_KEY=\n\n# .env (not committed, in .gitignore)\nDATABASE_PASSWORD=actual_password\nAPI_KEY=actual_key\n\n✅ Use secret management services\n- HashiCorp Vault\n- AWS Secrets Manager\n- Azure Key Vault\n- Google Secret Manager\n\nSecrets injected at runtime, never stored in code:\npassword = secretsManager.getSecret('database-password')\n```\n\n## Continuous Integration (CI)\n\n### Core Principles\n\n```\n1. Maintain a single source repository\n   - All code in version control (Git)\n   - Include build scripts, tests, configs\n\n2. Automate the build\n   - One command to build from source\n   - No manual steps\n\n3. Make builds self-testing\n   - Automated tests run on every build\n   - Build fails if tests fail\n\n4. Everyone commits daily\n   - Integrate at least once per day\n   - Smaller changes = easier integration\n\n5. Every commit builds on integration machine\n   - CI server (Jenkins, GitHub Actions, GitLab CI)\n   - Catches integration problems immediately\n\n6. Keep builds fast\n   - Under 10 minutes for commit build\n   - Longer tests in separate pipeline stages\n\n7. Test in production-like environment\n   - CI environment mirrors production\n\n8. Make it easy to get latest build\n   - Latest successful build always available\n   - Artifacts stored and versioned\n\n9. Everyone sees build status\n   - Visible dashboard\n   - Notifications on failures\n```\n\n### CI Pipeline Example\n\n```\n.github/workflows/ci.yml (GitHub Actions)\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Setup environment\n        run: |\n          # Install dependencies\n          # Setup runtime\n\n      - name: Lint\n        run: lint-command\n\n      - name: Unit tests\n        run: test-command\n\n      - name: Build\n        run: build-command\n\n      - name: Integration tests\n        run: integration-test-command\n\n  security:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Security scan\n        run: security-scan-command\n\n  # Only deploy if all checks pass\n  deploy-staging:\n    needs: [build, security]\n    if: github.ref == 'refs/heads/develop'\n    runs-on: ubuntu-latest\n    steps:\n      - name: Deploy to staging\n        run: deploy-to-staging\n```\n\n## Continuous Delivery (CD)\n\n### Definition\n\n**Continuous Delivery**: Software is always in a deployable state. Any version can be deployed to production at any time with a single action.\n\n**Key Test**: A business stakeholder can request production deployment immediately without team anxiety.\n\n### Four Requirements\n\n```\n1. Software deployable throughout development\n   - Never break the build for extended periods\n   - Feature branches deployed to test environments\n\n2. Prioritize deployability over new features\n   - If choice between new feature and fixing build, fix build\n   - Technical debt that blocks deployment is critical\n\n3. Automated feedback on production readiness\n   - Automated tests after every commit\n   - Fast feedback (minutes, not hours)\n\n4. Push-button deployment to any environment\n   - One command deploys to dev/staging/prod\n   - No manual steps (no \"update this config file\")\n```\n\n### Continuous Delivery vs Continuous Deployment\n\n```\nContinuous Delivery:\n- CAN deploy any time\n- Business chooses when to deploy\n- Deployment is decision, not technical limitation\n\nContinuous Deployment:\n- EVERY change goes to production automatically\n- No human decision point\n- Higher risk, requires excellent monitoring\n\nMost teams use Continuous Delivery:\n- Deploy multiple times per day if needed\n- Deploy weekly for stable products\n- Choice based on business needs\n```\n\n## Deployment Pipeline\n\n### Pipeline Stages\n\n```\nA deployment pipeline breaks builds into stages.\nEach stage provides increasing confidence at the cost of extra time.\n\n┌─────────────┐\n│   Commit    │  Fast: Compile, unit tests, code quality\n│   Stage     │  Goal: Catch common errors in <10 minutes\n└──────┬──────┘\n       │ Pass\n       ↓\n┌─────────────┐\n│ Acceptance  │  Medium: Integration tests, API tests\n│   Stage     │  Goal: Verify system behavior (10-30 min)\n└──────┬──────┘\n       │ Pass\n       ↓\n┌─────────────┐\n│  Manual     │  Slow: Manual QA, exploratory testing\n│   Test      │  Goal: Human verification\n└──────┬──────┘\n       │ Pass\n       ↓\n┌─────────────┐\n│ Production  │  Deployment to live environment\n│  Deploy     │  Automated or one-click\n└─────────────┘\n```\n\n### Stage Design Principles\n\n```\n✅ Fast feedback first\n- Run cheapest, fastest tests early\n- Expensive tests later in pipeline\n\n✅ Fail fast\n- Stop pipeline on first failure\n- Don't waste time on later stages\n\n✅ Parallelize where possible\n- Run independent tests concurrently\n- Use multiple machines for test suites\n\n✅ One artifact, many environments\n- Build once in commit stage\n- Same binary deployed through all stages\n- Only configuration changes per environment\n\n❌ Don't rebuild in later stages\nCommit stage: Build artifact → artifact.v1.2.3\nLater stages: Deploy artifact.v1.2.3 (same binary)\n```\n\n### Pipeline Example\n\n```\n# Jenkinsfile (Jenkins Pipeline)\n\npipeline {\n  agent any\n\n  stages {\n    stage('Commit') {\n      steps {\n        sh 'build-command'\n        sh 'unit-test-command'\n        sh 'lint-command'\n      }\n    }\n\n    stage('Acceptance') {\n      steps {\n        sh 'deploy-to-test-environment'\n        sh 'run-integration-tests'\n        sh 'run-api-tests'\n      }\n    }\n\n    stage('Performance') {\n      steps {\n        sh 'deploy-to-perf-environment'\n        sh 'run-load-tests'\n      }\n    }\n\n    stage('Deploy Staging') {\n      when {\n        branch 'main'\n      }\n      steps {\n        sh 'deploy-to-staging'\n        sh 'smoke-tests'\n      }\n    }\n\n    stage('Deploy Production') {\n      when {\n        branch 'main'\n      }\n      input {\n        message \"Deploy to production?\"\n        ok \"Deploy\"\n      }\n      steps {\n        sh 'deploy-to-production'\n        sh 'smoke-tests'\n      }\n    }\n  }\n\n  post {\n    failure {\n      // Notify team of pipeline failure\n    }\n  }\n}\n```\n\n## Deployment Strategies\n\n### Blue-Green Deployment\n\n```\nPattern: Maintain two identical production environments.\nSwitch traffic between them for zero-downtime deployments.\n\n┌─────────────┐\n│    Blue     │  ← Currently serving traffic\n│ Environment │\n└─────────────┘\n       ↑\n   [Router]\n       ↓ (switch)\n┌─────────────┐\n│    Green    │  ← New version deployed, tested\n│ Environment │\n└─────────────┘\n\nSteps:\n1. Blue serves production traffic\n2. Deploy new version to Green\n3. Test Green thoroughly (smoke tests, sanity checks)\n4. Switch router to Green\n5. Monitor for issues\n6. If problems: Switch back to Blue (instant rollback)\n7. If success: Blue becomes staging for next release\n\nBenefits:\n✅ Zero downtime deployment\n✅ Instant rollback capability\n✅ Test in production-like environment\n✅ Disaster recovery testing on every deploy\n\nChallenges:\n⚠️  Requires double infrastructure\n⚠️  Database migrations must support both versions\n⚠️  Stateful sessions need special handling\n```\n\n### Database Migrations for Blue-Green\n\n```\nProblem: Blue and Green share database.\nNew version may need schema changes.\n\n❌ Breaking migration\nDeploy Green with new schema:\nALTER TABLE users DROP COLUMN legacy_field;\n→ Blue breaks immediately\n\n✅ Parallel Change pattern\nPhase 1: Add new column (both versions work)\nALTER TABLE users ADD COLUMN new_field VARCHAR(255);\n\nDeploy Green (reads new_field, writes both)\nDeploy Blue (updated to write both fields)\n\nPhase 2: Migrate data\nUPDATE users SET new_field = legacy_field WHERE new_field IS NULL;\n\nPhase 3: Remove old column (after Blue retired)\nALTER TABLE users DROP COLUMN legacy_field;\n```\n\n### Canary Release\n\n```\nPattern: Gradually roll out changes to subset of users.\nMonitor metrics before full rollout.\n\nProduction Traffic (100%)\n       ↓\n   [Router]\n       ├──→ 95% → Old Version\n       └──→ 5%  → New Version (Canary)\n\nSteps:\n1. Deploy new version to small subset (5% of servers)\n2. Route 5% of traffic to canary\n3. Monitor metrics: errors, latency, business KPIs\n4. If metrics good: Increase to 25%\n5. If metrics good: Increase to 50%\n6. If metrics good: Increase to 100%\n7. If metrics bad at any point: Rollback to 0%\n\nRollout Strategies:\n- Random user sampling\n- Internal employees first\n- Geographic regions (US-East → US-West → EU)\n- User segments (free users → paid users)\n\nBenefits:\n✅ Limit blast radius of bugs\n✅ Real production testing with real users\n✅ Gradual validation of capacity\n✅ Easy rollback (just reroute traffic)\n\nMonitoring:\nTrack during canary:\n- Error rates (5xx, 4xx)\n- Response times (p50, p95, p99)\n- Business metrics (conversion, revenue)\n- Infrastructure metrics (CPU, memory)\n\nAutomated Rollback:\nif (canaryErrorRate > oldVersionErrorRate * 1.5) {\n    rollback(\"Error rate increased significantly\")\n}\n```\n\n### Feature Toggles (Feature Flags)\n\n```\nPattern: Deploy code with features disabled.\nEnable features via configuration without redeployment.\n\nCategories of Toggles:\n\n1. Release Toggles (short-lived: days-weeks)\n   Allow incomplete features to be merged to main branch\n\n   if (featureFlags.isEnabled('new-checkout-flow')) {\n       return newCheckoutFlow()\n   } else {\n       return oldCheckoutFlow()\n   }\n\n2. Experiment Toggles (short-lived: weeks-months)\n   A/B testing and multivariate experiments\n\n   variant = experimentService.getVariant(userId, 'pricing-test')\n   if (variant == 'A') {\n       price = 9.99\n   } else if (variant == 'B') {\n       price = 14.99\n   }\n\n3. Ops Toggles (temporary or permanent)\n   Graceful degradation during outages\n\n   if (featureFlags.isEnabled('recommendations') && recommendationService.isHealthy()) {\n       recommendations = recommendationService.get(userId)\n   } else {\n       recommendations = []  // Degrade gracefully\n   }\n\n4. Permissioning Toggles (long-lived: months-years)\n   Premium features, beta access, internal-only features\n\n   if (user.isPremium || featureFlags.isEnabled('premium-feature', userId)) {\n       showPremiumFeature()\n   }\n```\n\n### Feature Toggle Best Practices\n\n```\n✅ Decouple decision from logic\n❌ Scattered conditionals\nif (isFeatureEnabled('feature-x')) { /* ... */ }\nif (isFeatureEnabled('feature-x')) { /* ... */ }\n\n✅ Centralize decisions\nclass FeatureDecisions {\n    useNewCheckout() {\n        return this.flags.isEnabled('new-checkout')\n    }\n}\n\n✅ Dependency injection\nclass CheckoutController {\n    constructor(features) {\n        if (features.useNewCheckout()) {\n            this.checkout = new NewCheckout()\n        } else {\n            this.checkout = new OldCheckout()\n        }\n    }\n}\n\n✅ Lifecycle management\nToggles are inventory with carrying cost.\n\nWhen creating toggle:\n- Add removal task to backlog immediately\n- Set expiration date\n- Document purpose and removal criteria\n\nProactive removal:\nMAX_TOGGLES = 20\nif (activeToggles.length > MAX_TOGGLES) {\n    throw new Error(\"Too many toggles! Remove old ones.\")\n}\n\n✅ Testing strategy\nTest configurations:\n1. All toggles off (fallback state)\n2. Expected production state\n3. All toggles on (optional, catch regressions)\n\n❌ Don't test all combinations (2^n explosion)\n\n✅ Runtime overrides for testing\nCookie-based override:\nif (cookie.featureOverride == 'new-checkout') {\n    enableFeature('new-checkout')\n}\n\nAllows testing without deployment\n```\n\n## Infrastructure as Code (IaC)\n\n### Principles\n\n```\nTreat infrastructure like software:\n- Version controlled\n- Code reviewed\n- Automated deployment\n- Tested\n\nBenefits:\n✅ Reproducible environments\n✅ Self-documenting infrastructure\n✅ Disaster recovery (rebuild from code)\n✅ Version history of infrastructure changes\n```\n\n### IaC Tools\n\n```\nTerraform (cloud-agnostic):\nresource \"aws_instance\" \"web\" {\n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t2.micro\"\n\n  tags = {\n    Name = \"WebServer\"\n    Environment = \"production\"\n  }\n}\n\nTerraform commands:\nterraform plan    # Preview changes\nterraform apply   # Apply changes\nterraform destroy # Tear down\n\nCloudFormation (AWS):\nResources:\n  WebServer:\n    Type: AWS::EC2::Instance\n    Properties:\n      ImageId: ami-0c55b159cbfafe1f0\n      InstanceType: t2.micro\n\nAnsible (configuration management):\n- name: Install web server\n  hosts: webservers\n  tasks:\n    - name: Install nginx\n      package:\n        name: nginx\n        state: present\n    - name: Start nginx\n      service:\n        name: nginx\n        state: started\n```\n\n### Immutable Infrastructure\n\n```\nTraditional (mutable servers):\n1. Deploy server\n2. SSH in, install updates\n3. Patch security issues\n4. Over time: configuration drift, \"snowflake servers\"\n\nModern (immutable servers):\n1. Build new server image with changes\n2. Deploy new servers from image\n3. Route traffic to new servers\n4. Terminate old servers\n5. Never modify running servers\n\nBenefits:\n✅ No configuration drift\n✅ Easy rollback (deploy old image)\n✅ Consistent, reproducible\n✅ Testable (test image before deploy)\n\nPhoenix Servers:\nRebuild servers regularly (daily/weekly) rather than patch:\n- Prevents configuration drift\n- Tests disaster recovery\n- Keeps rebuild process working\n```\n\n## Monitoring & Observability\n\n### Pre-Production Monitoring\n\n```\nSmoke Tests after deployment:\nQuick sanity checks that core functionality works\n\nPOST deployment:\n  1. Health check endpoint returns 200\n  2. Database connection succeeds\n  3. External API dependencies reachable\n  4. Critical user flow completes\n\nIf smoke test fails: Automatic rollback\n\nSynthetic Monitoring:\nAutomated tests running against production continuously\n\nEvery 5 minutes:\n  - Simulate user login\n  - Simulate checkout flow\n  - Simulate API calls\n\nDetect issues before users report them\n```\n\n### Deployment Metrics\n\n```\nTrack for every deployment:\n\nDeployment Frequency:\n- How often do we deploy?\n- Goal: Multiple times per day (elite performers)\n\nLead Time:\n- Time from commit to production\n- Goal: Less than 1 hour (elite performers)\n\nChange Failure Rate:\n- What % of deployments cause incidents?\n- Goal: Less than 15%\n\nMean Time to Recovery (MTTR):\n- How quickly can we recover from failure?\n- Goal: Less than 1 hour\n\nThese are DORA metrics (DevOps Research & Assessment)\n```\n\n## Rollback Strategies\n\n```\nFast rollback is critical for low-risk deployments\n\nDeployment Strategy → Rollback Method:\n\nBlue-Green:\n  Rollback: Switch router back to old environment\n  Speed: Instant (seconds)\n\nCanary:\n  Rollback: Reroute traffic away from canary\n  Speed: Instant (seconds)\n\nRolling Deployment:\n  Rollback: Deploy previous version\n  Speed: Same as deployment (minutes)\n\nDatabase Migrations:\n  Rollback: Run down migration\n  Speed: Depends on data volume (minutes to hours)\n  ⚠️  Data loss risk\n\nAlways test rollback procedure:\n- Rollback in staging before production deployment\n- Practice rollback during low-traffic periods\n- Document rollback steps\n- Automate rollback if possible\n\nRollback decision criteria:\nAutomatic rollback if:\n- Smoke tests fail\n- Error rate > threshold\n- Response time > threshold\n\nManual rollback if:\n- Critical business metric drops\n- User complaints spike\n- Unclear issue requiring investigation\n```\n\n## Common Anti-Patterns\n\n```\n❌ Manual deployments\n\"SSH into server and copy files\"\n→ Error-prone, not reproducible, no audit trail\n\n✅ Automated, scripted deployments\n\n❌ \"Works on my machine\"\nDifferent environment between dev and prod\n→ Use containers for consistency\n\n❌ Long-lived feature branches\nBranches diverge, painful merges, integration hell\n→ Trunk-based development with feature toggles\n\n❌ Testing in production only\nFirst time code runs together is production\n→ CI/CD with automated testing\n\n❌ Big bang releases\nDeploy months of changes at once\n→ Small, frequent deployments\n\n❌ No rollback plan\n\"We'll fix forward if something breaks\"\n→ Always have tested rollback procedure\n\n❌ Shared mutable infrastructure\nMultiple apps on same servers, manual configuration\n→ Immutable infrastructure, one app per instance\n\n❌ Permanent feature flags\n100+ flags, some years old\n→ Proactive toggle removal, max toggle limits\n```\n\n## Deployment Checklist\n\n```\nBefore Deployment:\n□ All tests passing in CI\n□ Code reviewed and approved\n□ Deployment plan documented\n□ Rollback plan documented and tested\n□ Database migrations reviewed (support old and new code)\n□ Feature flags configured correctly\n□ Monitoring and alerts configured\n□ Stakeholders notified (if major change)\n□ Deployment window scheduled (if needed)\n\nDuring Deployment:\n□ Deploy during low-traffic period (if possible)\n□ Monitor error rates and metrics\n□ Run smoke tests after deployment\n□ Check logs for errors\n□ Verify feature flags working as expected\n\nAfter Deployment:\n□ Monitor for 30 minutes minimum\n□ Check business metrics\n□ Verify with stakeholders\n□ Update documentation\n□ Schedule feature flag removal (if added)\n□ Document any issues encountered\n□ Retrospective on problems (if any)\n```\n\n## Summary\n\n**Environment Management:**\n- Maintain dev, staging, production environments\n- Keep environment parity (same OS, runtime, database)\n- Use environment variables for configuration\n- Never commit secrets to version control\n\n**Continuous Integration:**\n- Everyone commits daily to main branch\n- Automated builds and tests on every commit\n- Keep builds fast (<10 minutes)\n- Visible build status for whole team\n\n**Continuous Delivery:**\n- Software always deployable\n- Automated deployment to any environment\n- Push-button deployment, no manual steps\n- Business chooses when to deploy\n\n**Deployment Pipeline:**\n- Fast feedback first (unit tests, linting)\n- Increasing confidence in later stages\n- Build once, deploy same artifact everywhere\n- Fail fast, parallelize where possible\n\n**Deployment Strategies:**\n- Blue-Green: Zero-downtime with instant rollback\n- Canary: Gradual rollout with risk mitigation\n- Feature Toggles: Deploy code, enable features separately\n- Infrastructure as Code: Treat infrastructure like software\n\n**Key Principles:**\n- Small, frequent deployments (less risk than big bang)\n- Automated everything (build, test, deploy)\n- Fast rollback capability (test rollback procedures)\n- Monitor metrics during and after deployment\n- Immutable infrastructure (rebuild, don't patch)\n\n## References\n\n- [Continuous Delivery by Jez Humble & David Farley](https://continuousdelivery.com/)\n- [Martin Fowler - Continuous Integration](https://martinfowler.com/articles/continuousIntegration.html)\n- [Martin Fowler - Deployment Pipeline](https://martinfowler.com/bliki/DeploymentPipeline.html)\n- [Martin Fowler - Blue-Green Deployment](https://martinfowler.com/bliki/BlueGreenDeployment.html)\n- [Martin Fowler - Canary Release](https://martinfowler.com/bliki/CanaryRelease.html)\n- [Martin Fowler - Feature Toggles](https://martinfowler.com/articles/feature-toggles.html)\n- [Google SRE Book - Release Engineering](https://sre.google/sre-book/release-engineering/)\n- [DORA Metrics](https://www.devops-research.com/research.html)\n",
    "original/development-practices/devops-practices.md": "# DevOps Best Practices & Guidelines\n\n## CI/CD Pipeline Patterns\n\n### Build Pipeline Structure\n\n```yaml\n# .github/workflows/ci-cd.yml\nname: CI/CD Pipeline\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Install dependencies\n        run: npm ci\n      - name: Lint\n        run: npm run lint\n      - name: Unit tests\n        run: npm test\n      - name: Integration tests\n        run: npm run test:integration\n      - name: Build\n        run: npm run build\n      - name: Security scan\n        run: npm audit\n\n  deploy-staging:\n    needs: test\n    if: github.ref == 'refs/heads/main'\n    runs-on: ubuntu-latest\n    steps:\n      - name: Deploy to staging\n        run: ./deploy.sh staging\n      - name: Smoke tests\n        run: npm run test:smoke\n      - name: E2E tests\n        run: npm run test:e2e\n\n  deploy-production:\n    needs: deploy-staging\n    if: github.ref == 'refs/heads/main'\n    runs-on: ubuntu-latest\n    environment: production\n    steps:\n      - name: Deploy\n        run: ./deploy.sh production\n      - name: Health check\n        run: ./health-check.sh\n      - name: Verify metrics\n        run: ./verify-deployment.sh\n```\n\n### Deployment Strategies\n\n**Blue-Green Deployment:**\n```bash\n# Zero-downtime deployment\n./deploy.sh blue-green\n\n# Steps:\n# 1. Deploy new version to \"green\" environment\n# 2. Run health checks on green\n# 3. Switch traffic from blue to green\n# 4. Keep blue running for quick rollback\n# 5. After validation, decommission blue\n```\n\n**Canary Deployment:**\n```yaml\n# Gradual rollout\napiVersion: v1\nkind: Service\nmetadata:\n  name: app-canary\nspec:\n  selector:\n    app: myapp\n    version: v2\n  # Route 10% of traffic to v2\n  sessionAffinity: ClientIP\n```\n\n**Feature Flags:**\n```typescript\nexport const processPayment = async (order: Order) => {\n  if (featureFlags.isEnabled('new-payment-gateway', order.userId)) {\n    return newPaymentGateway.charge(order);\n  }\n  return legacyPaymentGateway.charge(order);\n};\n```\n\n## Infrastructure as Code\n\n### Terraform Example\n\n```hcl\n# main.tf\nterraform {\n  backend \"s3\" {\n    bucket = \"myapp-terraform-state\"\n    key    = \"production/terraform.tfstate\"\n    region = \"us-east-1\"\n  }\n}\n\nresource \"aws_instance\" \"app_server\" {\n  ami           = var.app_ami\n  instance_type = var.instance_type\n\n  tags = {\n    Name        = \"app-server-${var.environment}\"\n    Environment = var.environment\n    ManagedBy   = \"terraform\"\n  }\n}\n\nresource \"aws_security_group\" \"app_sg\" {\n  name = \"app-sg-${var.environment}\"\n\n  ingress {\n    from_port   = 443\n    to_port     = 443\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\n```\n\n### Docker Compose for Local Development\n\n```yaml\n# docker-compose.yml\nversion: '3.8'\n\nservices:\n  app:\n    build: .\n    ports:\n      - \"3000:3000\"\n    environment:\n      DB_HOST: postgres\n      REDIS_URL: redis://redis:6379\n      NODE_ENV: development\n    volumes:\n      - .:/app\n      - /app/node_modules\n    depends_on:\n      postgres:\n        condition: service_healthy\n      redis:\n        condition: service_started\n\n  postgres:\n    image: postgres:14\n    environment:\n      POSTGRES_DB: ${DB_NAME}\n      POSTGRES_USER: ${DB_USER}\n      POSTGRES_PASSWORD: ${DB_PASSWORD}\n    volumes:\n      - postgres-data:/var/lib/postgresql/data\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U ${DB_USER}\"]\n      interval: 5s\n      timeout: 5s\n      retries: 5\n\n  redis:\n    image: redis:7-alpine\n    volumes:\n      - redis-data:/data\n\nvolumes:\n  postgres-data:\n  redis-data:\n```\n\n## Monitoring & Observability\n\n### Structured Logging\n\n```typescript\nimport { createLogger } from './logger';\n\nconst logger = createLogger({\n  service: 'order-service',\n  environment: process.env.NODE_ENV\n});\n\nexport const processOrder = async (orderId: string, userId: string) => {\n  const timer = logger.startTimer();\n\n  logger.info('Processing order', {\n    orderId,\n    userId,\n    timestamp: new Date().toISOString()\n  });\n\n  try {\n    const order = await orderRepo.findById(orderId);\n\n    logger.debug('Order retrieved', {\n      orderId,\n      status: order.status,\n      total: order.total\n    });\n\n    await paymentService.charge(order);\n\n    logger.info('Order processed', {\n      orderId,\n      userId,\n      duration: timer.elapsed()\n    });\n\n    return order;\n  } catch (error) {\n    logger.error('Order processing failed', {\n      orderId,\n      userId,\n      error: error.message,\n      stack: error.stack,\n      context: { order }\n    });\n    throw error;\n  }\n};\n```\n\n### Application Metrics\n\n```typescript\nimport { metrics } from './metrics';\n\nexport const handler = async (req, res) => {\n  const startTime = Date.now();\n  const route = req.route.path;\n\n  try {\n    const result = await processRequest(req);\n\n    metrics.increment('requests.success', { route });\n    metrics.recordHistogram('request.duration', Date.now() - startTime, { route });\n    metrics.gauge('active_connections', getActiveConnections());\n\n    return res.json(result);\n  } catch (error) {\n    metrics.increment('requests.error', { route, error: error.name });\n    metrics.recordHistogram('request.duration', Date.now() - startTime, {\n      route,\n      status: 'error'\n    });\n    throw error;\n  }\n};\n```\n\n### Distributed Tracing\n\n```typescript\nimport { trace, context } from '@opentelemetry/api';\n\nconst tracer = trace.getTracer('order-service');\n\nexport const createOrder = async (orderData) => {\n  return tracer.startActiveSpan('createOrder', async (span) => {\n    try {\n      span.setAttribute('user.id', orderData.userId);\n      span.setAttribute('order.total', orderData.total);\n\n      const order = await tracer.startActiveSpan('db.insert', async (dbSpan) => {\n        const result = await db.insert('orders', orderData);\n        dbSpan.setAttribute('db.operation', 'insert');\n        dbSpan.setAttribute('db.table', 'orders');\n        dbSpan.end();\n        return result;\n      });\n\n      await tracer.startActiveSpan('payment.charge', async (paymentSpan) => {\n        await paymentService.charge(order.total);\n        paymentSpan.setAttribute('payment.amount', order.total);\n        paymentSpan.end();\n      });\n\n      span.setStatus({ code: SpanStatusCode.OK });\n      return order;\n    } catch (error) {\n      span.recordException(error);\n      span.setStatus({ code: SpanStatusCode.ERROR, message: error.message });\n      throw error;\n    } finally {\n      span.end();\n    }\n  });\n};\n```\n\n### Health Check Endpoints\n\n```typescript\nexport const healthCheck = async (req, res) => {\n  const health = {\n    status: 'healthy',\n    timestamp: new Date().toISOString(),\n    uptime: process.uptime(),\n    checks: {\n      database: await checkDatabase(),\n      redis: await checkRedis(),\n      externalApi: await checkExternalApi()\n    }\n  };\n\n  const isHealthy = Object.values(health.checks).every(check => check.status === 'ok');\n\n  res.status(isHealthy ? 200 : 503).json(health);\n};\n\nconst checkDatabase = async () => {\n  try {\n    await db.query('SELECT 1');\n    return { status: 'ok', latency: 5 };\n  } catch (error) {\n    return { status: 'error', error: error.message };\n  }\n};\n```\n\n### Alerting Rules\n\n```yaml\n# Prometheus alert rules\ngroups:\n  - name: application_alerts\n    rules:\n      - alert: HighErrorRate\n        expr: rate(http_requests_total{status=~\"5..\"}[5m]) > 0.05\n        for: 5m\n        labels:\n          severity: critical\n        annotations:\n          summary: \"High error rate ({{ $value | humanizePercentage }})\"\n          description: \"{{ $labels.service }} error rate above 5% for 5 minutes\"\n\n      - alert: SlowResponseTime\n        expr: histogram_quantile(0.95, http_request_duration_seconds) > 2\n        for: 10m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"Slow response time\"\n          description: \"95th percentile response time: {{ $value }}s\"\n\n      - alert: HighMemoryUsage\n        expr: (container_memory_usage_bytes / container_spec_memory_limit_bytes) > 0.9\n        for: 5m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"High memory usage ({{ $value | humanizePercentage }})\"\n\n      - alert: ServiceDown\n        expr: up{job=\"app\"} == 0\n        for: 1m\n        labels:\n          severity: critical\n        annotations:\n          summary: \"Service is down\"\n          description: \"{{ $labels.instance }} has been down for 1 minute\"\n```\n\n## Automation Best Practices\n\n### Single-Command Build\n\n```bash\n#!/bin/bash\n# build.sh - One command to build everything\n\nset -e\n\necho \"Installing dependencies...\"\nnpm ci\n\necho \"Linting code...\"\nnpm run lint\n\necho \"Type checking...\"\nnpm run typecheck\n\necho \"Running tests...\"\nnpm test\n\necho \"Building application...\"\nnpm run build\n\necho \"Creating Docker image...\"\ndocker build -t myapp:${VERSION} .\n\necho \"Pushing to registry...\"\ndocker push myapp:${VERSION}\n\necho \"Build complete: myapp:${VERSION}\"\n```\n\n### Automated Rollback\n\n```bash\n#!/bin/bash\n# rollback.sh\n\nCURRENT_VERSION=$(cat /var/app/version.txt)\nPREVIOUS_VERSION=$(cat /var/app/previous-version.txt)\n\necho \"Rolling back from $CURRENT_VERSION to $PREVIOUS_VERSION\"\n\n# Stop current version\ndocker-compose down\n\n# Start previous version\ndocker-compose -f docker-compose.$PREVIOUS_VERSION.yml up -d\n\n# Health check\nif ./health-check.sh; then\n  echo \"Rollback successful\"\n  exit 0\nelse\n  echo \"Rollback failed\"\n  exit 1\nfi\n```\n\n### Database Migrations in CI/CD\n\n```typescript\n// migrations/run-migrations.ts\nimport { migrate } from './migrator';\n\nexport const runMigrations = async () => {\n  try {\n    console.log('Running database migrations...');\n\n    const results = await migrate({\n      direction: 'up',\n      dryRun: process.env.DRY_RUN === 'true'\n    });\n\n    console.log(`Applied ${results.length} migrations`);\n\n    if (process.env.DRY_RUN === 'true') {\n      console.log('DRY RUN - No changes made');\n    }\n\n    process.exit(0);\n  } catch (error) {\n    console.error('Migration failed:', error);\n    process.exit(1);\n  }\n};\n```\n\n## Incident Response\n\n### Runbook Template\n\n```markdown\n# Runbook: API High Error Rate\n\n## Symptoms\n- Error rate > 5% for 5+ minutes\n- Alert: `HighErrorRate` firing\n- User reports of 500 errors\n\n## Investigation Steps\n\n1. **Check application logs**\n   ```bash\n   kubectl logs -l app=api --tail=100 | grep ERROR\n   ```\n\n2. **Check recent deployments**\n   ```bash\n   kubectl rollout history deployment/api\n   ```\n\n3. **Check dependencies**\n   - Database: `./check-db.sh`\n   - Redis: `redis-cli ping`\n   - External APIs: `curl -I https://external-api.com/health`\n\n4. **Check metrics**\n   - Dashboard: https://grafana.com/d/api-overview\n   - Look for: CPU spikes, memory leaks, connection pool exhaustion\n\n## Resolution Steps\n\n### If recent deployment caused issue:\n```bash\nkubectl rollout undo deployment/api\n```\n\n### If database is slow:\n```bash\n# Check slow queries\npsql -c \"SELECT * FROM pg_stat_statements ORDER BY mean_time DESC LIMIT 10\"\n```\n\n### If external API is down:\n```bash\n# Enable circuit breaker\ncurl -X POST http://api/config/circuit-breaker/enable\n```\n\n## Escalation\n- On-call engineer: #oncall-team\n- Database team: #database-team\n- External vendor support: vendor-support@example.com\n```\n\n### Blameless Postmortem Template\n\n```markdown\n# Incident Report: [Title]\n\n**Date:** YYYY-MM-DD\n**Duration:** XX minutes\n**Severity:** Critical/Major/Minor\n**Affected Users:** X,XXX users\n\n## Summary\nBrief description of what happened and user impact.\n\n## Timeline\n- **HH:MM** - Deployment of vX.X.X\n- **HH:MM** - First error spike detected\n- **HH:MM** - Alert triggered\n- **HH:MM** - Engineer began investigation\n- **HH:MM** - Root cause identified\n- **HH:MM** - Fix deployed\n- **HH:MM** - Service fully restored\n\n## Root Cause\nTechnical explanation of what caused the incident.\n\n## What Went Well\n✅ Monitoring detected issue quickly\n✅ Rollback procedure worked\n✅ Clear communication in incident channel\n\n## What Didn't Go Well\n❌ Issue not caught in staging\n❌ Alert delay of X minutes\n❌ Unclear runbook steps\n\n## Action Items\n1. [ ] Add test coverage for scenario (Owner: @dev, Due: Date)\n2. [ ] Improve alert threshold (Owner: @ops, Due: Date)\n3. [ ] Update runbook with new steps (Owner: @sre, Due: Date)\n4. [ ] Add monitoring for X metric (Owner: @dev, Due: Date)\n\n## Lessons Learned\n- Key takeaway 1\n- Key takeaway 2\n```\n\n## DORA Metrics Reference\n\n**Four Key Metrics for DevOps Performance:**\n\n### 1. Deployment Frequency\nHow often you deploy to production.\n\n```\nElite Performers:   Multiple times per day\nHigh Performers:    Daily to weekly\nMedium Performers:  Weekly to monthly\nLow Performers:     Monthly to every 6 months\n```\n\n**Improve:** Smaller batches, automated pipelines, feature flags, trunk-based development\n\n### 2. Lead Time for Changes\nTime from commit to production.\n\n```\nElite Performers:   < 1 hour\nHigh Performers:    1 day to 1 week\nMedium Performers:  1 week to 1 month\nLow Performers:     1 month to 6 months\n```\n\n**Improve:** Remove manual gates, faster CI/CD, reduce batch size, automate tests\n\n### 3. Mean Time to Recovery (MTTR)\nTime to restore service after incident.\n\n```\nElite Performers:   < 1 hour\nHigh Performers:    < 1 day\nMedium Performers:  1 day to 1 week\nLow Performers:     1 week to 1 month\n```\n\n**Improve:** Better monitoring, automated rollback, feature flags, runbooks, practice recovery\n\n### 4. Change Failure Rate\nPercentage of deployments causing production issues.\n\n```\nElite Performers:   0-15%\nHigh Performers:    16-30%\nMedium Performers:  31-45%\nLow Performers:     46-60%\n```\n\n**Improve:** Better testing, staging matches production, gradual rollouts, post-deployment verification\n\n## Anti-Patterns\n\n### ❌ Separate \"DevOps Team\"\n\n```\nDevelopment Team → DevOps Team → Operations\n                  (new silo)\n```\n\n**Problem:** Recreates dev/ops divide, becomes bottleneck, handover mentality persists.\n\n**✅ Instead:** Embed DevOps practices in all teams, create platform team that enables (not gatekeeps).\n\n### ❌ Tools Without Culture\n\n```\nExecutive: \"We bought Jenkins and Kubernetes!\"\n\nReality:\n- Teams still siloed\n- Deployments still manual\n- No collaboration\n- Tools unused\n```\n\n**✅ Instead:** Foster collaboration first, then adopt tools that support the culture.\n\n### ❌ Manual Approval Gates\n\n```\nDeveloper → CI/CD → CAB Meeting → Production\n                    (1 week wait)\n```\n\n**Problem:** Defeats automation, creates large batches, slow feedback.\n\n**✅ Instead:** Automated governance through tests, security scans, audit trails.\n\n### ❌ Inconsistent Environments\n\n```\nDevelopment: macOS, SQLite, mock APIs\nProduction:  Linux, PostgreSQL, real APIs\n```\n\n**Problem:** \"Works on my machine,\" late discovery of environment issues.\n\n**✅ Instead:** Use containers (Docker) to match environments, IaC for consistency.\n\n### ❌ Missing Observability\n\n```typescript\n// Can't debug production issues\nexport const handler = async (req, res) => {\n  const result = await processRequest(req);\n  return res.json(result);\n};\n```\n\n**✅ Instead:**\n```typescript\nexport const handler = async (req, res) => {\n  const timer = startTimer();\n  logger.info('Request started', { path: req.path, userId: req.userId });\n\n  try {\n    const result = await processRequest(req);\n\n    metrics.recordLatency('request.duration', timer.elapsed());\n    logger.info('Request completed', { path: req.path, status: 200 });\n\n    return res.json(result);\n  } catch (error) {\n    logger.error('Request failed', {\n      path: req.path,\n      error: error.message,\n      stack: error.stack\n    });\n    throw error;\n  }\n};\n```\n\n### ❌ No Rollback Strategy\n\n```bash\n# Deploy script with no way back\n./deploy.sh production\n# Hope it works!\n```\n\n**✅ Instead:**\n```bash\n# Always keep previous version\n./deploy.sh production --keep-previous\n# Quick rollback available\n./rollback.sh\n```\n\n## Practical Tips\n\n### Make Deployments Boring\n- Deploy frequently (reduces risk per deployment)\n- Automate completely (no manual steps)\n- Same process for all environments\n- Practice rollbacks regularly\n\n### Shift Left on Security\n```yaml\n# Security in CI pipeline\n- name: Security scan\n  run: |\n    npm audit\n    docker scan myapp:latest\n    sonarqube-scan\n    dependency-check\n```\n\n### Version Everything\n- Code: Git\n- Infrastructure: Terraform/IaC\n- Configuration: Version controlled\n- Database: Migration scripts\n- Dependencies: Lock files (package-lock.json, yarn.lock)\n\n### Automate Toil\nIf you do it manually twice, automate it the third time.\n\n```bash\n# Manual: SSH into server, restart service\nssh prod-server \"sudo systemctl restart myapp\"\n\n# Automated: Self-healing service\nkubectl set image deployment/myapp myapp=myapp:v2\n# Kubernetes handles health checks and restarts\n```\n\n### Document as Code\n```typescript\n// Bad: Wiki page that gets outdated\n// Good: Code documentation that stays current\n\n/**\n * Processes order payment\n *\n * @throws {PaymentError} When payment gateway is unavailable\n * @throws {InsufficientFundsError} When user has insufficient funds\n *\n * Metrics: payment.success, payment.failure\n * Logs: payment.processed, payment.failed\n */\nexport const processPayment = async (order: Order) => {\n  // Implementation\n};\n```\n\n### Progressive Rollout Pattern\n\n```typescript\n// Gradual rollout with monitoring\nexport const deploymentStrategy = {\n  canary: {\n    steps: [\n      { traffic: 5, duration: '5m' },   // 5% traffic for 5 min\n      { traffic: 25, duration: '10m' },  // 25% traffic for 10 min\n      { traffic: 50, duration: '15m' },  // 50% traffic for 15 min\n      { traffic: 100 }                   // Full rollout\n    ],\n    autoRollback: {\n      errorRate: 0.05,     // Rollback if error rate > 5%\n      latencyP95: 2000     // Rollback if p95 latency > 2s\n    }\n  }\n};\n```\n\n### Chaos Engineering Basics\n\n```typescript\n// Inject failures to test resilience\nexport const chaosTests = {\n  // Kill random instance\n  killPod: async () => {\n    const pod = await selectRandomPod();\n    await kubectl.delete(pod);\n    await verifyServiceHealthy();\n  },\n\n  // Introduce network latency\n  networkDelay: async () => {\n    await injectLatency({ delay: '500ms', jitter: '100ms' });\n    await verifyResponseTime({ max: 3000 });\n  },\n\n  // Simulate dependency failure\n  dependencyFailure: async () => {\n    await mockService.returnError(500);\n    await verifyCircuitBreaker();\n  }\n};\n```\n\n## References\n\n- [DORA Metrics](https://cloud.google.com/blog/products/devops-sre/using-the-four-keys-to-measure-your-devops-performance)\n- [The Phoenix Project](https://itrevolution.com/the-phoenix-project/)\n- [Site Reliability Engineering (SRE)](https://sre.google/books/)\n- [Continuous Delivery](https://continuousdelivery.com/)\n- [Infrastructure as Code](https://www.terraform.io/intro)\n",
    "original/development-practices/error-handling-resilience.md": "# Error Handling & Resilience Patterns\n\n## Error Handling Best Practices\n\n### Use Custom Error Classes\n\n```typescript\n// ❌ Generic errors\nthrow new Error('User not found');\nthrow new Error('Invalid input');\n\n// ✅ Custom error hierarchy\nclass AppError extends Error {\n  constructor(\n    message: string,\n    public statusCode: number = 500,\n    public code: string = 'INTERNAL_ERROR',\n    public details?: unknown\n  ) {\n    super(message);\n    this.name = this.constructor.name;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\nclass NotFoundError extends AppError {\n  constructor(resource: string, id: string) {\n    super(`${resource} with id ${id} not found`, 404, 'NOT_FOUND', { resource, id });\n  }\n}\n\nclass ValidationError extends AppError {\n  constructor(message: string, details: unknown) {\n    super(message, 400, 'VALIDATION_ERROR', details);\n  }\n}\n\nclass UnauthorizedError extends AppError {\n  constructor(message: string = 'Unauthorized') {\n    super(message, 401, 'UNAUTHORIZED');\n  }\n}\n\n// Usage\nconst getUser = async (id: string) => {\n  const user = await db.findUser(id);\n  if (!user) {\n    throw new NotFoundError('User', id);\n  }\n  return user;\n};\n```\n\n### Centralized Error Handling\n\n```typescript\n// Express error handler\napp.use((err: Error, req: Request, res: Response, next: NextFunction) => {\n  if (err instanceof AppError) {\n    return res.status(err.statusCode).json({\n      error: {\n        message: err.message,\n        code: err.code,\n        details: err.details\n      }\n    });\n  }\n\n  // Unexpected errors\n  console.error('Unexpected error:', err);\n\n  res.status(500).json({\n    error: {\n      message: 'Internal server error',\n      code: 'INTERNAL_ERROR'\n    }\n  });\n});\n\n// Async error wrapper\nconst asyncHandler = (fn: RequestHandler) => {\n  return (req: Request, res: Response, next: NextFunction) => {\n    Promise.resolve(fn(req, res, next)).catch(next);\n  };\n};\n\n// Usage\napp.get('/users/:id', asyncHandler(async (req, res) => {\n  const user = await getUser(req.params.id); // Errors automatically caught\n  res.json(user);\n}));\n```\n\n### Result Type Pattern\n\n```typescript\n// Instead of throwing, return Result type\ntype Result<T, E = Error> =\n  | { success: true; value: T }\n  | { success: false; error: E };\n\nconst parseJSON = <T>(json: string): Result<T, string> => {\n  try {\n    const value = JSON.parse(json);\n    return { success: true, value };\n  } catch (error) {\n    return { success: false, error: 'Invalid JSON' };\n  }\n};\n\n// Usage\nconst result = parseJSON<User>(userJson);\n\nif (result.success) {\n  console.log('User:', result.value);\n} else {\n  console.error('Error:', result.error);\n}\n\n// Chainable Result\nclass Result<T, E> {\n  private constructor(\n    private readonly _success: boolean,\n    private readonly _value?: T,\n    private readonly _error?: E\n  ) {}\n\n  static ok<T, E>(value: T): Result<T, E> {\n    return new Result(true, value);\n  }\n\n  static err<T, E>(error: E): Result<T, E> {\n    return new Result(false, undefined, error);\n  }\n\n  isOk(): boolean {\n    return this._success;\n  }\n\n  isErr(): boolean {\n    return !this._success;\n  }\n\n  map<U>(fn: (value: T) => U): Result<U, E> {\n    if (this._success) {\n      return Result.ok(fn(this._value!));\n    }\n    return Result.err(this._error!);\n  }\n\n  flatMap<U>(fn: (value: T) => Result<U, E>): Result<U, E> {\n    if (this._success) {\n      return fn(this._value!);\n    }\n    return Result.err(this._error!);\n  }\n\n  unwrap(): T {\n    if (!this._success) {\n      throw new Error('Called unwrap on error result');\n    }\n    return this._value!;\n  }\n\n  unwrapOr(defaultValue: T): T {\n    return this._success ? this._value! : defaultValue;\n  }\n}\n```\n\n## Circuit Breaker Pattern\n\n### Basic Implementation\n\n```typescript\nenum CircuitState {\n  CLOSED = 'CLOSED',     // Normal operation\n  OPEN = 'OPEN',         // Failing, reject calls immediately\n  HALF_OPEN = 'HALF_OPEN' // Testing if service recovered\n}\n\nclass CircuitBreaker {\n  private state: CircuitState = CircuitState.CLOSED;\n  private failureCount = 0;\n  private successCount = 0;\n  private nextAttempt: number = Date.now();\n\n  constructor(\n    private readonly threshold: number = 5,        // Failures to trip\n    private readonly timeout: number = 60000,       // Time before retry (ms)\n    private readonly monitoringPeriod: number = 10000 // Reset period (ms)\n  ) {}\n\n  async execute<T>(operation: () => Promise<T>): Promise<T> {\n    if (this.state === CircuitState.OPEN) {\n      if (Date.now() < this.nextAttempt) {\n        throw new Error('Circuit breaker is OPEN');\n      }\n      this.state = CircuitState.HALF_OPEN;\n    }\n\n    try {\n      const result = await operation();\n      this.onSuccess();\n      return result;\n    } catch (error) {\n      this.onFailure();\n      throw error;\n    }\n  }\n\n  private onSuccess(): void {\n    this.failureCount = 0;\n\n    if (this.state === CircuitState.HALF_OPEN) {\n      this.state = CircuitState.CLOSED;\n      this.successCount = 0;\n    }\n  }\n\n  private onFailure(): void {\n    this.failureCount++;\n    this.successCount = 0;\n\n    if (this.failureCount >= this.threshold) {\n      this.state = CircuitState.OPEN;\n      this.nextAttempt = Date.now() + this.timeout;\n    }\n  }\n\n  getState(): CircuitState {\n    return this.state;\n  }\n}\n\n// Usage\nconst paymentBreaker = new CircuitBreaker(5, 60000);\n\nconst processPayment = async (amount: number) => {\n  try {\n    return await paymentBreaker.execute(() =>\n      paymentService.charge(amount)\n    );\n  } catch (error) {\n    if (error.message === 'Circuit breaker is OPEN') {\n      // Use fallback or queue for later\n      return await queuePayment(amount);\n    }\n    throw error;\n  }\n};\n```\n\n### Advanced Circuit Breaker\n\n```typescript\ninterface CircuitBreakerOptions {\n  failureThreshold: number;\n  successThreshold: number;\n  timeout: number;\n  onStateChange?: (state: CircuitState) => void;\n}\n\nclass AdvancedCircuitBreaker {\n  private state: CircuitState = CircuitState.CLOSED;\n  private failures: number[] = [];\n  private successes = 0;\n  private nextAttempt = 0;\n\n  constructor(private options: CircuitBreakerOptions) {}\n\n  async call<T>(fn: () => Promise<T>): Promise<T> {\n    if (this.state === CircuitState.OPEN) {\n      if (Date.now() < this.nextAttempt) {\n        throw new Error('Circuit breaker OPEN');\n      }\n      this.transitionTo(CircuitState.HALF_OPEN);\n    }\n\n    try {\n      const result = await fn();\n      this.onSuccess();\n      return result;\n    } catch (error) {\n      this.onFailure(error);\n      throw error;\n    }\n  }\n\n  private onSuccess(): void {\n    this.failures = [];\n\n    if (this.state === CircuitState.HALF_OPEN) {\n      this.successes++;\n      if (this.successes >= this.options.successThreshold) {\n        this.transitionTo(CircuitState.CLOSED);\n        this.successes = 0;\n      }\n    }\n  }\n\n  private onFailure(error: Error): void {\n    this.successes = 0;\n    this.failures.push(Date.now());\n\n    // Remove old failures outside window\n    const windowStart = Date.now() - 10000;\n    this.failures = this.failures.filter(t => t > windowStart);\n\n    if (this.failures.length >= this.options.failureThreshold) {\n      this.transitionTo(CircuitState.OPEN);\n      this.nextAttempt = Date.now() + this.options.timeout;\n    }\n  }\n\n  private transitionTo(newState: CircuitState): void {\n    const oldState = this.state;\n    this.state = newState;\n\n    if (this.options.onStateChange) {\n      this.options.onStateChange(newState);\n    }\n\n    console.log(`Circuit breaker: ${oldState} → ${newState}`);\n  }\n}\n```\n\n## Retry Pattern\n\n### Exponential Backoff\n\n```typescript\ninterface RetryOptions {\n  maxAttempts: number;\n  initialDelay: number;\n  maxDelay: number;\n  backoffMultiplier: number;\n  retryableErrors?: (error: Error) => boolean;\n}\n\nconst retry = async <T>(\n  operation: () => Promise<T>,\n  options: RetryOptions\n): Promise<T> => {\n  let lastError: Error;\n  let delay = options.initialDelay;\n\n  for (let attempt = 1; attempt <= options.maxAttempts; attempt++) {\n    try {\n      return await operation();\n    } catch (error) {\n      lastError = error as Error;\n\n      // Check if error is retryable\n      if (options.retryableErrors && !options.retryableErrors(lastError)) {\n        throw lastError;\n      }\n\n      if (attempt === options.maxAttempts) {\n        throw lastError;\n      }\n\n      console.log(`Attempt ${attempt} failed, retrying in ${delay}ms...`);\n\n      await sleep(delay);\n\n      // Exponential backoff\n      delay = Math.min(delay * options.backoffMultiplier, options.maxDelay);\n    }\n  }\n\n  throw lastError!;\n};\n\nconst sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\n// Usage\nconst fetchData = async (url: string) => {\n  return retry(\n    () => fetch(url).then(r => r.json()),\n    {\n      maxAttempts: 3,\n      initialDelay: 1000,\n      maxDelay: 10000,\n      backoffMultiplier: 2,\n      retryableErrors: (error) => {\n        // Retry on network errors, not on 4xx client errors\n        return error.message.includes('network') ||\n               error.message.includes('timeout');\n      }\n    }\n  );\n};\n```\n\n### Retry with Jitter\n\n```typescript\n// Adds randomness to prevent thundering herd\nconst retryWithJitter = async <T>(\n  operation: () => Promise<T>,\n  maxAttempts: number = 3\n): Promise<T> => {\n  for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n    try {\n      return await operation();\n    } catch (error) {\n      if (attempt === maxAttempts) throw error;\n\n      const baseDelay = Math.pow(2, attempt) * 1000;\n      const jitter = Math.random() * 1000;\n      const delay = baseDelay + jitter;\n\n      console.log(`Retry ${attempt}/${maxAttempts} after ${delay}ms`);\n      await sleep(delay);\n    }\n  }\n\n  throw new Error('Max retries exceeded');\n};\n```\n\n## Timeout Pattern\n\n### Request Timeout\n\n```typescript\nconst withTimeout = <T>(\n  promise: Promise<T>,\n  timeoutMs: number,\n  errorMessage: string = 'Operation timed out'\n): Promise<T> => {\n  return Promise.race([\n    promise,\n    new Promise<T>((_, reject) =>\n      setTimeout(() => reject(new Error(errorMessage)), timeoutMs)\n    )\n  ]);\n};\n\n// Usage\nconst fetchUserWithTimeout = async (id: string) => {\n  return withTimeout(\n    fetchUser(id),\n    5000,\n    'User fetch timed out after 5 seconds'\n  );\n};\n\n// With AbortController (modern approach)\nconst fetchWithTimeout = async (url: string, timeoutMs: number) => {\n  const controller = new AbortController();\n  const timeout = setTimeout(() => controller.abort(), timeoutMs);\n\n  try {\n    const response = await fetch(url, { signal: controller.signal });\n    return await response.json();\n  } finally {\n    clearTimeout(timeout);\n  }\n};\n```\n\n## Bulkhead Pattern\n\n### Isolate Resources\n\n```typescript\n// Prevent one failing operation from exhausting all resources\nclass Bulkhead {\n  private activeRequests = 0;\n\n  constructor(private readonly maxConcurrent: number) {}\n\n  async execute<T>(operation: () => Promise<T>): Promise<T> {\n    if (this.activeRequests >= this.maxConcurrent) {\n      throw new Error('Bulkhead limit reached');\n    }\n\n    this.activeRequests++;\n\n    try {\n      return await operation();\n    } finally {\n      this.activeRequests--;\n    }\n  }\n\n  getActiveCount(): number {\n    return this.activeRequests;\n  }\n}\n\n// Usage: Separate bulkheads for different services\nconst paymentBulkhead = new Bulkhead(5);\nconst emailBulkhead = new Bulkhead(10);\n\nconst processPayment = async (amount: number) => {\n  return paymentBulkhead.execute(() => paymentService.charge(amount));\n};\n\nconst sendEmail = async (to: string, content: string) => {\n  return emailBulkhead.execute(() => emailService.send(to, content));\n};\n```\n\n### Queue-Based Bulkhead\n\n```typescript\nclass QueuedBulkhead<T> {\n  private queue: Array<{\n    operation: () => Promise<T>;\n    resolve: (value: T) => void;\n    reject: (error: Error) => void;\n  }> = [];\n  private activeCount = 0;\n\n  constructor(private readonly maxConcurrent: number) {}\n\n  async execute(operation: () => Promise<T>): Promise<T> {\n    return new Promise((resolve, reject) => {\n      this.queue.push({ operation, resolve, reject });\n      this.processQueue();\n    });\n  }\n\n  private async processQueue(): Promise<void> {\n    if (this.activeCount >= this.maxConcurrent || this.queue.length === 0) {\n      return;\n    }\n\n    const { operation, resolve, reject } = this.queue.shift()!;\n    this.activeCount++;\n\n    try {\n      const result = await operation();\n      resolve(result);\n    } catch (error) {\n      reject(error as Error);\n    } finally {\n      this.activeCount--;\n      this.processQueue();\n    }\n  }\n}\n```\n\n## Graceful Degradation\n\n### Fallback Strategies\n\n```typescript\n// Fallback to cache when service unavailable\nconst getUserProfile = async (userId: string): Promise<UserProfile> => {\n  try {\n    return await userService.getProfile(userId);\n  } catch (error) {\n    console.warn('User service unavailable, using cached data');\n\n    const cached = await cache.get(`profile:${userId}`);\n    if (cached) {\n      return { ...cached, stale: true };\n    }\n\n    // Last resort: return minimal profile\n    return {\n      id: userId,\n      name: 'User',\n      stale: true,\n      limited: true\n    };\n  }\n};\n\n// Feature degradation\nconst search = async (query: string): Promise<SearchResults> => {\n  try {\n    // Try advanced search with ML ranking\n    return await advancedSearch(query);\n  } catch (error) {\n    console.warn('Advanced search failed, falling back to basic search');\n\n    try {\n      // Fallback to basic database search\n      return await basicSearch(query);\n    } catch (error) {\n      // Last resort: cached popular results\n      return await getCachedPopularResults();\n    }\n  }\n};\n```\n\n### Partial Responses\n\n```typescript\n// Return partial data instead of complete failure\nconst getDashboardData = async (userId: string) => {\n  const [userResult, ordersResult, statsResult] = await Promise.allSettled([\n    getUserData(userId),\n    getOrders(userId),\n    getStatistics(userId)\n  ]);\n\n  return {\n    user: userResult.status === 'fulfilled' ? userResult.value : null,\n    orders: ordersResult.status === 'fulfilled' ? ordersResult.value : [],\n    stats: statsResult.status === 'fulfilled' ? statsResult.value : null,\n    errors: {\n      user: userResult.status === 'rejected' ? userResult.reason.message : null,\n      orders: ordersResult.status === 'rejected' ? ordersResult.reason.message : null,\n      stats: statsResult.status === 'rejected' ? statsResult.reason.message : null\n    }\n  };\n};\n```\n\n## Health Checks\n\n### Service Health\n\n```typescript\ninterface HealthCheck {\n  status: 'healthy' | 'degraded' | 'unhealthy';\n  checks: Record<string, {\n    status: 'pass' | 'fail';\n    latency?: number;\n    error?: string;\n  }>;\n}\n\nconst checkHealth = async (): Promise<HealthCheck> => {\n  const checks = await Promise.allSettled([\n    checkDatabase(),\n    checkRedis(),\n    checkExternalAPI()\n  ]);\n\n  const results = {\n    database: checks[0],\n    redis: checks[1],\n    externalAPI: checks[2]\n  };\n\n  const failedChecks = Object.values(results).filter(r => r.status === 'rejected').length;\n\n  return {\n    status: failedChecks === 0 ? 'healthy' :\n            failedChecks < Object.keys(results).length ? 'degraded' :\n            'unhealthy',\n    checks: {\n      database: results.database.status === 'fulfilled'\n        ? { status: 'pass', latency: results.database.value }\n        : { status: 'fail', error: results.database.reason.message },\n      redis: results.redis.status === 'fulfilled'\n        ? { status: 'pass', latency: results.redis.value }\n        : { status: 'fail', error: results.redis.reason.message },\n      externalAPI: results.externalAPI.status === 'fulfilled'\n        ? { status: 'pass', latency: results.externalAPI.value }\n        : { status: 'fail', error: results.externalAPI.reason.message }\n    }\n  };\n};\n\nconst checkDatabase = async (): Promise<number> => {\n  const start = Date.now();\n  await db.query('SELECT 1');\n  return Date.now() - start;\n};\n```\n\n## Combining Resilience Patterns\n\n```typescript\nclass ResilientService {\n  private circuitBreaker: CircuitBreaker;\n  private bulkhead: Bulkhead;\n\n  constructor(\n    private readonly serviceName: string,\n    private readonly baseService: any\n  ) {\n    this.circuitBreaker = new CircuitBreaker(5, 60000);\n    this.bulkhead = new Bulkhead(10);\n  }\n\n  async call<T>(operation: () => Promise<T>): Promise<T> {\n    // Combine: Bulkhead → Circuit Breaker → Timeout → Retry\n    return this.bulkhead.execute(() =>\n      this.circuitBreaker.execute(() =>\n        withTimeout(\n          retry(operation, {\n            maxAttempts: 3,\n            initialDelay: 1000,\n            maxDelay: 5000,\n            backoffMultiplier: 2\n          }),\n          10000\n        )\n      )\n    );\n  }\n}\n\n// Usage\nconst paymentService = new ResilientService('payment', basePaymentService);\n\nconst processPayment = async (amount: number) => {\n  try {\n    return await paymentService.call(() =>\n      basePaymentService.charge(amount)\n    );\n  } catch (error) {\n    // All resilience patterns exhausted, use fallback\n    return await queuePaymentForLater(amount);\n  }\n};\n```\n\n## Anti-Patterns\n\n### ❌ Swallowing Errors\n\n```typescript\n// ❌ Silent failure\ntry {\n  await criticalOperation();\n} catch (error) {\n  // Error ignored - dangerous!\n}\n\n// ✅ Log and handle appropriately\ntry {\n  await criticalOperation();\n} catch (error) {\n  logger.error('Critical operation failed', { error });\n  metrics.increment('critical_operation_failure');\n  throw error; // Or handle gracefully\n}\n```\n\n### ❌ Generic Error Messages\n\n```typescript\n// ❌ Not actionable\nthrow new Error('Something went wrong');\n\n// ✅ Specific and actionable\nthrow new ValidationError('Email must be a valid email address', {\n  field: 'email',\n  value: userInput.email\n});\n```\n\n### ❌ Infinite Retries\n\n```typescript\n// ❌ Never give up\nwhile (true) {\n  try {\n    await operation();\n    break;\n  } catch (error) {\n    // Retry forever - will exhaust resources\n  }\n}\n\n// ✅ Maximum retry limit\nconst maxRetries = 3;\nfor (let i = 0; i < maxRetries; i++) {\n  try {\n    await operation();\n    break;\n  } catch (error) {\n    if (i === maxRetries - 1) throw error;\n  }\n}\n```\n\n## References\n\n- [Circuit Breaker](https://martinfowler.com/bliki/CircuitBreaker.html)\n- [Release It! - Design Patterns for Resilience](https://pragprog.com/titles/mnee2/release-it-second-edition/)\n- [Retry Pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/retry)\n- [Bulkhead Pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/bulkhead)\n",
    "original/development-practices/performance-optimization.md": "# Performance Optimization Best Practices\n\n## Profiling First\n\n### Never Optimize Without Measuring\n\n```typescript\n// ❌ Premature optimization\nconst processUsers = (users: User[]) => {\n  // Assuming this is slow without measuring\n  const cache = new Map();\n  users.forEach(user => {\n    if (!cache.has(user.id)) {\n      cache.set(user.id, expensiveCalculation(user));\n    }\n  });\n};\n\n// ✅ Profile first, then optimize\n// 1. Use profiling tools\nconsole.time('processUsers');\nconst result = processUsers(users);\nconsole.timeEnd('processUsers'); // processUsers: 2354ms\n\n// 2. Identify bottlenecks with profiler\n// Chrome DevTools → Performance tab\n// Node.js → node --prof app.js\n\n// 3. Optimize the actual bottleneck\nconst processUsers = (users: User[]) => {\n  // Found that database queries were the issue\n  return processUsersBatch(users); // Batch processing\n};\n```\n\n### Profiling Tools\n\n```typescript\n// Console timing\nconsole.time('operation');\nawait heavyOperation();\nconsole.timeEnd('operation');\n\n// Performance API (Browser)\nconst t0 = performance.now();\nawait operation();\nconst t1 = performance.now();\nconsole.log(`Operation took ${t1 - t0}ms`);\n\n// process.hrtime (Node.js)\nconst start = process.hrtime.bigint();\nawait operation();\nconst end = process.hrtime.bigint();\nconsole.log(`Duration: ${(end - start) / 1000000n}ms`);\n\n// Profiling decorator\nconst profile = (target: any, propertyKey: string, descriptor: PropertyDescriptor) => {\n  const originalMethod = descriptor.value;\n\n  descriptor.value = async function (...args: any[]) {\n    const start = Date.now();\n    const result = await originalMethod.apply(this, args);\n    const duration = Date.now() - start;\n\n    console.log(`${propertyKey} took ${duration}ms`);\n    return result;\n  };\n\n  return descriptor;\n};\n\nclass Service {\n  @profile\n  async processData(data: any[]) {\n    // Implementation\n  }\n}\n```\n\n## Database Optimization\n\n### N+1 Query Problem\n\n```typescript\n// ❌ N+1 queries (1 + N database calls)\nconst getOrdersWithCustomers = async () => {\n  const orders = await db.query('SELECT * FROM orders');\n\n  for (const order of orders) {\n    // N additional queries!\n    order.customer = await db.query('SELECT * FROM customers WHERE id = ?', [order.customerId]);\n  }\n\n  return orders;\n};\n\n// ✅ Use JOIN or eager loading\nconst getOrdersWithCustomers = async () => {\n  return db.query(`\n    SELECT\n      orders.*,\n      customers.name as customer_name,\n      customers.email as customer_email\n    FROM orders\n    JOIN customers ON orders.customer_id = customers.id\n  `);\n};\n\n// ✅ Using ORM with eager loading\nconst getOrdersWithCustomers = async () => {\n  return orderRepository.find({\n    relations: ['customer']\n  });\n};\n```\n\n### Query Optimization\n\n```typescript\n// ❌ Fetching unnecessary data\nconst getUserEmail = async (userId: string) => {\n  const user = await db.query('SELECT * FROM users WHERE id = ?', [userId]);\n  return user.email;\n};\n\n// ✅ Select only needed columns\nconst getUserEmail = async (userId: string) => {\n  const result = await db.query('SELECT email FROM users WHERE id = ?', [userId]);\n  return result.email;\n};\n\n// ❌ Multiple queries\nconst getOrderSummary = async (orderId: string) => {\n  const order = await db.query('SELECT * FROM orders WHERE id = ?', [orderId]);\n  const itemCount = await db.query('SELECT COUNT(*) FROM order_items WHERE order_id = ?', [orderId]);\n  const total = await db.query('SELECT SUM(price * quantity) FROM order_items WHERE order_id = ?', [orderId]);\n\n  return { order, itemCount, total };\n};\n\n// ✅ Single optimized query\nconst getOrderSummary = async (orderId: string) => {\n  return db.query(`\n    SELECT\n      o.*,\n      COUNT(oi.id) as item_count,\n      SUM(oi.price * oi.quantity) as total\n    FROM orders o\n    LEFT JOIN order_items oi ON o.id = oi.order_id\n    WHERE o.id = ?\n    GROUP BY o.id\n  `, [orderId]);\n};\n```\n\n### Indexing\n\n```sql\n-- ❌ No index on frequently queried column\nSELECT * FROM users WHERE email = 'user@example.com'; -- Full table scan\n\n-- ✅ Add index\nCREATE INDEX idx_users_email ON users(email);\n\n-- ✅ Composite index for multiple columns\nCREATE INDEX idx_orders_user_status ON orders(user_id, status);\n\n-- Query using composite index\nSELECT * FROM orders WHERE user_id = 123 AND status = 'pending';\n\n-- ✅ Partial index for specific conditions\nCREATE INDEX idx_active_users ON users(email) WHERE active = true;\n```\n\n### Database Connection Pooling\n\n```typescript\n// ❌ Creating new connection for each query\nconst getUser = async (id: string) => {\n  const connection = await createConnection(); // Expensive!\n  const user = await connection.query('SELECT * FROM users WHERE id = ?', [id]);\n  await connection.close();\n  return user;\n};\n\n// ✅ Use connection pool\nimport { Pool } from 'pg';\n\nconst pool = new Pool({\n  host: 'localhost',\n  database: 'mydb',\n  max: 20,        // Maximum connections\n  idleTimeoutMillis: 30000,\n  connectionTimeoutMillis: 2000,\n});\n\nconst getUser = async (id: string) => {\n  const client = await pool.connect();\n  try {\n    const result = await client.query('SELECT * FROM users WHERE id = $1', [id]);\n    return result.rows[0];\n  } finally {\n    client.release(); // Return to pool\n  }\n};\n```\n\n## Caching Strategies\n\n### In-Memory Caching\n\n```typescript\n// Simple in-memory cache\nclass Cache<T> {\n  private cache = new Map<string, { value: T; expiry: number }>();\n\n  set(key: string, value: T, ttlMs: number = 60000): void {\n    this.cache.set(key, {\n      value,\n      expiry: Date.now() + ttlMs\n    });\n  }\n\n  get(key: string): T | null {\n    const item = this.cache.get(key);\n\n    if (!item) return null;\n\n    if (Date.now() > item.expiry) {\n      this.cache.delete(key);\n      return null;\n    }\n\n    return item.value;\n  }\n\n  clear(): void {\n    this.cache.clear();\n  }\n}\n\n// Usage\nconst userCache = new Cache<User>();\n\nconst getUser = async (id: string): Promise<User> => {\n  const cached = userCache.get(id);\n  if (cached) return cached;\n\n  const user = await db.findUser(id);\n  userCache.set(id, user, 300000); // 5 minutes\n\n  return user;\n};\n```\n\n### HTTP Caching\n\n```typescript\nimport express from 'express';\n\n// Cache-Control headers\napp.get('/api/products', (req, res) => {\n  res.set('Cache-Control', 'public, max-age=300'); // Cache for 5 minutes\n\n  const products = getProducts();\n  res.json(products);\n});\n\n// ETag caching\napp.get('/api/user/:id', async (req, res) => {\n  const user = await getUser(req.params.id);\n\n  const etag = generateETag(user); // Hash of user data\n  res.set('ETag', etag);\n\n  // Check if client has current version\n  if (req.headers['if-none-match'] === etag) {\n    return res.status(304).end(); // Not Modified\n  }\n\n  res.json(user);\n});\n\n// Last-Modified caching\napp.get('/api/posts/:id', async (req, res) => {\n  const post = await getPost(req.params.id);\n\n  res.set('Last-Modified', post.updatedAt.toUTCString());\n\n  const ifModifiedSince = req.headers['if-modified-since'];\n  if (ifModifiedSince && new Date(ifModifiedSince) >= post.updatedAt) {\n    return res.status(304).end();\n  }\n\n  res.json(post);\n});\n```\n\n### Redis Caching\n\n```typescript\nimport Redis from 'ioredis';\n\nconst redis = new Redis();\n\nconst getCachedUser = async (id: string): Promise<User | null> => {\n  const cached = await redis.get(`user:${id}`);\n  if (cached) {\n    return JSON.parse(cached);\n  }\n\n  const user = await db.findUser(id);\n\n  // Cache for 5 minutes\n  await redis.setex(`user:${id}`, 300, JSON.stringify(user));\n\n  return user;\n};\n\n// Cache invalidation\nconst updateUser = async (id: string, data: Partial<User>) => {\n  const user = await db.updateUser(id, data);\n\n  // Invalidate cache\n  await redis.del(`user:${id}`);\n\n  return user;\n};\n\n// Cache-aside pattern\nconst getProduct = async (id: string): Promise<Product> => {\n  // Try cache first\n  const cached = await redis.get(`product:${id}`);\n  if (cached) return JSON.parse(cached);\n\n  // Cache miss: fetch from database\n  const product = await db.findProduct(id);\n\n  // Store in cache\n  await redis.setex(`product:${id}`, 600, JSON.stringify(product));\n\n  return product;\n};\n```\n\n### Memoization\n\n```typescript\n// Function result caching\nconst memoize = <T extends (...args: any[]) => any>(fn: T): T => {\n  const cache = new Map<string, ReturnType<T>>();\n\n  return ((...args: any[]) => {\n    const key = JSON.stringify(args);\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n\n    const result = fn(...args);\n    cache.set(key, result);\n\n    return result;\n  }) as T;\n};\n\n// Usage\nconst expensiveCalculation = memoize((n: number): number => {\n  console.log('Computing...');\n  let result = 0;\n  for (let i = 0; i < n * 1000000; i++) {\n    result += i;\n  }\n  return result;\n});\n\nexpensiveCalculation(100); // Computing... (takes time)\nexpensiveCalculation(100); // Instant (from cache)\n```\n\n## Algorithmic Optimization\n\n### Choose Right Data Structure\n\n```typescript\n// ❌ Using array for lookups (O(n))\nconst users: User[] = [];\nconst findUser = (id: string) => users.find(u => u.id === id); // Slow for large arrays\n\n// ✅ Use Map for O(1) lookups\nconst users = new Map<string, User>();\nconst findUser = (id: string) => users.get(id); // Fast\n\n// ❌ Checking existence in array\nconst hasPermission = (userId: string, permission: string) => {\n  const permissions = getUserPermissions(userId); // Returns string[]\n  return permissions.includes(permission); // O(n)\n};\n\n// ✅ Use Set for O(1) membership checks\nconst hasPermission = (userId: string, permission: string) => {\n  const permissions = getUserPermissions(userId); // Returns Set<string>\n  return permissions.has(permission); // O(1)\n};\n```\n\n### Reduce Complexity\n\n```typescript\n// ❌ Nested loops (O(n²))\nconst findDuplicates = (arr: number[]) => {\n  const duplicates = [];\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = i + 1; j < arr.length; j++) {\n      if (arr[i] === arr[j] && !duplicates.includes(arr[i])) {\n        duplicates.push(arr[i]);\n      }\n    }\n  }\n  return duplicates;\n};\n\n// ✅ Use Set (O(n))\nconst findDuplicates = (arr: number[]) => {\n  const seen = new Set<number>();\n  const duplicates = new Set<number>();\n\n  for (const num of arr) {\n    if (seen.has(num)) {\n      duplicates.add(num);\n    } else {\n      seen.add(num);\n    }\n  }\n\n  return Array.from(duplicates);\n};\n```\n\n## Frontend Performance\n\n### Lazy Loading\n\n```typescript\n// React lazy loading\nimport { lazy, Suspense } from 'react';\n\nconst HeavyComponent = lazy(() => import('./HeavyComponent'));\n\nconst App = () => (\n  <Suspense fallback={<div>Loading...</div>}>\n    <HeavyComponent />\n  </Suspense>\n);\n\n// Image lazy loading\n<img src=\"image.jpg\" loading=\"lazy\" alt=\"Description\" />\n\n// Route-based code splitting\nconst routes = [\n  {\n    path: '/dashboard',\n    component: lazy(() => import('./pages/Dashboard'))\n  },\n  {\n    path: '/profile',\n    component: lazy(() => import('./pages/Profile'))\n  }\n];\n```\n\n### Debouncing and Throttling\n\n```typescript\n// Debounce: Wait until user stops typing\nconst debounce = <T extends (...args: any[]) => any>(\n  fn: T,\n  delay: number\n): ((...args: Parameters<T>) => void) => {\n  let timeoutId: NodeJS.Timeout;\n\n  return (...args: Parameters<T>) => {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => fn(...args), delay);\n  };\n};\n\n// Usage: Search as user types\nconst searchUsers = debounce(async (query: string) => {\n  const results = await api.searchUsers(query);\n  updateUI(results);\n}, 300);\n\ninput.addEventListener('input', (e) => {\n  searchUsers(e.target.value);\n});\n\n// Throttle: Execute at most once per interval\nconst throttle = <T extends (...args: any[]) => any>(\n  fn: T,\n  limit: number\n): ((...args: Parameters<T>) => void) => {\n  let inThrottle: boolean;\n\n  return (...args: Parameters<T>) => {\n    if (!inThrottle) {\n      fn(...args);\n      inThrottle = true;\n      setTimeout(() => (inThrottle = false), limit);\n    }\n  };\n};\n\n// Usage: Scroll event\nconst handleScroll = throttle(() => {\n  console.log('Scroll position:', window.scrollY);\n}, 100);\n\nwindow.addEventListener('scroll', handleScroll);\n```\n\n### Virtual Scrolling\n\n```typescript\n// Render only visible items\nconst VirtualList = ({ items, itemHeight }: Props) => {\n  const [scrollTop, setScrollTop] = useState(0);\n  const containerHeight = 600;\n\n  const visibleStart = Math.floor(scrollTop / itemHeight);\n  const visibleEnd = Math.ceil((scrollTop + containerHeight) / itemHeight);\n\n  const visibleItems = items.slice(visibleStart, visibleEnd);\n\n  return (\n    <div\n      style={{ height: containerHeight, overflow: 'auto' }}\n      onScroll={(e) => setScrollTop(e.currentTarget.scrollTop)}\n    >\n      <div style={{ height: items.length * itemHeight, position: 'relative' }}>\n        {visibleItems.map((item, index) => (\n          <div\n            key={visibleStart + index}\n            style={{\n              position: 'absolute',\n              top: (visibleStart + index) * itemHeight,\n              height: itemHeight\n            }}\n          >\n            {item.content}\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n};\n```\n\n## Asynchronous Optimization\n\n### Parallel Execution\n\n```typescript\n// ❌ Sequential (slow)\nconst getUserData = async (userId: string) => {\n  const user = await fetchUser(userId);           // 100ms\n  const posts = await fetchPosts(userId);         // 150ms\n  const comments = await fetchComments(userId);   // 120ms\n\n  return { user, posts, comments }; // Total: 370ms\n};\n\n// ✅ Parallel (fast)\nconst getUserData = async (userId: string) => {\n  const [user, posts, comments] = await Promise.all([\n    fetchUser(userId),\n    fetchPosts(userId),\n    fetchComments(userId)\n  ]);\n\n  return { user, posts, comments }; // Total: 150ms (longest operation)\n};\n\n// ✅ Partial parallel with dependencies\nconst getOrderDetails = async (orderId: string) => {\n  const order = await fetchOrder(orderId); // Must fetch first\n\n  const [customer, items, shipping] = await Promise.all([\n    fetchCustomer(order.customerId),\n    fetchOrderItems(orderId),\n    fetchShippingInfo(orderId)\n  ]);\n\n  return { order, customer, items, shipping };\n};\n```\n\n### Batch Processing\n\n```typescript\n// ❌ Processing one at a time\nconst processUsers = async (userIds: string[]) => {\n  for (const id of userIds) {\n    await updateUser(id); // Slow for large lists\n  }\n};\n\n// ✅ Batch processing\nconst processUsers = async (userIds: string[]) => {\n  const BATCH_SIZE = 50;\n\n  for (let i = 0; i < userIds.length; i += BATCH_SIZE) {\n    const batch = userIds.slice(i, i + BATCH_SIZE);\n\n    await Promise.all(\n      batch.map(id => updateUser(id))\n    );\n  }\n};\n\n// ✅ Bulk database operations\nconst createUsers = async (users: User[]) => {\n  // Instead of individual INSERTs\n  await db.query(`\n    INSERT INTO users (name, email)\n    VALUES ${users.map(() => '(?, ?)').join(', ')}\n  `, users.flatMap(u => [u.name, u.email]));\n};\n```\n\n## Resource Optimization\n\n### Memory Management\n\n```typescript\n// ❌ Memory leak: Event listeners not removed\nclass Component {\n  constructor() {\n    window.addEventListener('resize', this.handleResize);\n  }\n\n  handleResize = () => {\n    // ...\n  };\n\n  // Component destroyed but listener remains!\n}\n\n// ✅ Clean up resources\nclass Component {\n  constructor() {\n    window.addEventListener('resize', this.handleResize);\n  }\n\n  handleResize = () => {\n    // ...\n  };\n\n  destroy() {\n    window.removeEventListener('resize', this.handleResize);\n  }\n}\n\n// ✅ Process large files in streams\nimport { createReadStream } from 'fs';\nimport { createInterface } from 'readline';\n\nconst processLargeFile = async (filePath: string) => {\n  const fileStream = createReadStream(filePath);\n  const rl = createInterface({\n    input: fileStream,\n    crlfDelay: Infinity\n  });\n\n  for await (const line of rl) {\n    processLine(line); // Process one line at a time\n  }\n};\n```\n\n### Compression\n\n```typescript\nimport compression from 'compression';\nimport express from 'express';\n\nconst app = express();\n\n// Enable gzip compression\napp.use(compression({\n  filter: (req, res) => {\n    if (req.headers['x-no-compression']) {\n      return false;\n    }\n    return compression.filter(req, res);\n  },\n  level: 6 // Compression level (0-9)\n}));\n\n// Compress specific responses\napp.get('/api/large-data', (req, res) => {\n  const data = getLargeDataset();\n\n  res.set('Content-Type', 'application/json');\n  res.set('Content-Encoding', 'gzip');\n\n  res.json(data); // Automatically compressed\n});\n```\n\n## Monitoring and Metrics\n\n### Performance Metrics\n\n```typescript\n// Track key metrics\nclass PerformanceMonitor {\n  private metrics = new Map<string, number[]>();\n\n  recordLatency(operation: string, durationMs: number): void {\n    if (!this.metrics.has(operation)) {\n      this.metrics.set(operation, []);\n    }\n    this.metrics.get(operation)!.push(durationMs);\n  }\n\n  getStats(operation: string) {\n    const values = this.metrics.get(operation) || [];\n    const sorted = values.sort((a, b) => a - b);\n\n    return {\n      count: values.length,\n      mean: values.reduce((a, b) => a + b, 0) / values.length,\n      p50: sorted[Math.floor(sorted.length * 0.5)],\n      p95: sorted[Math.floor(sorted.length * 0.95)],\n      p99: sorted[Math.floor(sorted.length * 0.99)],\n      max: sorted[sorted.length - 1]\n    };\n  }\n}\n\n// Usage\nconst monitor = new PerformanceMonitor();\n\nconst withMonitoring = async <T>(operation: string, fn: () => Promise<T>): Promise<T> => {\n  const start = Date.now();\n  try {\n    return await fn();\n  } finally {\n    monitor.recordLatency(operation, Date.now() - start);\n  }\n};\n\n// Track performance\nawait withMonitoring('getUserData', () => getUserData('123'));\n\n// View stats\nconsole.log(monitor.getStats('getUserData'));\n// { count: 1000, mean: 45, p50: 42, p95: 78, p99: 120, max: 250 }\n```\n\n## Anti-Patterns\n\n### ❌ Premature Optimization\n\n```typescript\n// Don't optimize before measuring\n// \"Premature optimization is the root of all evil\" - Donald Knuth\n\n// Write clear code first\nconst sum = (numbers: number[]) => numbers.reduce((a, b) => a + b, 0);\n\n// Only optimize if proven to be a bottleneck\n```\n\n### ❌ Over-Caching\n\n```typescript\n// Caching everything wastes memory\ncache.set('trivial-calculation', 2 + 2); // Don't cache simple operations\n```\n\n### ❌ Ignoring Cache Invalidation\n\n```typescript\n// Stale data from never-expiring cache\ncache.set('user-data', user); // No TTL, no invalidation strategy\n```\n\n## References\n\n- [Web Performance](https://web.dev/performance/)\n- [Node.js Performance Best Practices](https://nodejs.org/en/docs/guides/simple-profiling/)\n- [Database Indexing](https://use-the-index-luke.com/)\n- [Chrome DevTools Performance](https://developer.chrome.com/docs/devtools/performance/)\n",
    "original/development-practices/refactoring-patterns.md": "# Refactoring Patterns & Best Practices\n\n## When to Refactor\n\n### Opportunistic Refactoring\n\n**Camp Site Rule**: Always leave code cleaner than you found it.\n\n```typescript\n// When you see this while adding a feature\nconst processOrder = (order) => {\n  if (order.type === 'standard') {\n    const total = order.items.reduce((sum, item) => sum + item.price, 0);\n    if (total > 100) {\n      return total * 0.9;\n    }\n    return total;\n  } else if (order.type === 'premium') {\n    const total = order.items.reduce((sum, item) => sum + item.price, 0);\n    return total * 0.85;\n  }\n  // ...\n};\n\n// Refactor before adding your feature\nconst calculateTotal = (items: OrderItem[]): number => {\n  return items.reduce((sum, item) => sum + item.price, 0);\n};\n\nconst applyDiscount = (total: number, orderType: string): number => {\n  const discounts = {\n    standard: total > 100 ? 0.9 : 1.0,\n    premium: 0.85\n  };\n  return total * (discounts[orderType] || 1.0);\n};\n\nconst processOrder = (order: Order): number => {\n  const total = calculateTotal(order.items);\n  return applyDiscount(total, order.type);\n};\n```\n\n### Preparatory Refactoring\n\nRefactor to make the next change easier.\n\n```typescript\n// Current code\nclass ReportGenerator {\n  generate(data: any[]) {\n    const html = '<html><body>';\n    data.forEach(item => {\n      html += `<p>${item.name}: ${item.value}</p>`;\n    });\n    html += '</body></html>';\n    return html;\n  }\n}\n\n// You need to add PDF export...\n// First refactor to separate formatting from generation\nclass ReportGenerator {\n  private formatAsHTML(data: any[]): string {\n    let html = '<html><body>';\n    data.forEach(item => {\n      html += `<p>${item.name}: ${item.value}</p>`;\n    });\n    html += '</body></html>';\n    return html;\n  }\n\n  generate(data: any[], format: 'html' | 'pdf'): string {\n    if (format === 'html') {\n      return this.formatAsHTML(data);\n    }\n    // Now adding PDF is easy\n    return this.formatAsPDF(data);\n  }\n}\n```\n\n## Code Smells\n\n### Long Method\n\n```typescript\n// ❌ Long method (hard to understand)\nconst processUserRegistration = async (userData: any) => {\n  // Validation\n  if (!userData.email) throw new Error('Email required');\n  if (!userData.email.includes('@')) throw new Error('Invalid email');\n  if (!userData.password) throw new Error('Password required');\n  if (userData.password.length < 8) throw new Error('Password too short');\n\n  // Check existing user\n  const existing = await db.query('SELECT * FROM users WHERE email = ?', [userData.email]);\n  if (existing.length > 0) throw new Error('Email already exists');\n\n  // Hash password\n  const salt = await bcrypt.genSalt(10);\n  const hash = await bcrypt.hash(userData.password, salt);\n\n  // Create user\n  const user = await db.query('INSERT INTO users (email, password) VALUES (?, ?)', [\n    userData.email,\n    hash\n  ]);\n\n  // Send email\n  const transporter = nodemailer.createTransport({ /* config */ });\n  await transporter.sendMail({\n    to: userData.email,\n    subject: 'Welcome',\n    html: '<h1>Welcome!</h1>'\n  });\n\n  return user;\n};\n\n// ✅ Extract Method refactoring\nconst validateUserData = (userData: UserData): void => {\n  if (!userData.email) throw new Error('Email required');\n  if (!userData.email.includes('@')) throw new Error('Invalid email');\n  if (!userData.password) throw new Error('Password required');\n  if (userData.password.length < 8) throw new Error('Password too short');\n};\n\nconst checkEmailAvailability = async (email: string): Promise<void> => {\n  const existing = await db.query('SELECT * FROM users WHERE email = ?', [email]);\n  if (existing.length > 0) throw new Error('Email already exists');\n};\n\nconst hashPassword = async (password: string): Promise<string> => {\n  const salt = await bcrypt.genSalt(10);\n  return bcrypt.hash(password, salt);\n};\n\nconst sendWelcomeEmail = async (email: string): Promise<void> => {\n  const transporter = nodemailer.createTransport({ /* config */ });\n  await transporter.sendMail({\n    to: email,\n    subject: 'Welcome',\n    html: '<h1>Welcome!</h1>'\n  });\n};\n\nconst processUserRegistration = async (userData: UserData) => {\n  validateUserData(userData);\n  await checkEmailAvailability(userData.email);\n\n  const passwordHash = await hashPassword(userData.password);\n  const user = await db.query('INSERT INTO users (email, password) VALUES (?, ?)', [\n    userData.email,\n    passwordHash\n  ]);\n\n  await sendWelcomeEmail(userData.email);\n\n  return user;\n};\n```\n\n### Large Class\n\n```typescript\n// ❌ God object doing everything\nclass UserManager {\n  createUser(data: any) { /* ... */ }\n  updateUser(id: string, data: any) { /* ... */ }\n  deleteUser(id: string) { /* ... */ }\n  validateEmail(email: string) { /* ... */ }\n  hashPassword(password: string) { /* ... */ }\n  sendWelcomeEmail(email: string) { /* ... */ }\n  sendPasswordResetEmail(email: string) { /* ... */ }\n  generateToken(userId: string) { /* ... */ }\n  verifyToken(token: string) { /* ... */ }\n  logActivity(userId: string, action: string) { /* ... */ }\n  checkPermissions(userId: string, action: string) { /* ... */ }\n  // 50 more methods...\n}\n\n// ✅ Extract Class refactoring\nclass UserRepository {\n  create(data: UserData) { /* ... */ }\n  update(id: string, data: Partial<UserData>) { /* ... */ }\n  delete(id: string) { /* ... */ }\n  findById(id: string) { /* ... */ }\n}\n\nclass UserValidator {\n  validateEmail(email: string) { /* ... */ }\n  validatePassword(password: string) { /* ... */ }\n}\n\nclass PasswordService {\n  hash(password: string) { /* ... */ }\n  verify(password: string, hash: string) { /* ... */ }\n}\n\nclass EmailService {\n  sendWelcome(email: string) { /* ... */ }\n  sendPasswordReset(email: string) { /* ... */ }\n}\n\nclass AuthService {\n  generateToken(userId: string) { /* ... */ }\n  verifyToken(token: string) { /* ... */ }\n}\n\nclass PermissionService {\n  check(userId: string, action: string) { /* ... */ }\n}\n\n// Coordinating service\nclass UserService {\n  constructor(\n    private userRepo: UserRepository,\n    private validator: UserValidator,\n    private passwordService: PasswordService,\n    private emailService: EmailService\n  ) {}\n\n  async register(data: UserData) {\n    this.validator.validateEmail(data.email);\n    this.validator.validatePassword(data.password);\n\n    const hash = await this.passwordService.hash(data.password);\n    const user = await this.userRepo.create({ ...data, password: hash });\n\n    await this.emailService.sendWelcome(user.email);\n\n    return user;\n  }\n}\n```\n\n### Duplicate Code\n\n```typescript\n// ❌ Duplicated logic\nconst calculateOrderTotal = (order: Order) => {\n  let total = 0;\n  order.items.forEach(item => {\n    total += item.price * item.quantity;\n  });\n  return total;\n};\n\nconst calculateCartTotal = (cart: Cart) => {\n  let total = 0;\n  cart.items.forEach(item => {\n    total += item.price * item.quantity;\n  });\n  return total;\n};\n\nconst calculateInvoiceTotal = (invoice: Invoice) => {\n  let total = 0;\n  invoice.items.forEach(item => {\n    total += item.price * item.quantity;\n  });\n  return total;\n};\n\n// ✅ Extract common function\nconst calculateItemsTotal = (items: LineItem[]): number => {\n  return items.reduce((total, item) => total + item.price * item.quantity, 0);\n};\n\nconst calculateOrderTotal = (order: Order) => calculateItemsTotal(order.items);\nconst calculateCartTotal = (cart: Cart) => calculateItemsTotal(cart.items);\nconst calculateInvoiceTotal = (invoice: Invoice) => calculateItemsTotal(invoice.items);\n```\n\n### Data Clumps\n\n```typescript\n// ❌ Data clumps (parameters always together)\nconst createUser = (\n  firstName: string,\n  lastName: string,\n  street: string,\n  city: string,\n  state: string,\n  zipCode: string\n) => {\n  // ...\n};\n\nconst updateAddress = (\n  userId: string,\n  street: string,\n  city: string,\n  state: string,\n  zipCode: string\n) => {\n  // ...\n};\n\n// ✅ Introduce Parameter Object\ninterface Address {\n  street: string;\n  city: string;\n  state: string;\n  zipCode: string;\n}\n\ninterface UserName {\n  firstName: string;\n  lastName: string;\n}\n\nconst createUser = (name: UserName, address: Address) => {\n  // ...\n};\n\nconst updateAddress = (userId: string, address: Address) => {\n  // ...\n};\n```\n\n### Primitive Obsession\n\n```typescript\n// ❌ Using primitives for domain concepts\nconst sendEmail = (to: string, subject: string, body: string) => {\n  // What if 'to' is invalid? Type system doesn't help\n};\n\nconst chargeCard = (amount: number, currency: string) => {\n  // What if currency and amount don't match?\n};\n\n// ✅ Introduce Value Objects\nclass Email {\n  private constructor(private readonly value: string) {\n    if (!value.includes('@')) {\n      throw new Error('Invalid email');\n    }\n  }\n\n  static create(value: string): Email {\n    return new Email(value);\n  }\n\n  toString(): string {\n    return this.value;\n  }\n}\n\nclass Money {\n  private constructor(\n    private readonly amount: number,\n    private readonly currency: string\n  ) {\n    if (amount < 0) throw new Error('Amount cannot be negative');\n  }\n\n  static create(amount: number, currency: string): Money {\n    return new Money(amount, currency);\n  }\n\n  add(other: Money): Money {\n    if (this.currency !== other.currency) {\n      throw new Error('Cannot add different currencies');\n    }\n    return new Money(this.amount + other.amount, this.currency);\n  }\n\n  getAmount(): number {\n    return this.amount;\n  }\n\n  getCurrency(): string {\n    return this.currency;\n  }\n}\n\nconst sendEmail = (to: Email, subject: string, body: string) => {\n  // Type safety enforced\n};\n\nconst chargeCard = (amount: Money) => {\n  // Currency mismatch caught at compile time\n};\n```\n\n### Long Parameter List\n\n```typescript\n// ❌ Long parameter list\nconst createOrder = (\n  userId: string,\n  items: Item[],\n  shippingAddress: Address,\n  billingAddress: Address,\n  paymentMethod: string,\n  shippingMethod: string,\n  discountCode: string,\n  giftWrap: boolean,\n  giftMessage: string,\n  priority: boolean\n) => {\n  // Hard to remember parameter order\n};\n\n// ✅ Introduce Parameter Object\ninterface CreateOrderParams {\n  userId: string;\n  items: Item[];\n  shippingAddress: Address;\n  billingAddress: Address;\n  paymentMethod: string;\n  shippingMethod: string;\n  discountCode?: string;\n  gift?: {\n    wrap: boolean;\n    message: string;\n  };\n  priority?: boolean;\n}\n\nconst createOrder = (params: CreateOrderParams) => {\n  // Clear, self-documenting\n};\n\n// Usage\ncreateOrder({\n  userId: '123',\n  items: [...],\n  shippingAddress: {...},\n  billingAddress: {...},\n  paymentMethod: 'credit_card',\n  shippingMethod: 'express',\n  priority: true\n});\n```\n\n## Refactoring Techniques\n\n### Extract Function\n\n```typescript\n// Before\nconst printOwing = (invoice: Invoice) => {\n  let outstanding = 0;\n\n  console.log('***********************');\n  console.log('**** Customer Owes ****');\n  console.log('***********************');\n\n  for (const order of invoice.orders) {\n    outstanding += order.amount;\n  }\n\n  console.log(`Name: ${invoice.customer}`);\n  console.log(`Amount: ${outstanding}`);\n};\n\n// After\nconst printBanner = () => {\n  console.log('***********************');\n  console.log('**** Customer Owes ****');\n  console.log('***********************');\n};\n\nconst calculateOutstanding = (orders: Order[]): number => {\n  return orders.reduce((sum, order) => sum + order.amount, 0);\n};\n\nconst printDetails = (customer: string, outstanding: number) => {\n  console.log(`Name: ${customer}`);\n  console.log(`Amount: ${outstanding}`);\n};\n\nconst printOwing = (invoice: Invoice) => {\n  printBanner();\n  const outstanding = calculateOutstanding(invoice.orders);\n  printDetails(invoice.customer, outstanding);\n};\n```\n\n### Inline Function\n\n```typescript\n// Before (unnecessary indirection)\nconst getRating = (driver: Driver): number => {\n  return moreThanFiveLateDeliveries(driver) ? 2 : 1;\n};\n\nconst moreThanFiveLateDeliveries = (driver: Driver): boolean => {\n  return driver.numberOfLateDeliveries > 5;\n};\n\n// After\nconst getRating = (driver: Driver): number => {\n  return driver.numberOfLateDeliveries > 5 ? 2 : 1;\n};\n```\n\n### Replace Conditional with Polymorphism\n\n```typescript\n// ❌ Type switching\nclass Bird {\n  constructor(public type: string, public numberOfCoconuts: number, public voltage: number) {}\n\n  get speed(): number {\n    switch (this.type) {\n      case 'European':\n        return this.baseSpeed;\n      case 'African':\n        return this.baseSpeed - this.loadFactor * this.numberOfCoconuts;\n      case 'Norwegian':\n        return this.isNailed ? 0 : this.baseSpeed * this.voltage;\n    }\n  }\n\n  get baseSpeed() {\n    return 10;\n  }\n\n  get loadFactor() {\n    return 2;\n  }\n\n  get isNailed() {\n    return this.voltage > 100;\n  }\n}\n\n// ✅ Polymorphism\nabstract class Bird {\n  abstract get speed(): number;\n  protected get baseSpeed() {\n    return 10;\n  }\n}\n\nclass EuropeanBird extends Bird {\n  get speed(): number {\n    return this.baseSpeed;\n  }\n}\n\nclass AfricanBird extends Bird {\n  constructor(private numberOfCoconuts: number) {\n    super();\n  }\n\n  get speed(): number {\n    return this.baseSpeed - this.loadFactor * this.numberOfCoconuts;\n  }\n\n  private get loadFactor() {\n    return 2;\n  }\n}\n\nclass NorwegianBird extends Bird {\n  constructor(private voltage: number) {\n    super();\n  }\n\n  get speed(): number {\n    return this.isNailed ? 0 : this.baseSpeed * this.voltage;\n  }\n\n  private get isNailed() {\n    return this.voltage > 100;\n  }\n}\n```\n\n### Replace Loop with Pipeline\n\n```typescript\n// Before\nconst names: string[] = [];\nfor (const person of people) {\n  if (person.age >= 18) {\n    names.push(person.name);\n  }\n}\n\n// After\nconst names = people\n  .filter(person => person.age >= 18)\n  .map(person => person.name);\n\n// More complex example\n// Before\nconst result = [];\nfor (const order of orders) {\n  if (order.status === 'completed') {\n    let total = 0;\n    for (const item of order.items) {\n      total += item.price * item.quantity;\n    }\n    if (total > 100) {\n      result.push({\n        orderId: order.id,\n        total: total\n      });\n    }\n  }\n}\n\n// After\nconst result = orders\n  .filter(order => order.status === 'completed')\n  .map(order => ({\n    orderId: order.id,\n    total: order.items.reduce((sum, item) => sum + item.price * item.quantity, 0)\n  }))\n  .filter(order => order.total > 100);\n```\n\n### Decompose Conditional\n\n```typescript\n// Before\nif (date.before(SUMMER_START) || date.after(SUMMER_END)) {\n  charge = quantity * winterRate + winterServiceCharge;\n} else {\n  charge = quantity * summerRate;\n}\n\n// After\nconst isWinter = (date: Date): boolean => {\n  return date.before(SUMMER_START) || date.after(SUMMER_END);\n};\n\nconst winterCharge = (quantity: number): number => {\n  return quantity * winterRate + winterServiceCharge;\n};\n\nconst summerCharge = (quantity: number): number => {\n  return quantity * summerRate;\n};\n\nconst charge = isWinter(date)\n  ? winterCharge(quantity)\n  : summerCharge(quantity);\n```\n\n### Move Function\n\n```typescript\n// Before (function in wrong class)\nclass Account {\n  overdraftCharge(): number {\n    if (this.type === 'Premium') {\n      return 10;\n    } else {\n      return 25;\n    }\n  }\n}\n\n// After (function moved to appropriate class)\nclass AccountType {\n  overdraftCharge(): number {\n    return this.isPremium ? 10 : 25;\n  }\n}\n\nclass Account {\n  constructor(private accountType: AccountType) {}\n\n  overdraftCharge(): number {\n    return this.accountType.overdraftCharge();\n  }\n}\n```\n\n### Replace Magic Number with Named Constant\n\n```typescript\n// Before\nconst potentialEnergy = (mass: number, height: number): number => {\n  return mass * 9.81 * height;\n};\n\nif (user.age < 18) {\n  // Can't purchase\n}\n\n// After\nconst GRAVITATIONAL_CONSTANT = 9.81;\nconst MINIMUM_AGE = 18;\n\nconst potentialEnergy = (mass: number, height: number): number => {\n  return mass * GRAVITATIONAL_CONSTANT * height;\n};\n\nif (user.age < MINIMUM_AGE) {\n  // Can't purchase\n}\n```\n\n### Encapsulate Collection\n\n```typescript\n// ❌ Direct access to collection\nclass Course {\n  constructor(public students: Student[]) {}\n}\n\nconst course = new Course([]);\ncourse.students.push(new Student()); // Direct manipulation\n\n// ✅ Encapsulated collection\nclass Course {\n  private students: Student[] = [];\n\n  addStudent(student: Student): void {\n    this.students.push(student);\n  }\n\n  removeStudent(student: Student): void {\n    const index = this.students.indexOf(student);\n    if (index !== -1) {\n      this.students.splice(index, 1);\n    }\n  }\n\n  getStudents(): readonly Student[] {\n    return Object.freeze([...this.students]); // Return copy\n  }\n\n  get numberOfStudents(): number {\n    return this.students.length;\n  }\n}\n```\n\n## Refactoring Best Practices\n\n### Small Steps\n\n```typescript\n// ✅ Refactor in tiny, testable increments\n// Step 1: Extract variable\nconst price = order.quantity * order.itemPrice;\nconst discount = Math.max(0, order.quantity - 500) * order.itemPrice * 0.05;\nconst shipping = Math.min(price * 0.1, 100);\nreturn price - discount + shipping;\n\n// Step 2: Extract functions\nconst basePrice = (order) => order.quantity * order.itemPrice;\nconst quantityDiscount = (order) => Math.max(0, order.quantity - 500) * order.itemPrice * 0.05;\nconst shipping = (order) => Math.min(basePrice(order) * 0.1, 100);\n\nreturn basePrice(order) - quantityDiscount(order) + shipping(order);\n\n// Step 3: Create class\nclass PriceCalculator {\n  constructor(private order: Order) {}\n\n  get basePrice() {\n    return this.order.quantity * this.order.itemPrice;\n  }\n\n  get quantityDiscount() {\n    return Math.max(0, this.order.quantity - 500) * this.order.itemPrice * 0.05;\n  }\n\n  get shipping() {\n    return Math.min(this.basePrice * 0.1, 100);\n  }\n\n  get total() {\n    return this.basePrice - this.quantityDiscount + this.shipping;\n  }\n}\n```\n\n### Test Before and After\n\n```typescript\n// Always have tests before refactoring\ndescribe('PriceCalculator', () => {\n  it('should calculate correct total', () => {\n    const order = { quantity: 600, itemPrice: 10 };\n    const calculator = new PriceCalculator(order);\n\n    expect(calculator.total).toBe(6050); // 6000 - 50 + 100\n  });\n\n  it('should apply no discount for small orders', () => {\n    const order = { quantity: 100, itemPrice: 10 };\n    const calculator = new PriceCalculator(order);\n\n    expect(calculator.quantityDiscount).toBe(0);\n  });\n});\n\n// Run tests: All pass ✓\n// Refactor\n// Run tests again: All pass ✓\n```\n\n### Separate Structural from Behavioral Changes\n\n```bash\n# ✅ Good commit history\ncommit abc123: Move calculatePrice to PriceService (structural)\ncommit def456: Add tax calculation to price (behavioral)\n\n# ❌ Bad commit history\ncommit xyz789: Move calculatePrice and fix tax bug\n# Can't tell what broke if this commit causes issues\n```\n\n### Don't Refactor and Add Features Simultaneously\n\n```typescript\n// ❌ Mixing refactoring with feature addition\nconst processOrder = (order: Order) => {\n  // Refactoring old code\n  const total = calculateTotal(order.items);\n\n  // Adding new feature\n  if (order.hasLoyaltyCard) {\n    total = applyLoyaltyDiscount(total);\n  }\n\n  return total;\n};\n\n// ✅ Separate commits\n// Commit 1: Refactor processOrder to use calculateTotal\n// Commit 2: Add loyalty card discount feature\n```\n\n## When Not to Refactor\n\n### Code You Don't Need to Modify\n\nIf code works and you're not changing it, leave it alone unless it's actively causing problems.\n\n### Code You're About to Delete\n\nDon't refactor code that's scheduled for removal.\n\n### When You Don't Understand the Domain\n\nRefactoring requires understanding why code exists. Learn first, refactor second.\n\n### When Tests Are Missing\n\nAdd tests first, then refactor with confidence.\n\n## References\n\n- [Refactoring Catalog](https://refactoring.com/catalog/)\n- [Code Smell](https://martinfowler.com/bliki/CodeSmell.html)\n- [Opportunistic Refactoring](https://martinfowler.com/bliki/OpportunisticRefactoring.html)\n- [Refactoring: This Class is Too Large](https://martinfowler.com/articles/class-too-large.html)\n- [Parallel Change](https://martinfowler.com/bliki/ParallelChange.html)\n",
    "original/development-practices/rest-api-design.md": "# REST API Design Guidelines\n\n## Overview\n\nRESTful API design is an architectural approach that provides a standardized way to build web services. Poor API design creates technical debt, frustrates developers, and makes systems harder to maintain. These guidelines ensure APIs are intuitive, consistent, and maintainable.\n\n## Core Principles\n\n### 1. Resource-Oriented Design\n\n**APIs are interfaces that other developers (including future you) will have to work with.**\n\nThink in terms of **resources** (nouns - entities and their relationships) rather than **actions** (verbs - operations).\n\n✅ **Good (Resource-Oriented):**\n```\nGET    /api/v1/books\nPOST   /api/v1/books\nGET    /api/v1/books/123\nPUT    /api/v1/books/123\nDELETE /api/v1/books/123\n```\n\n❌ **Bad (Action-Oriented):**\n```\nPOST /api/v1/createBook\nGET  /api/v1/getBookById/123\nPOST /api/v1/updateBook/123\nPOST /api/v1/deleteBook/123\n```\n\n### 2. Use Nouns, Never Verbs in URLs\n\n**The HTTP method conveys the action. The URL describes what exists.**\n\n| ❌ Anti-pattern | ✅ Correct |\n|-----------------|-----------|\n| `POST /api/v1/createBook` | `POST /api/v1/books` |\n| `GET /api/v1/getBookById/123` | `GET /api/v1/books/123` |\n| `POST /api/v1/updateBook/123` | `PUT /api/v1/books/123` |\n| `DELETE /api/v1/removeBook/123` | `DELETE /api/v1/books/123` |\n| `GET /api/v1/fetchUserOrders` | `GET /api/v1/orders?userId=123` |\n\n### 3. Plural Nouns for Collections\n\n**Always use plural nouns for collections to eliminate ambiguity.**\n\n✅ **Good:**\n```\nGET /api/v1/books           # Collection of books\nGET /api/v1/books/123       # Single book from books collection\nGET /api/v1/authors         # Collection of authors\nGET /api/v1/authors/456     # Single author\n```\n\n❌ **Bad:**\n```\nGET /api/v1/book            # Unclear: one book or all books?\nGET /api/v1/book/123        # Inconsistent\n```\n\n---\n\n## HTTP Methods - Semantic Meaning\n\nEach HTTP method has a specific purpose and guarantees:\n\n### GET - Read Only\n- **Purpose:** Retrieve resources\n- **Guarantees:** Safe (no side effects), idempotent\n- **Response:** Resource representation\n\n```typescript\n// Get collection\nGET /api/v1/books\nResponse: { data: Book[], pagination: {...} }\n\n// Get single resource\nGET /api/v1/books/123\nResponse: { data: Book }\n```\n\n### POST - Create\n- **Purpose:** Create new resource or complex operations\n- **Guarantees:** Not idempotent (creates new resource each time)\n- **Response:** 201 Created with Location header\n\n```typescript\nPOST /api/v1/books\nBody: { title: \"The Hobbit\", author: \"J.R.R. Tolkien\" }\nResponse: 201 Created\nLocation: /api/v1/books/123\nBody: { data: { id: 123, title: \"The Hobbit\", ... } }\n```\n\n### PUT - Replace Entire Resource\n- **Purpose:** Replace entire resource (all fields required)\n- **Guarantees:** Idempotent (same result if called multiple times)\n- **Response:** 200 OK or 204 No Content\n\n```typescript\nPUT /api/v1/books/123\nBody: {\n  title: \"The Hobbit\",\n  author: \"J.R.R. Tolkien\",\n  isbn: \"978-0547928227\",\n  publishedDate: \"1937-09-21\",\n  pages: 310\n}\nResponse: 200 OK\n```\n\n### PATCH - Partial Update\n- **Purpose:** Update specific fields (only send changed fields)\n- **Guarantees:** Idempotent\n- **Response:** 200 OK\n\n```typescript\nPATCH /api/v1/books/123\nBody: { price: 14.99 }  // Only update price\nResponse: 200 OK\n```\n\n### DELETE - Remove Resource\n- **Purpose:** Delete resource\n- **Guarantees:** Idempotent\n- **Response:** 204 No Content or 200 OK\n\n```typescript\nDELETE /api/v1/books/123\nResponse: 204 No Content\n```\n\n---\n\n## URL Structure\n\n### Standard URL Format\n\n```\n{protocol}://{host}/api/{version}/{collection}/{id}?{query_params}\n```\n\n**Examples:**\n```\nhttps://api.example.com/api/v1/books\nhttps://api.example.com/api/v1/books/123\nhttps://api.example.com/api/v1/authors/456/books\nhttps://api.example.com/api/v1/books?genre=fiction&page=1&limit=20\n```\n\n### API Versioning\n\n**Always version APIs from inception.**\n\n✅ **Good:**\n```\n/api/v1/books\n/api/v2/books\n```\n\n❌ **Bad:**\n```\n/api/books          # No version\n/books              # No API prefix\n/v1/books           # No API prefix\n```\n\n**Why:** Allows breaking changes without disrupting existing clients. Clients can upgrade to new versions when ready.\n\n### Hierarchical Resources\n\n**Use path nesting for parent-child relationships.**\n\n✅ **Good (Clear Hierarchy):**\n```\nGET /api/v1/authors/456/books              # Books by specific author\nPOST /api/v1/authors/456/books             # Create book for author\nGET /api/v1/orders/789/items               # Items in specific order\nGET /api/v1/users/123/addresses            # User's addresses\n```\n\n❌ **Bad (Too Deep):**\n```\nGET /api/v1/publishers/1/authors/2/books/3/reviews/4/comments/5\n# Too nested, hard to read and maintain\n```\n\n**Limit nesting to 2-3 levels.** Beyond that, use query parameters:\n\n✅ **Better:**\n```\nGET /api/v1/comments?reviewId=4\nGET /api/v1/reviews/4/comments\n```\n\n---\n\n## Query Parameters & Filtering\n\n### Simple Filters\n\n**Use query parameters for straightforward filtering.**\n\n```typescript\n// Single filter\nGET /api/v1/books?author=tolkien\n\n// Multiple filters\nGET /api/v1/books?author=tolkien&genre=fantasy&available=true\n\n// Range filters\nGET /api/v1/books?priceMin=10&priceMax=50&publishedAfter=2020-01-01\n\n// Sorting\nGET /api/v1/books?sortBy=publishedDate&order=desc\n\n// Pagination\nGET /api/v1/books?page=1&limit=20\n```\n\n### Complex Filters\n\n**When filters become unwieldy, switch to POST with structured request body.**\n\n❌ **Unwieldy Query String:**\n```\nGET /api/v1/books?authors=1,2,3&genres=fiction,mystery&priceMin=10&priceMax=50&publishedAfter=2020-01-01&inStock=true&formats=paperback,ebook\n```\n\n✅ **Structured Search Endpoint:**\n```typescript\nPOST /api/v1/books/search\n{\n  \"authors\": [1, 2, 3],\n  \"genres\": [\"fiction\", \"mystery\"],\n  \"priceRange\": { \"min\": 10, \"max\": 50 },\n  \"publishedAfter\": \"2020-01-01\",\n  \"inStock\": true,\n  \"formats\": [\"paperback\", \"ebook\"],\n  \"sortBy\": \"publishedDate\",\n  \"order\": \"desc\",\n  \"page\": 1,\n  \"limit\": 20\n}\n```\n\n---\n\n## Naming Conventions\n\n### Consistency is Key\n\n**Pick ONE style (snake_case or camelCase) and enforce it throughout the entire API.**\n\n✅ **Consistent snake_case:**\n```typescript\nGET /api/v1/products?created_at=2024-01-01&price_min=50&is_available=true\nPOST /api/v1/users/123/shipping_addresses\n\n{\n  \"product_id\": 123,\n  \"product_name\": \"Widget\",\n  \"created_at\": \"2024-01-01T00:00:00Z\",\n  \"is_available\": true\n}\n```\n\n✅ **Consistent camelCase:**\n```typescript\nGET /api/v1/products?createdAt=2024-01-01&priceMin=50&isAvailable=true\nPOST /api/v1/users/123/shippingAddresses\n\n{\n  \"productId\": 123,\n  \"productName\": \"Widget\",\n  \"createdAt\": \"2024-01-01T00:00:00Z\",\n  \"isAvailable\": true\n}\n```\n\n❌ **Inconsistent (Never Mix):**\n```typescript\nGET /api/v1/products?created_at=2024-01-01&priceMin=50  // Mixed!\n\n{\n  \"product_id\": 123,        // snake_case\n  \"productName\": \"Widget\",  // camelCase - confusing!\n}\n```\n\n---\n\n## Response Standards\n\n### HTTP Status Codes\n\n**Use meaningful status codes to communicate outcomes.**\n\n| Code | Meaning | Usage |\n|------|---------|-------|\n| 200 OK | Success | GET, PUT, PATCH succeeded |\n| 201 Created | Resource created | POST succeeded |\n| 204 No Content | Success, no body | DELETE succeeded |\n| 400 Bad Request | Invalid client data | Validation failed |\n| 401 Unauthorized | Authentication required | No/invalid auth token |\n| 403 Forbidden | Authenticated but not permitted | Insufficient permissions |\n| 404 Not Found | Resource doesn't exist | Invalid ID |\n| 409 Conflict | Resource conflict | Duplicate, version mismatch |\n| 422 Unprocessable Entity | Semantic errors | Business rule violation |\n| 500 Internal Server Error | Server failure | Unexpected error |\n\n❌ **Don't return 200 for everything:**\n```typescript\n// Bad - returns 200 for errors\nGET /api/v1/books/999\nResponse: 200 OK\n{\n  \"success\": false,\n  \"error\": \"Book not found\"\n}\n```\n\n✅ **Use proper status codes:**\n```typescript\nGET /api/v1/books/999\nResponse: 404 Not Found\n{\n  \"error\": {\n    \"code\": \"RESOURCE_NOT_FOUND\",\n    \"message\": \"Book with ID 999 not found\"\n  }\n}\n```\n\n### Success Response Format\n\n**Wrap data in consistent structure.**\n\n```typescript\n// Single resource\nGET /api/v1/books/123\nResponse: 200 OK\n{\n  \"data\": {\n    \"id\": 123,\n    \"title\": \"The Hobbit\",\n    \"author\": \"J.R.R. Tolkien\",\n    \"isbn\": \"978-0547928227\"\n  }\n}\n\n// Collection\nGET /api/v1/books\nResponse: 200 OK\n{\n  \"data\": [\n    { \"id\": 123, \"title\": \"The Hobbit\" },\n    { \"id\": 124, \"title\": \"1984\" }\n  ],\n  \"pagination\": {\n    \"page\": 1,\n    \"limit\": 20,\n    \"total\": 150,\n    \"totalPages\": 8\n  }\n}\n\n// Creation\nPOST /api/v1/books\nResponse: 201 Created\nLocation: /api/v1/books/123\n{\n  \"data\": {\n    \"id\": 123,\n    \"title\": \"The Hobbit\",\n    \"createdAt\": \"2024-12-06T10:00:00Z\"\n  }\n}\n```\n\n### Error Response Format\n\n**Provide structured, actionable error information.**\n\n```typescript\n// Simple error\nResponse: 404 Not Found\n{\n  \"error\": {\n    \"code\": \"RESOURCE_NOT_FOUND\",\n    \"message\": \"Book with ID 999 not found\"\n  }\n}\n\n// Validation errors (field-level details)\nResponse: 400 Bad Request\n{\n  \"error\": {\n    \"code\": \"VALIDATION_ERROR\",\n    \"message\": \"The request contains invalid data\",\n    \"details\": [\n      {\n        \"field\": \"price\",\n        \"message\": \"Must be a positive number\",\n        \"value\": -10\n      },\n      {\n        \"field\": \"isbn\",\n        \"message\": \"ISBN format invalid\",\n        \"value\": \"123\"\n      },\n      {\n        \"field\": \"publishedDate\",\n        \"message\": \"Must be in ISO 8601 format\",\n        \"value\": \"2024/01/01\"\n      }\n    ]\n  }\n}\n\n// Business rule error\nResponse: 422 Unprocessable Entity\n{\n  \"error\": {\n    \"code\": \"INSUFFICIENT_STOCK\",\n    \"message\": \"Cannot process order: insufficient stock\",\n    \"details\": {\n      \"requested\": 10,\n      \"available\": 3,\n      \"productId\": 456\n    }\n  }\n}\n```\n\n### Pagination (Non-Optional)\n\n**If your API returns lists, it needs pagination** - regardless of current data size.\n\n✅ **Always paginate collections:**\n```typescript\nGET /api/v1/books?page=1&limit=20\n\nResponse: 200 OK\n{\n  \"data\": [\n    { \"id\": 1, \"title\": \"Book 1\" },\n    { \"id\": 2, \"title\": \"Book 2\" }\n  ],\n  \"pagination\": {\n    \"page\": 1,\n    \"limit\": 20,\n    \"total\": 150,\n    \"totalPages\": 8,\n    \"hasNext\": true,\n    \"hasPrevious\": false\n  },\n  \"links\": {\n    \"self\": \"/api/v1/books?page=1&limit=20\",\n    \"next\": \"/api/v1/books?page=2&limit=20\",\n    \"last\": \"/api/v1/books?page=8&limit=20\"\n  }\n}\n```\n\n**Common Pagination Strategies:**\n\n1. **Offset-based (page/limit)**\n   ```\n   GET /api/v1/books?page=2&limit=20\n   ```\n\n2. **Cursor-based (for large datasets)**\n   ```\n   GET /api/v1/books?cursor=eyJpZCI6MTIzfQ&limit=20\n   ```\n\n3. **Keyset pagination (efficient for large tables)**\n   ```\n   GET /api/v1/books?afterId=123&limit=20\n   ```\n\n---\n\n## Virtual Resources\n\n**Not all endpoints map to database tables. Handle aggregated or generated data as resources.**\n\n```typescript\n// Recommendations (generated on-demand)\nGET /api/v1/users/123/recommendations\nGET /api/v1/recommendations?type=trending\n\n// Complex search\nPOST /api/v1/books/search\n{\n  \"query\": \"fantasy\",\n  \"filters\": {...}\n}\n\n// Autocomplete/suggestions\nGET /api/v1/suggestions?q=hob&type=books\nResponse: {\n  \"data\": [\n    { \"id\": 123, \"title\": \"The Hobbit\" },\n    { \"id\": 456, \"title\": \"Hobbit House Design\" }\n  ]\n}\n\n// Analytics/aggregations\nGET /api/v1/analytics/sales?period=monthly&year=2024\nGET /api/v1/reports/inventory?warehouseId=5\n```\n\n---\n\n## Complete REST API Example\n\n### Book Store System\n\n**Entities:** Authors, Books, Customers, Orders, Order Items\n\n**Clean Endpoints:**\n\n```typescript\n// Books\nGET    /api/v1/books              // List with pagination\nGET    /api/v1/books/123          // Specific book\nPOST   /api/v1/books              // Create\nPUT    /api/v1/books/123          // Full update\nPATCH  /api/v1/books/123          // Partial update\nDELETE /api/v1/books/123          // Delete\n\n// Authors\nGET    /api/v1/authors\nGET    /api/v1/authors/456\nPOST   /api/v1/authors\nPUT    /api/v1/authors/456\nDELETE /api/v1/authors/456\n\n// Hierarchical (Author's books)\nGET    /api/v1/authors/456/books\nPOST   /api/v1/authors/456/books\n\n// Orders\nGET    /api/v1/orders\nGET    /api/v1/orders/789\nPOST   /api/v1/orders\nPATCH  /api/v1/orders/789\n\n// Order items (nested resource)\nGET    /api/v1/orders/789/items\nPOST   /api/v1/orders/789/items\nPATCH  /api/v1/orders/789/items/10\nDELETE /api/v1/orders/789/items/10\n\n// Customers\nGET    /api/v1/customers\nGET    /api/v1/customers/123\nGET    /api/v1/customers/123/orders      // Customer's orders\nGET    /api/v1/customers/123/addresses   // Customer's addresses\n```\n\n---\n\n## Express.js Implementation Example\n\n```typescript\nimport express, { Request, Response } from 'express';\n\nconst router = express.Router();\n\n// List books with pagination\nrouter.get('/api/v1/books', async (req: Request, res: Response) => {\n  const page = parseInt(req.query.page as string) || 1;\n  const limit = parseInt(req.query.limit as string) || 20;\n  const genre = req.query.genre as string;\n\n  const filters: any = {};\n  if (genre) filters.genre = genre;\n\n  const { books, total } = await bookService.findAll({\n    page,\n    limit,\n    filters\n  });\n\n  res.status(200).json({\n    data: books,\n    pagination: {\n      page,\n      limit,\n      total,\n      totalPages: Math.ceil(total / limit)\n    }\n  });\n});\n\n// Get single book\nrouter.get('/api/v1/books/:id', async (req: Request, res: Response) => {\n  const book = await bookService.findById(req.params.id);\n\n  if (!book) {\n    return res.status(404).json({\n      error: {\n        code: 'RESOURCE_NOT_FOUND',\n        message: `Book with ID ${req.params.id} not found`\n      }\n    });\n  }\n\n  res.status(200).json({ data: book });\n});\n\n// Create book\nrouter.post('/api/v1/books', async (req: Request, res: Response) => {\n  const validationErrors = validateBook(req.body);\n\n  if (validationErrors.length > 0) {\n    return res.status(400).json({\n      error: {\n        code: 'VALIDATION_ERROR',\n        message: 'The request contains invalid data',\n        details: validationErrors\n      }\n    });\n  }\n\n  const book = await bookService.create(req.body);\n\n  res.status(201)\n    .location(`/api/v1/books/${book.id}`)\n    .json({ data: book });\n});\n\n// Update book (full replacement)\nrouter.put('/api/v1/books/:id', async (req: Request, res: Response) => {\n  const book = await bookService.update(req.params.id, req.body);\n\n  if (!book) {\n    return res.status(404).json({\n      error: {\n        code: 'RESOURCE_NOT_FOUND',\n        message: `Book with ID ${req.params.id} not found`\n      }\n    });\n  }\n\n  res.status(200).json({ data: book });\n});\n\n// Partial update\nrouter.patch('/api/v1/books/:id', async (req: Request, res: Response) => {\n  const book = await bookService.partialUpdate(req.params.id, req.body);\n\n  if (!book) {\n    return res.status(404).json({\n      error: {\n        code: 'RESOURCE_NOT_FOUND',\n        message: `Book with ID ${req.params.id} not found`\n      }\n    });\n  }\n\n  res.status(200).json({ data: book });\n});\n\n// Delete book\nrouter.delete('/api/v1/books/:id', async (req: Request, res: Response) => {\n  const deleted = await bookService.delete(req.params.id);\n\n  if (!deleted) {\n    return res.status(404).json({\n      error: {\n        code: 'RESOURCE_NOT_FOUND',\n        message: `Book with ID ${req.params.id} not found`\n      }\n    });\n  }\n\n  res.status(204).send();\n});\n\n// Complex search\nrouter.post('/api/v1/books/search', async (req: Request, res: Response) => {\n  const { books, total } = await bookService.search(req.body);\n\n  res.status(200).json({\n    data: books,\n    pagination: {\n      page: req.body.page || 1,\n      limit: req.body.limit || 20,\n      total,\n      totalPages: Math.ceil(total / (req.body.limit || 20))\n    }\n  });\n});\n```\n\n---\n\n## Common Pitfalls\n\n❌ **Verbs in URLs:** `/api/createUser`, `/api/getBooks`\n❌ **Singular collections:** `/api/book` instead of `/api/books`\n❌ **Returning 200 for errors:** Always use proper status codes\n❌ **No pagination:** Will cause performance issues as data grows\n❌ **Inconsistent naming:** Mixing snake_case and camelCase\n❌ **Too deep nesting:** `/publishers/1/authors/2/books/3/reviews/4`\n❌ **No versioning:** `/api/books` instead of `/api/v1/books`\n❌ **Generic errors:** \"Error occurred\" without details\n❌ **No field-level validation errors:** Hard to debug for clients\n\n---\n\n## Key Takeaways\n\n1. **Resource-oriented design:** Use nouns, not verbs\n2. **HTTP methods matter:** GET, POST, PUT, PATCH, DELETE have specific meanings\n3. **Version from day one:** `/api/v1/`\n4. **Always paginate:** Even if data is small now\n5. **Meaningful status codes:** Don't return 200 for everything\n6. **Structured errors:** Provide actionable error messages with field-level details\n7. **Consistency wins:** Pick naming convention and stick to it\n8. **Hierarchical resources:** Use nesting wisely (2-3 levels max)\n9. **Query for simple filters, POST for complex:** Don't create unwieldy query strings\n\n**Remember:** APIs are interfaces that other developers (including future you) will use. Invest time in good design upfront to avoid technical debt.\n",
    "original/development-practices/security-practices.md": "# Security Best Practices & Guidelines\n\n## Input Validation\n\n### Whitelist Validation\n\n```typescript\n// ❌ Blacklist approach (bypassable)\nconst sanitize = (input: string) => {\n  return input.replace(/<script>/g, '');\n  // Bypassed with: <scr<script>ipt>, <SCRIPT>, etc.\n};\n\n// ✅ Whitelist approach\nconst validateEmail = (email: string): boolean => {\n  const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\n  return emailRegex.test(email);\n};\n\nconst validateAge = (age: string): number => {\n  const ageNum = parseInt(age, 10);\n  if (isNaN(ageNum) || ageNum < 0 || ageNum > 150) {\n    throw new ValidationError('Invalid age');\n  }\n  return ageNum;\n};\n```\n\n### Framework Validation\n\n```typescript\n// Using class-validator (TypeScript/NestJS)\nimport { IsEmail, IsInt, Min, Max, Length } from 'class-validator';\n\nclass CreateUserDto {\n  @IsEmail()\n  email: string;\n\n  @Length(12, 160)\n  password: string;\n\n  @IsInt()\n  @Min(0)\n  @Max(150)\n  age: number;\n}\n\n// Using Zod\nimport { z } from 'zod';\n\nconst userSchema = z.object({\n  email: z.string().email(),\n  password: z.string().min(12).max(160),\n  age: z.number().int().min(0).max(150),\n  url: z.string().url()\n});\n\nconst validateUser = (data: unknown) => {\n  return userSchema.parse(data); // Throws on invalid\n};\n```\n\n### Validation Rules\n\n- Keep contracts as restrictive as possible\n- Reject invalid data without detailed error feedback\n- Validate at API boundaries, not just UI\n- Never trust client-side validation alone\n- Validate data type, length, format, and range\n\n## Output Encoding\n\n### Context-Appropriate Encoding\n\n```typescript\n// ❌ Dangerous: Direct HTML injection\nconst showMessage = (userInput: string) => {\n  element.innerHTML = userInput; // XSS vulnerability\n};\n\n// ✅ Safe: Text encoding\nconst showMessage = (userInput: string) => {\n  element.textContent = userInput; // Automatically encoded\n};\n\n// For React\nconst UserProfile = ({ userName }: { userName: string }) => {\n  return <div>{userName}</div>; // Auto-encoded by React\n};\n\n// ❌ Bypassing encoding\nconst UnsafeProfile = ({ html }: { html: string }) => {\n  return <div dangerouslySetInnerHTML={{ __html: html }} />; // Avoid\n};\n```\n\n### Template Encoding\n\n```erb\n<!-- ERB (Ruby) -->\n<p><%= @user_input %></p>         <!-- Safe: Auto-encoded -->\n<p><%= raw @user_input %></p>     <!-- Dangerous: No encoding -->\n\n<!-- Thymeleaf (Java) -->\n<p th:text=\"${userInput}\"></p>     <!-- Safe: Auto-encoded -->\n<p th:utext=\"${userInput}\"></p>    <!-- Dangerous: No encoding -->\n\n<!-- Handlebars -->\n<p>{{userInput}}</p>               <!-- Safe: Auto-encoded -->\n<p>{{{userInput}}}</p>             <!-- Dangerous: No encoding -->\n```\n\n### Storage and Rendering\n\n```typescript\n// ✅ Store raw, encode at render time\nconst saveComment = async (comment: string) => {\n  await db.insert('comments', { text: comment }); // Store raw\n};\n\nconst displayComment = (comment: Comment) => {\n  return escapeHtml(comment.text); // Encode when displaying\n};\n\n// ❌ Don't encode before storage\nconst saveComment = async (comment: string) => {\n  const encoded = escapeHtml(comment); // Wrong: encode at storage\n  await db.insert('comments', { text: encoded });\n};\n```\n\n## SQL Injection Prevention\n\n### Parameter Binding\n\n```typescript\n// ❌ String concatenation (vulnerable)\nconst getUserByEmail = async (email: string) => {\n  const query = `SELECT * FROM users WHERE email = '${email}'`;\n  // Input: ' OR '1'='1\n  // Result: SELECT * FROM users WHERE email = '' OR '1'='1'\n  return db.query(query);\n};\n\n// ✅ Parameterized queries\nconst getUserByEmail = async (email: string) => {\n  const query = 'SELECT * FROM users WHERE email = ?';\n  return db.query(query, [email]);\n};\n\n// ✅ Using ORM (TypeORM example)\nconst getUserByEmail = async (email: string) => {\n  return userRepository.findOne({ where: { email } });\n};\n\n// ✅ Using query builder\nconst getUsers = async (minAge: number) => {\n  return db\n    .select('*')\n    .from('users')\n    .where('age', '>', minAge); // Automatically parameterized\n};\n```\n\n### Dynamic Queries\n\n```typescript\n// ❌ Building dynamic WHERE with concatenation\nconst searchUsers = async (filters: Record<string, string>) => {\n  let query = 'SELECT * FROM users WHERE 1=1';\n  Object.entries(filters).forEach(([key, value]) => {\n    query += ` AND ${key} = '${value}'`; // SQL injection\n  });\n  return db.query(query);\n};\n\n// ✅ Using query builder for dynamic queries\nconst searchUsers = async (filters: Record<string, string>) => {\n  let query = db.select('*').from('users');\n\n  Object.entries(filters).forEach(([key, value]) => {\n    query = query.where(key, '=', value); // Parameterized\n  });\n\n  return query;\n};\n```\n\n### NoSQL Injection\n\n```typescript\n// ❌ MongoDB injection\nconst getUser = async (username: string) => {\n  return db.collection('users').findOne({\n    username: username,\n    $where: `this.username === '${username}'` // Injection point\n  });\n};\n\n// ✅ Safe MongoDB query\nconst getUser = async (username: string) => {\n  return db.collection('users').findOne({ username }); // Safe\n};\n\n// ❌ Accepting objects from user input\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  db.users.findOne({ username, password }); // If password = {$gt: \"\"}, bypasses check\n});\n\n// ✅ Validate types\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n\n  if (typeof username !== 'string' || typeof password !== 'string') {\n    throw new Error('Invalid input types');\n  }\n\n  db.users.findOne({ username, password });\n});\n```\n\n## Authentication\n\n### Password Storage\n\n```typescript\nimport bcrypt from 'bcrypt';\n\n// ❌ Plaintext storage\nconst createUser = async (email: string, password: string) => {\n  await db.insert('users', { email, password }); // Catastrophic\n};\n\n// ❌ Simple hash (no salt, fast algorithm)\nconst createUser = async (email: string, password: string) => {\n  const hash = crypto.createHash('sha256').update(password).digest('hex');\n  await db.insert('users', { email, password_hash: hash }); // Still weak\n};\n\n// ✅ Bcrypt with salt (recommended)\nconst SALT_ROUNDS = 12; // Configurable work factor\n\nconst createUser = async (email: string, password: string) => {\n  const hash = await bcrypt.hash(password, SALT_ROUNDS);\n  await db.insert('users', { email, password_hash: hash });\n};\n\nconst verifyPassword = async (email: string, password: string): Promise<boolean> => {\n  const user = await db.findOne('users', { email });\n  if (!user) {\n    return false; // Don't reveal user existence\n  }\n  return bcrypt.compare(password, user.password_hash);\n};\n\n// Using Argon2 (more modern)\nimport argon2 from 'argon2';\n\nconst createUser = async (email: string, password: string) => {\n  const hash = await argon2.hash(password);\n  await db.insert('users', { email, password_hash: hash });\n};\n```\n\n### Password Policies\n\n```typescript\nconst validatePassword = (password: string): boolean => {\n  // Minimum length: 12 characters\n  if (password.length < 12) {\n    throw new Error('Password must be at least 12 characters');\n  }\n\n  // Maximum length: prevent DoS via bcrypt\n  if (password.length > 160) {\n    throw new Error('Password too long');\n  }\n\n  // ✅ Allow special characters, spaces, unicode\n  // ✅ Don't prevent password manager usage\n  // ✅ Support paste functionality\n\n  return true;\n};\n\n// ❌ Avoid overly restrictive rules\nconst badPasswordValidation = (password: string) => {\n  // Don't require specific character types\n  // This reduces entropy and frustrates users\n  if (!/[A-Z]/.test(password)) return false;\n  if (!/[a-z]/.test(password)) return false;\n  if (!/[0-9]/.test(password)) return false;\n  if (!/[!@#$]/.test(password)) return false;\n  // Bad approach\n};\n```\n\n### Login Protection\n\n```typescript\n// Rate limiting and account lockout\nimport rateLimit from 'express-rate-limit';\n\nconst loginLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 5, // 5 attempts\n  message: 'Too many login attempts, please try again later',\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\napp.post('/login', loginLimiter, async (req, res) => {\n  const { email, password } = req.body;\n\n  // ✅ Generic error message\n  const user = await verifyPassword(email, password);\n  if (!user) {\n    return res.status(401).json({ error: 'Invalid email or password' });\n    // ❌ Don't say: \"Email not found\" or \"Incorrect password\"\n  }\n\n  // Create session\n  req.session.userId = user.id;\n  res.json({ success: true });\n});\n\n// Temporary lockout with exponential backoff\nconst loginAttempts = new Map<string, { count: number; lockedUntil?: Date }>();\n\nconst checkLoginAttempts = (email: string): boolean => {\n  const attempts = loginAttempts.get(email);\n\n  if (attempts?.lockedUntil && attempts.lockedUntil > new Date()) {\n    return false; // Still locked\n  }\n\n  return true;\n};\n\nconst recordFailedLogin = (email: string) => {\n  const attempts = loginAttempts.get(email) || { count: 0 };\n  attempts.count++;\n\n  if (attempts.count >= 5) {\n    // Lock for exponentially increasing time\n    const lockMinutes = Math.pow(2, attempts.count - 5); // 1, 2, 4, 8... minutes\n    attempts.lockedUntil = new Date(Date.now() + lockMinutes * 60 * 1000);\n  }\n\n  loginAttempts.set(email, attempts);\n};\n```\n\n### Two-Factor Authentication\n\n```typescript\nimport speakeasy from 'speakeasy';\nimport qrcode from 'qrcode';\n\nconst enable2FA = async (userId: string) => {\n  const secret = speakeasy.generateSecret({\n    name: `MyApp (${user.email})`\n  });\n\n  // Store secret (encrypted)\n  await db.update('users', userId, {\n    totp_secret: encrypt(secret.base32)\n  });\n\n  // Generate QR code for user\n  const qrCodeUrl = await qrcode.toDataURL(secret.otpauth_url);\n\n  return { secret: secret.base32, qrCode: qrCodeUrl };\n};\n\nconst verify2FA = async (userId: string, token: string): Promise<boolean> => {\n  const user = await db.findById('users', userId);\n  const secret = decrypt(user.totp_secret);\n\n  return speakeasy.totp.verify({\n    secret,\n    encoding: 'base32',\n    token,\n    window: 2 // Allow 2 time steps (60 seconds)\n  });\n};\n\n// Login with 2FA\napp.post('/login', async (req, res) => {\n  const { email, password, totpToken } = req.body;\n\n  const user = await verifyPassword(email, password);\n  if (!user) {\n    return res.status(401).json({ error: 'Invalid credentials' });\n  }\n\n  if (user.totp_enabled) {\n    if (!totpToken || !await verify2FA(user.id, totpToken)) {\n      return res.status(401).json({ error: 'Invalid 2FA token' });\n    }\n  }\n\n  req.session.userId = user.id;\n  res.json({ success: true });\n});\n```\n\n## Session Management\n\n### Secure Session Generation\n\n```typescript\nimport crypto from 'crypto';\n\n// ❌ Predictable session ID\nconst generateSessionId = () => {\n  return `${Date.now()}-${Math.random()}`; // Predictable\n};\n\n// ✅ Cryptographically secure random\nconst generateSessionId = (): string => {\n  return crypto.randomBytes(32).toString('base64'); // 256 bits\n};\n\n// Session creation\napp.post('/login', async (req, res) => {\n  const user = await authenticateUser(req.body);\n\n  // ✅ Create new session after authentication\n  req.session.regenerate((err) => {\n    if (err) throw err;\n\n    req.session.userId = user.id;\n    req.session.save();\n    res.json({ success: true });\n  });\n});\n```\n\n### Cookie Security\n\n```typescript\n// Express session configuration\nimport session from 'express-session';\n\napp.use(session({\n  secret: process.env.SESSION_SECRET, // Strong random secret\n  name: 'sessionId', // Don't use default 'connect.sid'\n\n  cookie: {\n    secure: true,        // Only send over HTTPS\n    httpOnly: true,      // Prevent JavaScript access\n    sameSite: 'strict',  // CSRF protection\n    maxAge: 30 * 60 * 1000, // 30 minutes\n    domain: 'example.com',\n    path: '/'\n  },\n\n  resave: false,\n  saveUninitialized: false,\n\n  // Use secure session store (Redis, database)\n  store: new RedisStore({ client: redisClient })\n}));\n\n// ❌ Insecure cookie settings\napp.use(session({\n  cookie: {\n    secure: false,      // Allows HTTP transmission\n    httpOnly: false,    // Accessible via JavaScript\n    sameSite: 'none'    // No CSRF protection\n  }\n}));\n```\n\n### Session Lifecycle\n\n```typescript\n// Inactivity timeout\nconst SESSION_TIMEOUT = 30 * 60 * 1000; // 30 minutes\n\napp.use((req, res, next) => {\n  if (req.session.userId) {\n    const now = Date.now();\n    const lastActivity = req.session.lastActivity || now;\n\n    if (now - lastActivity > SESSION_TIMEOUT) {\n      req.session.destroy();\n      return res.status(401).json({ error: 'Session expired' });\n    }\n\n    req.session.lastActivity = now;\n  }\n  next();\n});\n\n// Logout endpoint\napp.post('/logout', (req, res) => {\n  req.session.destroy((err) => {\n    if (err) {\n      return res.status(500).json({ error: 'Logout failed' });\n    }\n\n    res.clearCookie('sessionId');\n    res.json({ success: true });\n  });\n});\n\n// Terminate all sessions on password change\nconst changePassword = async (userId: string, newPassword: string) => {\n  const hash = await bcrypt.hash(newPassword, SALT_ROUNDS);\n  await db.update('users', userId, { password_hash: hash });\n\n  // Invalidate all sessions for this user\n  await sessionStore.destroyAllForUser(userId);\n};\n```\n\n## Authorization\n\n### Server-Side Enforcement\n\n```typescript\n// ❌ Client-side only (dangerous)\nconst AdminPanel = () => {\n  const user = useUser();\n\n  if (!user.isAdmin) {\n    return null; // UI hidden but API still accessible\n  }\n\n  return <AdminControls />;\n};\n\n// ✅ Server-side enforcement\napp.delete('/users/:id', requireAuth, async (req, res) => {\n  const currentUser = req.user;\n\n  // Check role\n  if (!currentUser.hasRole('admin')) {\n    return res.status(403).json({ error: 'Forbidden' });\n  }\n\n  await userService.delete(req.params.id);\n  res.json({ success: true });\n});\n\n// ✅ Resource-level authorization\napp.put('/profiles/:id', requireAuth, async (req, res) => {\n  const currentUser = req.user;\n  const profileId = req.params.id;\n\n  // Check ownership\n  if (currentUser.id !== profileId && !currentUser.hasRole('admin')) {\n    return res.status(403).json({ error: 'Forbidden' });\n  }\n\n  await profileService.update(profileId, req.body);\n  res.json({ success: true });\n});\n```\n\n### RBAC (Role-Based Access Control)\n\n```typescript\n// Define permissions\nenum Permission {\n  USER_READ = 'user:read',\n  USER_WRITE = 'user:write',\n  USER_DELETE = 'user:delete',\n  POST_CREATE = 'post:create',\n  POST_PUBLISH = 'post:publish'\n}\n\n// Define roles\nconst roles = {\n  viewer: [Permission.USER_READ],\n  editor: [Permission.USER_READ, Permission.POST_CREATE],\n  admin: [Permission.USER_READ, Permission.USER_WRITE, Permission.USER_DELETE, Permission.POST_PUBLISH]\n};\n\n// Authorization middleware\nconst requirePermission = (permission: Permission) => {\n  return (req, res, next) => {\n    const user = req.user;\n\n    if (!user) {\n      return res.status(401).json({ error: 'Unauthorized' });\n    }\n\n    const userPermissions = roles[user.role] || [];\n\n    if (!userPermissions.includes(permission)) {\n      return res.status(403).json({ error: 'Forbidden' });\n    }\n\n    next();\n  };\n};\n\n// Usage\napp.delete('/users/:id', requirePermission(Permission.USER_DELETE), async (req, res) => {\n  await userService.delete(req.params.id);\n  res.json({ success: true });\n});\n```\n\n### ABAC (Attribute-Based Access Control)\n\n```typescript\n// Policy-based authorization\ninterface AuthContext {\n  user: User;\n  resource: Resource;\n  action: string;\n  environment: {\n    time: Date;\n    ipAddress: string;\n  };\n}\n\nconst policies = {\n  canEditDocument: (ctx: AuthContext): boolean => {\n    const { user, resource, environment } = ctx;\n\n    // Owner can always edit\n    if (resource.ownerId === user.id) return true;\n\n    // Admins can edit during business hours\n    if (user.role === 'admin') {\n      const hour = environment.time.getHours();\n      return hour >= 9 && hour < 17;\n    }\n\n    // Collaborators can edit if document is not locked\n    if (resource.collaborators.includes(user.id)) {\n      return !resource.isLocked;\n    }\n\n    return false;\n  }\n};\n\n// Authorization middleware\nconst authorize = (policy: string) => {\n  return async (req, res, next) => {\n    const resource = await loadResource(req.params.id);\n\n    const context: AuthContext = {\n      user: req.user,\n      resource,\n      action: req.method,\n      environment: {\n        time: new Date(),\n        ipAddress: req.ip\n      }\n    };\n\n    if (!policies[policy](context)) {\n      return res.status(403).json({ error: 'Forbidden' });\n    }\n\n    next();\n  };\n};\n\n// Usage\napp.put('/documents/:id', authorize('canEditDocument'), async (req, res) => {\n  await documentService.update(req.params.id, req.body);\n  res.json({ success: true });\n});\n```\n\n## HTTPS / TLS\n\n### Configuration\n\n```typescript\nimport https from 'https';\nimport fs from 'fs';\n\n// HTTPS server setup\nconst options = {\n  key: fs.readFileSync('/path/to/private-key.pem'),\n  cert: fs.readFileSync('/path/to/certificate.pem'),\n\n  // Modern cipher suite (use Mozilla SSL Config Generator)\n  ciphers: 'TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384',\n  minVersion: 'TLSv1.3'\n};\n\nhttps.createServer(options, app).listen(443);\n\n// Force HTTPS redirect\napp.use((req, res, next) => {\n  if (!req.secure && req.get('x-forwarded-proto') !== 'https') {\n    return res.redirect(301, `https://${req.hostname}${req.url}`);\n  }\n  next();\n});\n\n// HSTS header\napp.use((req, res, next) => {\n  res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');\n  next();\n});\n```\n\n### Security Headers\n\n```typescript\nimport helmet from 'helmet';\n\n// Use Helmet for security headers\napp.use(helmet());\n\n// Custom security headers\napp.use((req, res, next) => {\n  // Prevent MIME sniffing\n  res.setHeader('X-Content-Type-Options', 'nosniff');\n\n  // Prevent clickjacking\n  res.setHeader('X-Frame-Options', 'DENY');\n\n  // XSS protection\n  res.setHeader('X-XSS-Protection', '1; mode=block');\n\n  // Content Security Policy\n  res.setHeader('Content-Security-Policy',\n    \"default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'\");\n\n  // Referrer policy\n  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');\n\n  // Permissions policy\n  res.setHeader('Permissions-Policy', 'geolocation=(), microphone=(), camera=()');\n\n  next();\n});\n```\n\n## Secrets Management\n\n### Environment Variables\n\n```typescript\n// ❌ Hardcoded secrets\nconst config = {\n  dbPassword: 'super_secret_password', // Never do this\n  apiKey: 'sk-1234567890abcdef'\n};\n\n// ✅ Environment variables\nimport dotenv from 'dotenv';\ndotenv.config();\n\nconst config = {\n  dbPassword: process.env.DB_PASSWORD,\n  apiKey: process.env.API_KEY,\n  sessionSecret: process.env.SESSION_SECRET\n};\n\n// Validate required secrets on startup\nconst requiredEnvVars = ['DB_PASSWORD', 'API_KEY', 'SESSION_SECRET'];\n\nrequiredEnvVars.forEach(varName => {\n  if (!process.env[varName]) {\n    throw new Error(`Missing required environment variable: ${varName}`);\n  }\n});\n```\n\n### Secret Generation\n\n```bash\n# Generate strong session secret\nhead -c32 /dev/urandom | base64\n\n# Or using Node.js\nnode -e \"console.log(require('crypto').randomBytes(32).toString('base64'))\"\n\n# OpenSSL\nopenssl rand -base64 32\n```\n\n### .env File Security\n\n```bash\n# .gitignore\n.env\n.env.local\n.env.*.local\n*.key\n*.pem\nsecrets/\n\n# .env.example (commit this)\nDB_PASSWORD=\nAPI_KEY=\nSESSION_SECRET=\n```\n\n### Secrets in CI/CD\n\n```yaml\n# GitHub Actions\n- name: Deploy\n  env:\n    DB_PASSWORD: ${{ secrets.DB_PASSWORD }}\n    API_KEY: ${{ secrets.API_KEY }}\n  run: ./deploy.sh\n\n# Don't echo secrets in logs\n- name: Configure\n  run: |\n    echo \"Configuring application...\"\n    # ❌ echo \"DB_PASSWORD=$DB_PASSWORD\"\n    # ✅ Use secrets properly without logging\n```\n\n## Threat Modeling with STRIDE\n\n### STRIDE Framework\n\n**S - Spoofing Identity**\n- Threat: Attacker impersonates legitimate user\n- Mitigations: Strong authentication, MFA, session management\n\n**T - Tampering**\n- Threat: Malicious modification of data or code\n- Mitigations: Input validation, checksums, integrity checks, HTTPS\n\n**R - Repudiation**\n- Threat: Users deny actions they performed\n- Mitigations: Audit logging, non-repudiable signatures\n\n**I - Information Disclosure**\n- Threat: Unauthorized data access\n- Mitigations: Encryption, access controls, secure transmission\n\n**D - Denial of Service**\n- Threat: System unavailability\n- Mitigations: Rate limiting, resource quotas, load balancing\n\n**E - Elevation of Privilege**\n- Threat: Unauthorized privilege escalation\n- Mitigations: Principle of least privilege, authorization checks\n\n### Practical Application\n\n```typescript\n// Example: File upload feature threat model\n\n// SPOOFING: Verify uploader identity\napp.post('/upload', requireAuth, async (req, res) => {\n  const userId = req.user.id; // Authenticated user\n\n  // TAMPERING: Validate file type and content\n  const file = req.files.upload;\n  const allowedTypes = ['image/jpeg', 'image/png', 'application/pdf'];\n\n  if (!allowedTypes.includes(file.mimetype)) {\n    return res.status(400).json({ error: 'Invalid file type' });\n  }\n\n  // Scan for malware (TAMPERING)\n  await virusScanner.scan(file.path);\n\n  // INFORMATION DISCLOSURE: Store with access controls\n  const fileId = await fileStore.save(file, {\n    ownerId: userId,\n    visibility: 'private'\n  });\n\n  // REPUDIATION: Audit log\n  await auditLog.record({\n    action: 'file_upload',\n    userId,\n    fileId,\n    timestamp: new Date(),\n    ipAddress: req.ip\n  });\n\n  // DENIAL OF SERVICE: Enforce size limits\n  const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB\n  if (file.size > MAX_FILE_SIZE) {\n    return res.status(413).json({ error: 'File too large' });\n  }\n\n  // ELEVATION OF PRIVILEGE: Check quotas\n  const userQuota = await quotaService.getRemaining(userId);\n  if (userQuota < file.size) {\n    return res.status(403).json({ error: 'Quota exceeded' });\n  }\n\n  res.json({ fileId });\n});\n```\n\n## Common Vulnerabilities\n\n### Cross-Site Request Forgery (CSRF)\n\n```typescript\n// ❌ Vulnerable endpoint\napp.post('/transfer-money', requireAuth, async (req, res) => {\n  const { to, amount } = req.body;\n  await transferMoney(req.user.id, to, amount);\n  res.json({ success: true });\n});\n// Attacker creates: <form action=\"https://bank.com/transfer-money\" method=\"POST\">\n\n// ✅ CSRF token protection\nimport csrf from 'csurf';\n\nconst csrfProtection = csrf({ cookie: true });\n\napp.get('/transfer', csrfProtection, (req, res) => {\n  res.render('transfer', { csrfToken: req.csrfToken() });\n});\n\napp.post('/transfer-money', csrfProtection, async (req, res) => {\n  const { to, amount } = req.body;\n  await transferMoney(req.user.id, to, amount);\n  res.json({ success: true });\n});\n\n// ✅ SameSite cookie attribute\napp.use(session({\n  cookie: {\n    sameSite: 'strict' // or 'lax'\n  }\n}));\n```\n\n### XML External Entity (XXE)\n\n```typescript\nimport { parseString } from 'xml2js';\n\n// ❌ Vulnerable XML parsing\nconst parseXML = (xmlString: string) => {\n  return parseString(xmlString, { /* default options */ });\n  // Can load external entities\n};\n\n// ✅ Disable external entities\nimport libxmljs from 'libxmljs';\n\nconst parseXML = (xmlString: string) => {\n  return libxmljs.parseXml(xmlString, {\n    noent: false,  // Don't substitute entities\n    nonet: true    // Don't fetch external resources\n  });\n};\n```\n\n### Server-Side Request Forgery (SSRF)\n\n```typescript\n// ❌ Vulnerable URL fetch\napp.post('/fetch-url', async (req, res) => {\n  const { url } = req.body;\n  const response = await fetch(url); // Can access internal resources\n  res.json(await response.json());\n});\n\n// ✅ Whitelist allowed domains\nconst ALLOWED_DOMAINS = ['api.example.com', 'cdn.example.com'];\n\napp.post('/fetch-url', async (req, res) => {\n  const { url } = req.body;\n  const urlObj = new URL(url);\n\n  if (!ALLOWED_DOMAINS.includes(urlObj.hostname)) {\n    return res.status(400).json({ error: 'Domain not allowed' });\n  }\n\n  // Prevent access to internal IPs\n  const ip = await dns.resolve4(urlObj.hostname);\n  if (isPrivateIP(ip[0])) {\n    return res.status(400).json({ error: 'Internal IP not allowed' });\n  }\n\n  const response = await fetch(url);\n  res.json(await response.json());\n});\n\nconst isPrivateIP = (ip: string): boolean => {\n  return /^(10\\.|172\\.(1[6-9]|2[0-9]|3[01])\\.|192\\.168\\.)/.test(ip) ||\n         ip === '127.0.0.1' ||\n         ip === 'localhost';\n};\n```\n\n### Path Traversal\n\n```typescript\n// ❌ Vulnerable file access\napp.get('/files/:filename', (req, res) => {\n  const filename = req.params.filename;\n  res.sendFile(`/uploads/${filename}`);\n  // Input: ../../etc/passwd\n});\n\n// ✅ Validate and sanitize path\nimport path from 'path';\n\napp.get('/files/:filename', (req, res) => {\n  const filename = req.params.filename;\n\n  // Remove path traversal characters\n  const safeName = path.basename(filename);\n\n  // Build safe path\n  const filePath = path.join('/uploads', safeName);\n\n  // Verify path is within uploads directory\n  const normalizedPath = path.normalize(filePath);\n  if (!normalizedPath.startsWith('/uploads/')) {\n    return res.status(400).json({ error: 'Invalid filename' });\n  }\n\n  res.sendFile(normalizedPath);\n});\n```\n\n### Insecure Deserialization\n\n```typescript\n// ❌ Deserializing untrusted data\napp.post('/data', (req, res) => {\n  const obj = JSON.parse(req.body.data);\n  eval(obj.code); // Remote code execution\n});\n\n// ✅ Safe deserialization\napp.post('/data', (req, res) => {\n  try {\n    const obj = JSON.parse(req.body.data);\n\n    // Validate structure\n    const schema = z.object({\n      name: z.string(),\n      age: z.number()\n    });\n\n    const validated = schema.parse(obj);\n\n    // Never execute code from user input\n    // Never use eval, Function constructor, etc.\n\n    res.json(validated);\n  } catch (error) {\n    res.status(400).json({ error: 'Invalid data' });\n  }\n});\n```\n\n## Anti-Patterns\n\n### ❌ Security by Obscurity\n\n```typescript\n// Don't hide endpoints and call it security\napp.post('/api/secret_admin_panel_xyz123/delete-user', async (req, res) => {\n  // Obscure URL doesn't provide real security\n});\n\n// ✅ Proper authorization\napp.post('/api/users/:id', requireAuth, requireRole('admin'), async (req, res) => {\n  // Real security through authentication and authorization\n});\n```\n\n### ❌ Rolling Your Own Crypto\n\n```typescript\n// ❌ Custom encryption\nconst encrypt = (text: string, key: string) => {\n  return text.split('').map((c, i) =>\n    String.fromCharCode(c.charCodeAt(0) ^ key.charCodeAt(i % key.length))\n  ).join('');\n};\n\n// ✅ Use established libraries\nimport crypto from 'crypto';\n\nconst encrypt = (text: string, key: Buffer): string => {\n  const iv = crypto.randomBytes(16);\n  const cipher = crypto.createCipheriv('aes-256-gcm', key, iv);\n\n  let encrypted = cipher.update(text, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n\n  const authTag = cipher.getAuthTag();\n\n  return JSON.stringify({\n    iv: iv.toString('hex'),\n    authTag: authTag.toString('hex'),\n    encrypted\n  });\n};\n```\n\n### ❌ Client-Side Security\n\n```javascript\n// ❌ Client-side validation only\nfunction deleteUser(userId) {\n  if (currentUser.role !== 'admin') {\n    alert('Not authorized');\n    return;\n  }\n\n  fetch(`/api/users/${userId}`, { method: 'DELETE' });\n  // Attacker bypasses by calling fetch directly\n}\n\n// ✅ Server enforces security\napp.delete('/api/users/:id', requireRole('admin'), async (req, res) => {\n  await userService.delete(req.params.id);\n  res.json({ success: true });\n});\n```\n\n### ❌ Storing Secrets in Code\n\n```typescript\n// ❌ Committed to version control\nconst config = {\n  awsAccessKey: 'AKIAIOSFODNN7EXAMPLE',\n  awsSecretKey: 'wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY'\n};\n\n// ✅ Environment variables\nconst config = {\n  awsAccessKey: process.env.AWS_ACCESS_KEY_ID,\n  awsSecretKey: process.env.AWS_SECRET_ACCESS_KEY\n};\n```\n\n### ❌ Insufficient Logging\n\n```typescript\n// ❌ No audit trail\napp.post('/users/:id/promote', async (req, res) => {\n  await userService.promoteToAdmin(req.params.id);\n  res.json({ success: true });\n});\n\n// ✅ Comprehensive audit logging\napp.post('/users/:id/promote', requireAuth, async (req, res) => {\n  await auditLog.record({\n    action: 'user_promote_admin',\n    actor: req.user.id,\n    target: req.params.id,\n    timestamp: new Date(),\n    ipAddress: req.ip,\n    userAgent: req.get('user-agent')\n  });\n\n  await userService.promoteToAdmin(req.params.id);\n  res.json({ success: true });\n});\n```\n\n## Security Checklist\n\n### Development\n- [ ] All inputs validated server-side with whitelist approach\n- [ ] All outputs encoded for appropriate context\n- [ ] Parameterized queries for all database access\n- [ ] Passwords hashed with bcrypt/Argon2 (work factor ≥12)\n- [ ] No secrets in source code or version control\n- [ ] HTTPS enforced with HSTS header\n- [ ] Security headers configured (CSP, X-Frame-Options, etc.)\n- [ ] CSRF protection enabled for state-changing operations\n- [ ] Rate limiting on authentication endpoints\n- [ ] Audit logging for sensitive operations\n\n### Authentication & Authorization\n- [ ] Session IDs cryptographically random (≥128 bits)\n- [ ] Sessions regenerated after login/privilege change\n- [ ] Cookies marked Secure, HttpOnly, SameSite\n- [ ] Inactivity timeout implemented\n- [ ] Authorization enforced server-side for all endpoints\n- [ ] Principle of least privilege applied\n- [ ] Generic error messages (no user enumeration)\n- [ ] Two-factor authentication available for sensitive operations\n\n### Dependencies & Infrastructure\n- [ ] Dependencies regularly updated (automated scanning)\n- [ ] Vulnerable dependencies identified and patched\n- [ ] TLS 1.3 or TLS 1.2 minimum\n- [ ] Strong cipher suites configured\n- [ ] Database connections encrypted\n- [ ] Backup data encrypted at rest\n- [ ] Security monitoring and alerting enabled\n\n### Testing\n- [ ] Automated security tests in CI/CD\n- [ ] Regular penetration testing\n- [ ] Dependency vulnerability scanning\n- [ ] Static code analysis (SAST)\n- [ ] Dynamic analysis (DAST)\n- [ ] Threat modeling completed for new features\n\n## References\n\n- [OWASP Top 10](https://owasp.org/www-project-top-ten/)\n- [OWASP Cheat Sheet Series](https://cheatsheetseries.owasp.org/)\n- [Mozilla Web Security Guidelines](https://infosec.mozilla.org/guidelines/web_security)\n- [Mozilla SSL Configuration Generator](https://ssl-config.mozilla.org/)\n- [NIST Password Guidelines](https://pages.nist.gov/800-63-3/)\n- [CWE Top 25](https://cwe.mitre.org/top25/)\n",
    "original/development-practices/testing-practices.md": "# Testing Best Practices & Guidelines\n\n## Test Pyramid\n\n### Structure\n\n```\n        /\\\n       /  \\\n      / UI \\         ← Few (slow, brittle, expensive)\n     /------\\\n    /        \\\n   / Integration \\   ← Some (medium speed, moderate cost)\n  /--------------\\\n /                \\\n/   Unit Tests     \\ ← Many (fast, cheap, stable)\n--------------------\n```\n\n**Principle**: Write lots of small fast unit tests, some integration tests, very few UI tests.\n\n### Test Distribution\n\n```typescript\n// ✅ Good distribution\nUnit Tests:        1000+ tests, ~1-2 minutes total\nIntegration Tests: 50-100 tests, ~5-10 minutes total\nE2E Tests:         5-15 tests, ~15-30 minutes total\n\n// ❌ Ice cream cone anti-pattern\nUnit Tests:        50 tests\nIntegration Tests: 200 tests\nE2E Tests:         500 tests  // Maintenance nightmare\n```\n\n## Unit Testing\n\n### Test Structure: Arrange-Act-Assert\n\n```typescript\ndescribe('UserService', () => {\n  describe('createUser', () => {\n    it('should create user with hashed password', async () => {\n      // Arrange\n      const userData = {\n        email: 'test@example.com',\n        password: 'password123'\n      };\n      const mockRepo = {\n        save: jest.fn().mockResolvedValue({ id: '1', ...userData })\n      };\n      const service = new UserService(mockRepo);\n\n      // Act\n      const result = await service.createUser(userData);\n\n      // Assert\n      expect(result.id).toBe('1');\n      expect(result.email).toBe('test@example.com');\n      expect(mockRepo.save).toHaveBeenCalledWith(\n        expect.objectContaining({\n          email: 'test@example.com',\n          password: expect.not.stringMatching('password123') // Password should be hashed\n        })\n      );\n    });\n  });\n});\n```\n\n### Test Observable Behavior, Not Implementation\n\n```typescript\n// ❌ Testing implementation details\nit('should call validateEmail method', () => {\n  const spy = jest.spyOn(service, 'validateEmail');\n  service.createUser({ email: 'test@example.com', password: 'pass' });\n  expect(spy).toHaveBeenCalled(); // Brittle - breaks if refactored\n});\n\n// ✅ Testing observable behavior\nit('should reject invalid email', async () => {\n  await expect(\n    service.createUser({ email: 'invalid', password: 'pass' })\n  ).rejects.toThrow('Invalid email');\n});\n```\n\n### One Test Per Condition\n\n```typescript\n// ❌ Multiple assertions for different scenarios\nit('should validate user input', () => {\n  expect(() => validate({ age: -1 })).toThrow();\n  expect(() => validate({ age: 200 })).toThrow();\n  expect(() => validate({ name: '' })).toThrow();\n  // Hard to identify which condition failed\n});\n\n// ✅ One test per condition\nit('should reject negative age', () => {\n  expect(() => validate({ age: -1 })).toThrow('Age must be positive');\n});\n\nit('should reject age over 150', () => {\n  expect(() => validate({ age: 200 })).toThrow('Age must be under 150');\n});\n\nit('should reject empty name', () => {\n  expect(() => validate({ name: '' })).toThrow('Name is required');\n});\n```\n\n### Avoid Testing Trivial Code\n\n```typescript\n// ❌ Testing getters/setters\nit('should set and get name', () => {\n  user.setName('John');\n  expect(user.getName()).toBe('John');\n});\n\n// ❌ Testing framework code\nit('should return JSON response', () => {\n  const result = res.json({ data: 'test' });\n  expect(result).toBeDefined(); // Testing Express, not your code\n});\n\n// ✅ Test business logic\nit('should calculate discounted price correctly', () => {\n  const order = new Order({ items: [{ price: 100 }], discountPercent: 10 });\n  expect(order.getTotal()).toBe(90);\n});\n```\n\n### Solitary vs Sociable Unit Tests\n\n```typescript\n// Solitary: All collaborators mocked\ndescribe('OrderService (solitary)', () => {\n  it('should process order', async () => {\n    const mockPayment = { charge: jest.fn().mockResolvedValue({ success: true }) };\n    const mockInventory = { reserve: jest.fn().mockResolvedValue(true) };\n    const mockEmail = { send: jest.fn().mockResolvedValue(true) };\n\n    const service = new OrderService(mockPayment, mockInventory, mockEmail);\n    await service.processOrder(order);\n\n    expect(mockPayment.charge).toHaveBeenCalled();\n    expect(mockInventory.reserve).toHaveBeenCalled();\n    expect(mockEmail.send).toHaveBeenCalled();\n  });\n});\n\n// Sociable: Real collaborators where practical\ndescribe('OrderService (sociable)', () => {\n  it('should calculate total with real tax calculator', async () => {\n    const taxCalculator = new TaxCalculator(); // Real object\n    const mockPayment = { charge: jest.fn() }; // Mock external service\n\n    const service = new OrderService(mockPayment, taxCalculator);\n    await service.processOrder(order);\n\n    expect(mockPayment.charge).toHaveBeenCalledWith(\n      expect.objectContaining({ amount: 108 }) // $100 + 8% tax\n    );\n  });\n});\n```\n\n## Test Doubles\n\n### Types\n\n```typescript\n// Dummy: Passed but never used\nconst dummyLogger = {} as Logger;\nconst service = new Service(dummyLogger);\n\n// Stub: Returns canned responses\nconst stubDatabase = {\n  findUser: () => ({ id: '1', name: 'Test User' })\n};\n\n// Spy: Records how it was called\nconst spyLogger = {\n  log: jest.fn()\n};\nservice.doSomething();\nexpect(spyLogger.log).toHaveBeenCalledWith('Action completed');\n\n// Mock: Pre-programmed with expectations\nconst mockPayment = {\n  charge: jest.fn()\n    .mockResolvedValueOnce({ success: true })\n    .mockResolvedValueOnce({ success: false })\n};\n\n// Fake: Working implementation (not for production)\nclass FakeDatabase implements Database {\n  private data: Map<string, any> = new Map();\n\n  async save(id: string, data: any) {\n    this.data.set(id, data);\n  }\n\n  async find(id: string) {\n    return this.data.get(id);\n  }\n}\n```\n\n### When to Use Each\n\n```typescript\n// Use Stubs for queries\nconst stubUserRepo = {\n  findById: (id: string) => ({ id, name: 'John', role: 'admin' })\n};\n\n// Use Mocks for commands (behavior verification)\nconst mockEmailService = {\n  send: jest.fn()\n};\nawait service.registerUser(userData);\nexpect(mockEmailService.send).toHaveBeenCalledWith(\n  expect.objectContaining({ to: userData.email, subject: 'Welcome' })\n);\n\n// Use Fakes for complex dependencies\nconst fakeCache = new InMemoryCache(); // Faster than Redis in tests\nconst service = new Service(fakeCache);\n```\n\n## Integration Testing\n\n### Database Integration Tests\n\n```typescript\ndescribe('UserRepository (integration)', () => {\n  let db: Database;\n\n  beforeAll(async () => {\n    // Use test database or in-memory DB\n    db = await createTestDatabase();\n  });\n\n  afterAll(async () => {\n    await db.close();\n  });\n\n  beforeEach(async () => {\n    // Clean database before each test\n    await db.query('TRUNCATE TABLE users CASCADE');\n  });\n\n  it('should persist and retrieve user', async () => {\n    const repo = new UserRepository(db);\n    const user = await repo.create({\n      email: 'test@example.com',\n      name: 'Test User'\n    });\n\n    const retrieved = await repo.findById(user.id);\n\n    expect(retrieved).toMatchObject({\n      email: 'test@example.com',\n      name: 'Test User'\n    });\n  });\n\n  it('should enforce unique email constraint', async () => {\n    const repo = new UserRepository(db);\n\n    await repo.create({ email: 'test@example.com', name: 'User 1' });\n\n    await expect(\n      repo.create({ email: 'test@example.com', name: 'User 2' })\n    ).rejects.toThrow('Email already exists');\n  });\n});\n```\n\n### API Integration Tests\n\n```typescript\nimport request from 'supertest';\nimport { app } from '../app';\n\ndescribe('POST /api/users', () => {\n  it('should create user and return 201', async () => {\n    const response = await request(app)\n      .post('/api/users')\n      .send({\n        email: 'test@example.com',\n        password: 'securepassword123'\n      })\n      .expect(201);\n\n    expect(response.body).toMatchObject({\n      id: expect.any(String),\n      email: 'test@example.com'\n    });\n    expect(response.body.password).toBeUndefined(); // Password not returned\n  });\n\n  it('should return 400 for invalid email', async () => {\n    const response = await request(app)\n      .post('/api/users')\n      .send({\n        email: 'invalid-email',\n        password: 'password123'\n      })\n      .expect(400);\n\n    expect(response.body.error).toContain('Invalid email');\n  });\n});\n```\n\n### External Service Integration Tests\n\n```typescript\nimport nock from 'nock';\n\ndescribe('PaymentService integration', () => {\n  afterEach(() => {\n    nock.cleanAll();\n  });\n\n  it('should process payment via external API', async () => {\n    // Mock external payment API\n    nock('https://api.payment-provider.com')\n      .post('/charges')\n      .reply(200, {\n        id: 'ch_123',\n        status: 'succeeded',\n        amount: 1000\n      });\n\n    const service = new PaymentService();\n    const result = await service.charge({ amount: 1000, currency: 'USD' });\n\n    expect(result.status).toBe('succeeded');\n    expect(result.id).toBe('ch_123');\n  });\n\n  it('should handle payment API errors', async () => {\n    nock('https://api.payment-provider.com')\n      .post('/charges')\n      .reply(402, { error: 'Insufficient funds' });\n\n    const service = new PaymentService();\n\n    await expect(\n      service.charge({ amount: 1000, currency: 'USD' })\n    ).rejects.toThrow('Payment failed: Insufficient funds');\n  });\n});\n```\n\n## End-to-End Testing\n\n### Critical User Journeys Only\n\n```typescript\n// ✅ Test critical paths\ndescribe('E2E: User Registration Flow', () => {\n  it('should complete full registration', async () => {\n    await page.goto('http://localhost:3000/register');\n\n    // Fill form\n    await page.fill('[name=\"email\"]', 'newuser@example.com');\n    await page.fill('[name=\"password\"]', 'securepassword123');\n    await page.fill('[name=\"confirmPassword\"]', 'securepassword123');\n\n    // Submit\n    await page.click('button[type=\"submit\"]');\n\n    // Verify success\n    await expect(page.locator('.success-message')).toContainText(\n      'Registration successful'\n    );\n\n    // Verify redirect to dashboard\n    await expect(page).toHaveURL('http://localhost:3000/dashboard');\n  });\n});\n\n// ❌ Don't test every edge case at E2E level\ndescribe('E2E: Form Validation', () => {\n  // These should be unit/integration tests instead\n  it('should show error for missing email', async () => { /* ... */ });\n  it('should show error for invalid email format', async () => { /* ... */ });\n  it('should show error for short password', async () => { /* ... */ });\n  // 50 more validation tests...\n});\n```\n\n### Page Object Pattern\n\n```typescript\n// pages/registration.page.ts\nexport class RegistrationPage {\n  constructor(private page: Page) {}\n\n  async navigate() {\n    await this.page.goto('http://localhost:3000/register');\n  }\n\n  async fillEmail(email: string) {\n    await this.page.fill('[name=\"email\"]', email);\n  }\n\n  async fillPassword(password: string) {\n    await this.page.fill('[name=\"password\"]', password);\n  }\n\n  async submit() {\n    await this.page.click('button[type=\"submit\"]');\n  }\n\n  async getErrorMessage() {\n    return this.page.locator('.error-message').textContent();\n  }\n}\n\n// Test using Page Object\ndescribe('User Registration', () => {\n  let registrationPage: RegistrationPage;\n\n  beforeEach(async () => {\n    registrationPage = new RegistrationPage(page);\n    await registrationPage.navigate();\n  });\n\n  it('should register new user', async () => {\n    await registrationPage.fillEmail('user@example.com');\n    await registrationPage.fillPassword('securepassword');\n    await registrationPage.submit();\n\n    await expect(page).toHaveURL(/\\/dashboard/);\n  });\n});\n```\n\n## Test-Driven Development (TDD)\n\n### Red-Green-Refactor Cycle\n\n```typescript\n// 1. RED: Write failing test\ndescribe('calculateDiscount', () => {\n  it('should apply 10% discount for orders over $100', () => {\n    const result = calculateDiscount(150);\n    expect(result).toBe(15); // Test fails - function doesn't exist\n  });\n});\n\n// 2. GREEN: Write minimal code to pass\nconst calculateDiscount = (amount: number): number => {\n  if (amount > 100) {\n    return amount * 0.1;\n  }\n  return 0;\n};\n\n// 3. REFACTOR: Improve code while keeping tests green\nconst calculateDiscount = (amount: number): number => {\n  const DISCOUNT_THRESHOLD = 100;\n  const DISCOUNT_RATE = 0.1;\n\n  return amount > DISCOUNT_THRESHOLD ? amount * DISCOUNT_RATE : 0;\n};\n```\n\n## Contract Testing\n\n### Consumer-Driven Contracts\n\n```typescript\n// Consumer test (Frontend)\nimport { pact } from '@pact-foundation/pact';\n\ndescribe('User API Contract', () => {\n  const provider = pact({\n    consumer: 'FrontendApp',\n    provider: 'UserAPI'\n  });\n\n  it('should get user by ID', async () => {\n    await provider.addInteraction({\n      state: 'user with ID 123 exists',\n      uponReceiving: 'a request for user 123',\n      withRequest: {\n        method: 'GET',\n        path: '/api/users/123'\n      },\n      willRespondWith: {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n        body: {\n          id: '123',\n          name: 'John Doe',\n          email: 'john@example.com'\n        }\n      }\n    });\n\n    const response = await userClient.getUser('123');\n    expect(response.name).toBe('John Doe');\n  });\n});\n\n// Provider verification (Backend)\ndescribe('User API Provider', () => {\n  it('should verify contract', async () => {\n    await verifyPacts({\n      provider: 'UserAPI',\n      providerBaseUrl: 'http://localhost:3000',\n      pactUrls: ['./pacts/FrontendApp-UserAPI.json']\n    });\n  });\n});\n```\n\n## Test Best Practices\n\n### Keep Tests Independent\n\n```typescript\n// ❌ Tests depend on order\nlet userId: string;\n\nit('should create user', async () => {\n  const user = await service.createUser({ name: 'Test' });\n  userId = user.id; // Shared state\n});\n\nit('should update user', async () => {\n  await service.updateUser(userId, { name: 'Updated' }); // Fails if run alone\n});\n\n// ✅ Each test is independent\nit('should create user', async () => {\n  const user = await service.createUser({ name: 'Test' });\n  expect(user.id).toBeDefined();\n});\n\nit('should update user', async () => {\n  const user = await service.createUser({ name: 'Test' });\n  const updated = await service.updateUser(user.id, { name: 'Updated' });\n  expect(updated.name).toBe('Updated');\n});\n```\n\n### Use Test Helpers and Factories\n\n```typescript\n// Test helpers\nconst createTestUser = (overrides = {}) => ({\n  email: 'test@example.com',\n  name: 'Test User',\n  role: 'user',\n  ...overrides\n});\n\nconst createTestOrder = (overrides = {}) => ({\n  userId: '123',\n  items: [{ productId: 'p1', quantity: 1, price: 100 }],\n  status: 'pending',\n  ...overrides\n});\n\n// Usage\nit('should process order for premium user', async () => {\n  const premiumUser = createTestUser({ role: 'premium' });\n  const order = createTestOrder({ userId: premiumUser.id });\n\n  const result = await service.processOrder(order);\n\n  expect(result.discount).toBeGreaterThan(0);\n});\n```\n\n### Readable Test Names\n\n```typescript\n// ❌ Unclear test names\nit('test1', () => { /* ... */ });\nit('works correctly', () => { /* ... */ });\nit('should return true', () => { /* ... */ });\n\n// ✅ Descriptive test names\nit('should reject order when inventory is insufficient', () => { /* ... */ });\nit('should send confirmation email after successful payment', () => { /* ... */ });\nit('should apply 15% discount for VIP customers on orders over $200', () => { /* ... */ });\n```\n\n### Don't Over-DRY Tests\n\n```typescript\n// ❌ Over-abstracted (hard to understand)\nconst runTest = (input, expected, errorMsg) => {\n  it(errorMsg, () => {\n    expect(validate(input)).toBe(expected);\n  });\n};\nrunTest({ age: -1 }, false, 'test1');\nrunTest({ age: 200 }, false, 'test2');\n\n// ✅ Some repetition is OK for clarity\nit('should reject negative age', () => {\n  expect(validate({ age: -1 })).toBe(false);\n});\n\nit('should reject age over 150', () => {\n  expect(validate({ age: 200 })).toBe(false);\n});\n```\n\n## Handling Flaky Tests\n\n### Eliminate Non-Determinism\n\n```typescript\n// ❌ Time-dependent test\nit('should create timestamp', () => {\n  const result = service.createRecord();\n  expect(result.timestamp).toBe(new Date('2024-01-01')); // Fails tomorrow\n});\n\n// ✅ Inject time dependency\nclass Service {\n  constructor(private clock: Clock = new SystemClock()) {}\n\n  createRecord() {\n    return { timestamp: this.clock.now() };\n  }\n}\n\nit('should create timestamp', () => {\n  const mockClock = { now: () => new Date('2024-01-01') };\n  const service = new Service(mockClock);\n\n  const result = service.createRecord();\n  expect(result.timestamp).toEqual(new Date('2024-01-01'));\n});\n```\n\n### Avoid Race Conditions\n\n```typescript\n// ❌ Race condition\nit('should process async operation', async () => {\n  service.startAsyncTask();\n  // Task might not complete yet\n  expect(service.isComplete()).toBe(true); // Flaky\n});\n\n// ✅ Wait for completion\nit('should process async operation', async () => {\n  await service.startAsyncTask();\n  expect(service.isComplete()).toBe(true);\n});\n\n// ✅ Use polling for eventual consistency\nit('should eventually update status', async () => {\n  service.startAsyncTask();\n\n  await waitFor(() => {\n    expect(service.getStatus()).toBe('complete');\n  }, { timeout: 5000 });\n});\n```\n\n## Test Coverage\n\n### Use Coverage as a Guide, Not a Goal\n\n```bash\n# Generate coverage report\nnpm run test:coverage\n\n# Typical output\nStatements   : 85.5% ( 1234/1443 )\nBranches     : 78.2% ( 567/725 )\nFunctions    : 82.1% ( 234/285 )\nLines        : 86.3% ( 1198/1388 )\n```\n\n```typescript\n// ✅ 100% coverage doesn't mean bug-free\nconst divide = (a: number, b: number) => a / b;\n\nit('should divide numbers', () => {\n  expect(divide(10, 2)).toBe(5); // 100% coverage\n});\n\n// Missing test: divide(10, 0) → Infinity (edge case not covered)\n\n// ✅ Focus on important paths\nit('should handle division by zero', () => {\n  expect(() => divide(10, 0)).toThrow('Cannot divide by zero');\n});\n```\n\n## Anti-Patterns\n\n### ❌ Testing Private Methods\n\n```typescript\nclass UserService {\n  private validateEmail(email: string) { /* ... */ }\n\n  public createUser(data: UserData) {\n    this.validateEmail(data.email);\n    // ...\n  }\n}\n\n// ❌ Don't test private methods\nit('should validate email', () => {\n  const service = new UserService();\n  expect(service['validateEmail']('test@example.com')).toBe(true);\n});\n\n// ✅ Test through public interface\nit('should reject invalid email', () => {\n  const service = new UserService();\n  expect(() => service.createUser({ email: 'invalid' }))\n    .toThrow('Invalid email');\n});\n```\n\n### ❌ Mocking Everything\n\n```typescript\n// ❌ Over-mocking loses confidence\nit('should calculate total', () => {\n  const mockCalculator = {\n    add: jest.fn().mockReturnValue(10),\n    multiply: jest.fn().mockReturnValue(100)\n  };\n\n  const service = new PriceService(mockCalculator);\n  const result = service.calculateTotal();\n\n  expect(result).toBe(100); // Not testing real calculation\n});\n\n// ✅ Use real objects when simple\nit('should calculate total', () => {\n  const calculator = new Calculator(); // Real implementation\n  const service = new PriceService(calculator);\n\n  const result = service.calculateTotal([\n    { price: 10, quantity: 2 },\n    { price: 15, quantity: 3 }\n  ]);\n\n  expect(result).toBe(65); // 20 + 45\n});\n```\n\n### ❌ Slow Test Suites\n\n```typescript\n// ❌ Testing everything at E2E level\ndescribe('Form validation (E2E)', () => {\n  it('should validate email format', async () => { /* ... */ }); // 5s\n  it('should validate password length', async () => { /* ... */ }); // 5s\n  // 100 more E2E tests... → 10+ minutes\n});\n\n// ✅ Push tests down the pyramid\ndescribe('Form validation (unit)', () => {\n  it('should validate email format', () => { /* ... */ }); // 5ms\n  it('should validate password length', () => { /* ... */ }); // 5ms\n  // 100 tests → < 1 second\n});\n\ndescribe('Form submission (E2E)', () => {\n  it('should complete registration flow', async () => { /* ... */ }); // 5s\n  // Just the happy path\n});\n```\n\n## References\n\n- [Test Pyramid](https://martinfowler.com/bliki/TestPyramid.html)\n- [Mocks Aren't Stubs](https://martinfowler.com/articles/mocksArentStubs.html)\n- [Practical Test Pyramid](https://martinfowler.com/articles/practical-test-pyramid.html)\n- [Eradicating Non-Determinism in Tests](https://martinfowler.com/articles/nonDeterminism.html)\n- [Test-Driven Development](https://martinfowler.com/bliki/TestDrivenDevelopment.html)\n",
    "original/development-practices/version-control-patterns.md": "# Version Control Patterns\n\n## Overview\n\nVersion control patterns define how teams collaborate on code through branching, integration, and release strategies. The fundamental challenge: enable parallel development while maintaining code quality and minimizing integration conflicts.\n\n**Core Principle:** \"Branches should be integrated frequently and efforts focused on a healthy mainline that can be deployed into production with minimal effort.\"\n\n---\n\n## Foundational Patterns\n\n### Source Branching\n\nCreate parallel copies of code to track different streams of development work.\n\n**Key Concept:** A branch is a sequence of commits. Merging combines work from different branches.\n\n**Purpose:**\n- Enable parallel development without blocking\n- Experiment without affecting stable code\n- Track different versions simultaneously\n\n**Challenge:** Merging introduces complexity:\n- **Textual Conflicts**: Systems can detect (two people change same line)\n- **Semantic Conflicts**: Logic errors systems can't catch (incompatible changes to related code)\n\n### Mainline\n\nA single shared branch representing the current product state.\n\n**Also Known As:**\n- `main` / `master` (Git)\n- `trunk` (Subversion)\n- `develop` (Git-flow)\n\n**Purpose:**\n- Clear integration point for team\n- Represents \"current version\" of product\n- Foundation for release processes\n\n**Characteristics:**\n- Lives in central repository\n- All developers pull from and push to mainline\n- Should remain in releasable state (ideally)\n\n### Healthy Branch\n\nAutomated verification on each commit ensures code quality.\n\n**Requirements:**\n- **Self-Testing Code**: Comprehensive automated test suite\n- **Fast Commit Suite**: Tests run in ~10 minutes or less\n- **Multi-Stage Pipeline**: Longer tests run in deployment pipeline\n- **Immediate Fixing**: Break mainline → fix immediately before other work\n\n**Value:** Developers can confidently start work from mainline without untangling defects.\n\n**Example Verification:**\n```bash\n# On every commit to mainline\n1. Run unit tests (< 5 min)\n2. Run integration tests (< 10 min)\n3. Build artifacts\n4. If any step fails → block merge, notify team\n\n# Deployment pipeline (post-commit)\n1. Deploy to staging\n2. Run E2E tests (30 min)\n3. Run performance tests (60 min)\n4. Security scans\n```\n\n---\n\n## Integration Patterns\n\n### Mainline Integration\n\nDevelopers pull from mainline, merge changes locally, verify health, then push back.\n\n**Workflow:**\n```\n1. Pull latest mainline\n2. Merge your changes locally\n3. Run full test suite\n4. Build succeeds → push to mainline\n5. Automated checks pass → integration complete\n```\n\n**Critical Point:** Integration = pull AND push. Pulling alone isn't integration.\n\n**Anti-Pattern:**\n```typescript\n// ❌ Don't do this\ngit pull origin main\ngit push origin main  // Without running tests!\n\n// ✅ Correct\ngit pull origin main\nnpm test              // Verify health\nnpm run build\ngit push origin main  // Only after verification\n```\n\n### Integration Frequency\n\n**The Counter-Intuitive Truth:** \"If it hurts, do it more often.\"\n\n**Low-Frequency Integration (Weekly, Monthly)**\n```\nProblems:\n- Large, complex merges\n- Conflicts detected late after significant divergence\n- Fear of integration creates vicious cycle\n- Refactoring becomes risky\n- Semantic conflicts harder to catch\n\nResult: Integration pain increases exponentially with delay\n```\n\n**High-Frequency Integration (Daily, Multiple Times Daily)**\n```\nBenefits:\n- Small, manageable merges\n- Conflicts detected quickly with less code to review\n- Integration becomes routine, not scary\n- Encourages refactoring\n- Team stays aware of codebase changes\n\nResult: More integrations, but each is easier\n```\n\n**Key Research:** Elite development teams integrate notably more often than low performers (State of DevOps Report).\n\n### Feature Branching\n\nCreate a branch per feature; integrate into mainline only when complete.\n\n**Workflow:**\n```\n1. Create branch from mainline (feature/user-authentication)\n2. Commit changes to feature branch\n3. Periodically pull mainline changes (stay updated)\n4. Complete feature\n5. Merge entire feature to mainline\n```\n\n**Example:**\n```bash\n# Start feature\ngit checkout -b feature/user-authentication main\n\n# Work on feature (multiple commits)\ngit commit -m \"Add User model\"\ngit commit -m \"Implement JWT authentication\"\ngit commit -m \"Add login endpoint\"\n\n# Pull mainline changes periodically\ngit pull origin main  # Not integration, just staying updated\n\n# Feature complete → merge to main\ngit checkout main\ngit merge feature/user-authentication\ngit push origin main\n```\n\n**Strengths:**\n- ✅ Clear feature completion milestones\n- ✅ Code reviewed as complete unit\n- ✅ Features only appear when finished\n- ✅ Good for open-source (untrusted contributors)\n\n**Weaknesses:**\n- ❌ Integration frequency tied to feature length\n- ❌ Long features = delayed integration\n- ❌ Larger merges increase conflict risk\n- ❌ Discourages refactoring (merge fear)\n- ❌ Lower performance correlation (DevOps research)\n\n**When to Use:**\n- Open-source projects with external contributors\n- Teams requiring feature-level review\n- Regulatory environments needing clear audit trails\n- New teams learning version control\n\n### Continuous Integration\n\nDevelopers integrate to mainline daily (or multiple times daily), even with partially-complete features.\n\n**Core Rule:** Never accumulate more than one day's unintegrated work.\n\n**Workflow:**\n```\n1. Pull latest mainline\n2. Make small change (< 1 day work)\n3. Run tests locally\n4. Push to mainline\n5. Automated pipeline verifies\n6. Repeat multiple times per day\n```\n\n**Example:**\n```bash\n# Morning: Start new feature\ngit pull origin main\n# Implement User model (2 hours work)\ngit commit -m \"Add User model structure\"\ngit push origin main  # Integrate even though feature incomplete\n\n# Afternoon: Continue same feature\ngit pull origin main\n# Add authentication logic (3 hours work)\ngit commit -m \"Implement authentication service\"\ngit push origin main  # Another integration, feature still incomplete\n\n# Next day: Complete feature\ngit pull origin main\n# Wire up controller (2 hours work)\ngit commit -m \"Add authentication endpoints\"\ngit push origin main  # Feature now complete across 3 commits\n```\n\n**Hiding Incomplete Work:**\n\n```typescript\n// Option 1: Feature Flags\nexport const handler = async (req, res) => {\n  if (featureFlags.isEnabled('new-auth')) {\n    return newAuthenticationFlow(req, res);\n  }\n  return legacyAuthenticationFlow(req, res);\n};\n\n// Option 2: Keystone Interface (abstraction layer)\ninterface AuthService {\n  authenticate(credentials: Credentials): Promise<User>;\n}\n\n// Old implementation still works\nclass LegacyAuthService implements AuthService {\n  async authenticate(credentials: Credentials) {\n    // Existing logic\n  }\n}\n\n// New implementation being built incrementally\nclass JWTAuthService implements AuthService {\n  async authenticate(credentials: Credentials) {\n    // New JWT-based logic (partially complete, but doesn't break abstraction)\n  }\n}\n\n// Application uses interface, can swap when ready\nconst authService: AuthService = config.useNewAuth\n  ? new JWTAuthService()\n  : new LegacyAuthService();\n```\n\n**Strengths:**\n- ✅ Highest possible integration frequency\n- ✅ Smallest merges\n- ✅ Earliest conflict detection\n- ✅ Supports continuous refactoring\n- ✅ Correlates with elite team performance\n\n**Weaknesses:**\n- ❌ Requires rigorous testing discipline\n- ❌ No clear feature completion celebration\n- ❌ Code exists in mainline before feature activation\n- ❌ Difficult without healthy branch practices\n\n**When to Use:**\n- High-performing commercial teams\n- Projects with strong testing culture\n- Teams comfortable with feature flags\n- Continuous delivery environments\n\n### Feature Branching vs Continuous Integration\n\n**The Fundamental Trade-off:**\n\n```\nFeature Branching:\n└─ Integration Frequency = Feature Length\n   └─ Long features → delayed integration → larger merges\n\nContinuous Integration:\n└─ Integration Frequency = Daily (regardless of feature length)\n   └─ Long features → many small integrations → smaller merges\n```\n\n**Decision Framework:**\n\n| Factor | Feature Branching | Continuous Integration |\n|--------|------------------|----------------------|\n| Team trust | Low (open-source) | High (commercial) |\n| Testing maturity | Can be minimal | Must be strong |\n| Feature flags | Not needed | Essential |\n| Refactoring | Discouraged | Encouraged |\n| Integration | When feature done | Daily |\n| Performance correlation | Lower | Higher (DevOps data) |\n\n**Context Matters:** Neither is universally better. Choose based on team context, not dogma.\n\n---\n\n## Code Review Patterns\n\n### Pre-Integration Review\n\nEvery mainline commit must be peer-reviewed before merge.\n\n**Workflow:**\n```\n1. Developer completes work on branch\n2. Creates pull request\n3. Reviewer provides feedback\n4. Developer addresses feedback\n5. Reviewer approves\n6. Code merged to mainline\n```\n\n**Popular With:**\n- GitHub Pull Requests\n- Open-source projects\n- High-verification contexts (medical, financial)\n\n**Strengths:**\n- ✅ Quality gate before integration\n- ✅ Knowledge sharing\n- ✅ Catches issues early\n- ✅ Educational for junior developers\n\n**Weaknesses:**\n- ❌ Introduces latency (reduces integration frequency)\n- ❌ Can become bottleneck\n- ❌ Reviews delayed by days → stale branches\n\n**Best Practices:**\n```\n✅ Review within 24 hours (hours better than days)\n✅ Keep PRs small (< 400 lines changed)\n✅ Automate style/lint checks (don't waste review time)\n✅ Clear review criteria\n✅ Constructive, educational feedback\n\n❌ Week-old PRs with no review\n❌ 2,000 line PRs\n❌ Nitpicking formatting in reviews\n❌ Blocking approvals on subjective preferences\n```\n\n**Alternatives:**\n- **Pair Programming**: Continuous real-time review\n- **Post-Commit Refinement**: Review after merge, create cleanup commits\n- **Minimal Review**: High-trust teams review only risky changes\n\n### Ship/Show/Ask\n\nModern workflow combining pull requests with continuous integration principles.\n\n**Three Categories:**\n\n**Ship:** Merge directly to mainline without review\n```typescript\n// Examples:\n- Routine bug fixes following established patterns\n- Documentation updates\n- Minor refactorings\n- Configuration changes\n```\n\n**Show:** Create PR, merge immediately after automated checks (no approval wait)\n```typescript\n// Examples:\n- Demonstrating new technique\n- Large refactoring for team awareness\n- Code improvements worth discussing\n- Educational changes\n\n// Workflow\ngit push origin feature/refactor-auth\n# Create PR titled \"[SHOW] Refactor authentication service\"\n# Automated checks pass → merge immediately\n# Team reviews asynchronously, provides feedback for next time\n```\n\n**Ask:** Create PR, wait for feedback before merging\n```typescript\n// Examples:\n- Uncertain approaches\n- Architectural decisions\n- Experimental implementations\n- Breaking changes\n\n// Workflow\ngit push origin feature/new-architecture\n# Create PR titled \"[ASK] Proposal: Switch to event-driven architecture\"\n# Wait for team discussion and approval\n# Address feedback → merge\n```\n\n**Implementation Requirements:**\n1. Code approval NOT mandatory for merging\n2. Developers control their own merges (decide Show vs Ask)\n3. Continuous integration practices (feature flags, tests)\n4. Short-lived branches with frequent rebasing\n\n**Team Balance:**\n```\nJunior developers:\n├─ Ship: 30% (routine tasks)\n├─ Show: 40% (learning opportunities)\n└─ Ask: 30% (uncertain changes)\n\nSenior engineers:\n├─ Ship: 60% (established patterns)\n├─ Show: 30% (innovations to share)\n└─ Ask: 10% (architectural decisions)\n\nNew teams:\n├─ Ship: 20%\n├─ Show: 40% (knowledge building)\n└─ Ask: 40% (uncertainty common)\n\nEstablished teams:\n├─ Ship: 70% (high trust)\n├─ Show: 20%\n└─ Ask: 10%\n```\n\n**Benefits:**\n- ✅ Preserves high integration frequency\n- ✅ Asynchronous collaboration\n- ✅ Reduces PR bottlenecks\n- ✅ Maintains code quality\n- ✅ Builds team trust\n\n---\n\n## Path to Production Patterns\n\n### Release Branch\n\nStabilization branch accepting only bug fixes for production readiness.\n\n**Workflow:**\n```\n1. Copy mainline to release branch (release/v2.5)\n2. Continue new features on mainline\n3. Apply only bug fixes to release branch\n4. Tag release when stable (v2.5.0)\n5. Cherry-pick critical fixes back to mainline\n```\n\n**Example:**\n```bash\n# Cut release branch\ngit checkout -b release/v2.5 main\n\n# Mainline continues with new features\ngit checkout main\ngit commit -m \"Add feature for v2.6\"\n\n# Fix bug on release branch\ngit checkout release/v2.5\ngit commit -m \"Fix critical bug in authentication\"\ngit tag v2.5.0\n\n# Cherry-pick fix to mainline\ngit checkout main\ngit cherry-pick <commit-hash>  # Ensure mainline gets the fix\n```\n\n**Multiple Active Releases:**\n```bash\n# Maintain multiple release branches\nrelease/v2.4  # Production (critical fixes only)\nrelease/v2.5  # Next release (stabilization)\nmain          # Future work (v2.6 features)\n\n# Apply security fix to all\ngit checkout release/v2.4\ngit commit -m \"Security fix\"\ngit tag v2.4.3\n\ngit checkout release/v2.5\ngit cherry-pick <fix-commit>\ngit tag v2.5.1\n\ngit checkout main\ngit cherry-pick <fix-commit>\n```\n\n**When to Use:**\n- Mainline not stable enough for direct release\n- Multiple production versions supported\n- Extended stabilization period needed\n\n**When to Avoid:**\n- High-performing teams with healthy mainline\n- Continuous delivery environments\n- Single production version\n\n### Maturity Branch\n\nLong-lived branch marking latest version at each deployment stage.\n\n**Purpose:** Track which commit reached each environment.\n\n**Structure:**\n```\nmain          # Latest integrated work\nstaging       # Currently in staging environment\nproduction    # Currently in production\n```\n\n**Implementation:**\n```bash\n# Deploy commit 7a3f2 to staging\ngit checkout staging\ngit reset --hard 7a3f2  # Point staging to specific commit\ngit push --force origin staging  # Trigger staging deployment\n\n# Later, promote to production\ngit checkout production\ngit reset --hard 7a3f2\ngit push --force origin production  # Trigger production deployment\n```\n\n**Alternative: Tags Instead of Branches**\n```bash\n# Use tags for same purpose (cleaner)\ngit tag staging-762 7a3f2\ngit tag production-761 5b9c3\n\n# List what's where\ngit tag | grep staging  # See staging history\ngit tag | grep production\n```\n\n**When to Use:**\n- Improve workflow visibility\n- Trigger automated deployments\n- Track deployment history\n\n**Prefer Tags When:**\n- No commits needed on branches\n- Simplicity matters\n- Git history clarity important\n\n### Environment Branch\n\n❌ **Anti-Pattern:** Branch per environment with configuration commits.\n\n**Don't Do This:**\n```bash\n# ❌ Bad: Different code per environment\ngit checkout staging\n# Modify config files for staging database\ngit commit -m \"Staging config\"\n\ngit checkout production\n# Modify config files for production database\ngit commit -m \"Production config\"\n\n# Problem: Same version behaves differently in each environment!\n```\n\n**✅ Correct Approach:**\n```typescript\n// Same code, different configuration\n// config.ts\nexport const config = {\n  database: {\n    host: process.env.DB_HOST || 'localhost',\n    port: parseInt(process.env.DB_PORT || '5432'),\n    name: process.env.DB_NAME || 'app_db'\n  },\n  apiUrl: process.env.API_URL || 'http://localhost:3000'\n};\n\n// Environment variables (not in git)\n// .env.staging\nDB_HOST=staging-db.example.com\nAPI_URL=https://staging-api.example.com\n\n// .env.production\nDB_HOST=prod-db.example.com\nAPI_URL=https://api.example.com\n```\n\n**Rule:** \"You should be able to check out any version and run it in any environment.\"\n\n### Hotfix Branch\n\nEmergency branch for critical production defects.\n\n**With Release Branches:**\n```bash\n# Production is on release/v2.5\ngit checkout release/v2.5\ngit checkout -b hotfix/security-vulnerability\n\n# Apply fix\ngit commit -m \"Fix security vulnerability\"\n\n# Merge to release branch\ngit checkout release/v2.5\ngit merge hotfix/security-vulnerability\ngit tag v2.5.1\n\n# Deploy v2.5.1 to production\n\n# Cherry-pick to mainline\ngit checkout main\ngit cherry-pick <hotfix-commit>\n```\n\n**With Continuous Delivery:**\n```bash\n# Production = latest main\ngit checkout main\ngit checkout -b hotfix/critical-bug\n\n# Fix and test\ngit commit -m \"Fix critical bug\"\n\n# Merge to main and deploy\ngit checkout main\ngit merge hotfix/critical-bug\n# Automated pipeline deploys to production\n```\n\n**Key Practice:** Hotfix becomes highest priority. Freeze other work until hotfix integrated to prevent conflicts.\n\n### Release Train\n\nRelease on fixed schedule; features choose which train.\n\n**Schedule Example:**\n```\nEvery 2 weeks:\n├─ Week 1: Soft freeze (critical fixes only)\n├─ Week 2: Hard freeze → stabilization\n└─ Release day: Deploy to production\n\nTimeline:\nDay 0:  Cut release branch (v2.5)\nDay 7:  Soft freeze (no new features to v2.5)\nDay 10: Hard freeze (bug fixes only)\nDay 14: Release v2.5\nDay 14: Cut next release branch (v2.6)\n```\n\n**Developer Workflow:**\n```typescript\n// Feature ready on Day 3 → targets current train (v2.5)\ngit checkout release/v2.5\ngit merge feature/user-search\n\n// Feature ready on Day 8 → missed soft freeze, targets next train (v2.6)\ngit checkout release/v2.6\ngit merge feature/admin-panel\n\n// Feature ready on Day 13 → targets v2.7 (two trains away)\ngit checkout release/v2.7\ngit merge feature/analytics\n```\n\n**When to Use:**\n- Significant release friction (app store reviews, approval boards)\n- Predictable release schedules needed\n- Transitioning toward continuous delivery\n\n**Limitations:**\n- Features completed early wait for next train\n- Coordination overhead managing multiple trains\n\n**Better Alternative:**\nRelease directly from healthy mainline whenever business ready.\n\n### Release-Ready Mainline\n\nKeep mainline in production-ready state; release by tagging any commit.\n\n**Practices:**\n- Continuous Integration (daily+ commits)\n- Healthy Branch (every commit passes tests)\n- Deployment Pipeline (comprehensive automated checks)\n- Feature Flags (hide incomplete work)\n\n**Workflow:**\n```bash\n# Every commit is releasable\ngit log main --oneline\na3c2f1d Add user profile feature (behind feature flag)\nb5d3e2c Fix pagination bug\nc7f4a3b Refactor authentication service\nd9g6b4e Improve search performance\n\n# Business decides: \"Let's release d9g6b4e to production\"\ngit tag production-release-47 d9g6b4e\n# Automated deployment to production\n\n# Or with Continuous Deployment\n# Every commit to main automatically deploys\ngit push origin main  # → Automatic production deployment\n```\n\n**Continuous Delivery vs Continuous Deployment:**\n```\nContinuous Delivery:\n└─ Every commit CAN be released\n   └─ Business decides WHEN to release\n\nContinuous Deployment:\n└─ Every commit IS released\n   └─ Automatic deployment after pipeline passes\n```\n\n**Prerequisites:**\n- ✅ High-frequency integration discipline\n- ✅ Strong testing culture (comprehensive automated tests)\n- ✅ Deployment pipeline maturity\n- ✅ Feature flags for incomplete work\n- ✅ Monitoring and rollback capabilities\n\n**Benefits:**\n- Simplicity (no special release branches)\n- Rapid feature delivery\n- Production-readiness always visible\n- Reduced stress through regular rhythm\n\n**Context Dependency:**\n- Excellent for teams with mature practices\n- May be counterproductive for teams struggling with integration\n- Start with Release Branches, evolve toward release-ready mainline\n\n---\n\n## Named Workflows\n\n### Git-flow\n\nNamed-branch workflow with develop/main separation and typed branches.\n\n**Structure:**\n```\nmain                    # Production releases only (tagged)\ndevelop                 # Integration branch for features\nfeature/*              # Feature development\nrelease/*              # Release stabilization\nhotfix/*               # Production emergency fixes\n```\n\n**Workflow:**\n```bash\n# Start feature\ngit checkout -b feature/user-authentication develop\n\n# Complete feature\ngit checkout develop\ngit merge feature/user-authentication\n\n# Start release\ngit checkout -b release/v2.5 develop\n\n# Stabilize release\ngit checkout release/v2.5\n# ... bug fixes ...\n\n# Deploy to production\ngit checkout main\ngit merge release/v2.5\ngit tag v2.5.0\n\n# Merge fixes back to develop\ngit checkout develop\ngit merge release/v2.5\n```\n\n**Characteristics:**\n- Develop branch as main integration point\n- Main only receives tagged releases\n- Structured branch naming\n\n**When to Use:**\n- Teams wanting clear separation of features/releases\n- Scheduled release cycles\n- Multiple active release versions\n\n**Drawbacks:**\n- More complex than needed for many teams\n- Lower integration frequency (features accumulate on develop)\n- More merge points = more overhead\n\n### GitHub Flow\n\nMinimalist workflow: main always deployable, features on branches, pull requests for integration.\n\n**Structure:**\n```\nmain                    # Always deployable\nfeature/*              # Short-lived feature branches\n```\n\n**Workflow:**\n```bash\n# 1. Create feature branch\ngit checkout -b feature/add-search main\n\n# 2. Commit changes\ngit commit -m \"Implement search functionality\"\n\n# 3. Push and create pull request\ngit push origin feature/add-search\n# Open PR on GitHub\n\n# 4. Review, discuss, update\n# ... address feedback ...\n\n# 5. Merge to main after approval\n# PR merged on GitHub\n\n# 6. Deploy (automatically or manually)\n# Continuous delivery: deploy main to production\n```\n\n**Characteristics:**\n- Single long-lived branch (main)\n- Pull requests for all changes\n- Main always deployable\n\n**When to Use:**\n- Teams practicing continuous delivery\n- Simple deployment workflows\n- Projects without complex release management\n\n### Trunk-Based Development\n\nSynonym for Continuous Integration; emphasizes single mainline (trunk).\n\n**Core Principle:** Daily integration to trunk; short-lived branches (< 1 day) or no branches.\n\n**Strict Interpretation:**\n```bash\n# No branches, commit directly to trunk\ngit checkout main\n# Make change\ngit commit -m \"Add feature\"\ngit push origin main  # Multiple times per day\n```\n\n**Pragmatic Interpretation:**\n```bash\n# Very short-lived branches (< 1 day)\ngit checkout -b temp-refactor main\n# Work for few hours\ngit push origin temp-refactor\n# Create PR, merge same day\ngit checkout main\ngit merge temp-refactor\ngit branch -d temp-refactor\n```\n\n**Key Techniques:**\n- Feature flags for incomplete work\n- Branch by abstraction for large changes\n- Daily integration (minimum)\n- No long-lived feature branches\n\n**When to Use:**\n- High-performing teams\n- Continuous delivery environments\n- Projects with mature testing\n\n**Modern Context:** Term emerged as \"Continuous Integration\" experienced semantic diffusion (tools called \"CI\" but not practicing actual continuous integration).\n\n---\n\n## Best Practices\n\n### Integration Frequency\n\n**The Golden Rule:** \"If it hurts, do it more often.\"\n\n```\nLow Frequency:\n├─ Weekly integrations\n├─ Large merges (hundreds of files)\n├─ Fear of breaking things\n├─ Conflicts take hours to resolve\n└─ Result: Avoid refactoring, avoid integration → code quality declines\n\nHigh Frequency:\n├─ Daily (or multiple times daily) integrations\n├─ Small merges (10-50 files)\n├─ Routine, not scary\n├─ Conflicts resolved in minutes\n└─ Result: Confident refactoring, continuous improvement\n```\n\n**Research Evidence:** Elite teams integrate notably more often (State of DevOps Report).\n\n### Self-Testing Code\n\n**Essential for High-Frequency Integration:**\n\n```typescript\n// Every commit must include tests\n// auth.service.ts\nexport class AuthService {\n  async authenticate(credentials: Credentials): Promise<User> {\n    // Implementation\n  }\n}\n\n// auth.service.test.ts\ndescribe('AuthService', () => {\n  it('should authenticate valid credentials', async () => {\n    const service = new AuthService();\n    const user = await service.authenticate({ username: 'test', password: 'pass' });\n    expect(user).toBeDefined();\n  });\n\n  it('should reject invalid credentials', async () => {\n    const service = new AuthService();\n    await expect(\n      service.authenticate({ username: 'test', password: 'wrong' })\n    ).rejects.toThrow();\n  });\n});\n```\n\n**Test Suite Speed:**\n```\nCommit Suite (must be fast):\n└─ Unit tests: < 5 minutes\n└─ Integration tests: < 10 minutes total\n\nDeployment Pipeline (can be slower):\n└─ E2E tests: 30-60 minutes\n└─ Performance tests: 60+ minutes\n└─ Security scans: varies\n```\n\n### Modularity\n\n**Well-Structured Code Reduces Conflicts:**\n\n```typescript\n// ❌ Monolithic: Everyone edits same file\n// app.ts (5000 lines)\nexport class App {\n  authenticateUser() { /* ... */ }\n  processOrder() { /* ... */ }\n  generateReport() { /* ... */ }\n  sendEmail() { /* ... */ }\n  // ... hundreds more methods\n}\n\n// Developer A edits authenticateUser: conflict\n// Developer B edits processOrder: conflict\n// Same file = textual conflicts even though unrelated changes\n\n// ✅ Modular: Changes localized\n// auth/auth.service.ts\nexport class AuthService {\n  authenticateUser() { /* ... */ }\n}\n\n// orders/order.service.ts\nexport class OrderService {\n  processOrder() { /* ... */ }\n}\n\n// reports/report.service.ts\nexport class ReportService {\n  generateReport() { /* ... */ }\n}\n\n// Developer A edits AuthService: no conflict\n// Developer B edits OrderService: no conflict\n// Different files = no textual conflicts\n```\n\n**Key Insight:** \"Feature Branching is a poor man's modular architecture\" (Dan Bodart). Good design reduces need for complex branching.\n\n### Automation Reduces Friction\n\n**Every Minute of Friction Matters:**\n\n```\nManual Process:\n├─ Create PR: 2 minutes\n├─ Wait for approval: 4 hours (context switch cost)\n├─ Manual deploy: 15 minutes\n├─ Manual testing: 30 minutes\n└─ Total: ~5 hours → discourages frequent integration\n\nAutomated Process:\n├─ Create PR: 1 minute (CLI tool)\n├─ Automated checks: 10 minutes (parallel)\n├─ Auto-deploy on merge: 5 minutes\n├─ Automated tests: included in checks\n└─ Total: ~15 minutes → enables frequent integration\n```\n\n**Automation Priorities:**\n1. Automated testing (highest ROI)\n2. Automated builds\n3. Automated deployments\n4. Automated code quality checks\n5. Automated PR workflows\n\n### Team Trust\n\n**High Trust vs Low Trust:**\n\n```\nHigh Trust (Commercial Teams):\n├─ Pair programming (continuous review)\n├─ Post-commit refinement reviews\n├─ Ship/Show/Ask (self-directed)\n├─ Minimal approval gates\n└─ Frequent integration\n\nLow Trust (Open-Source):\n├─ Pre-integration review required\n├─ Multiple approvers\n├─ Fork-and-PR workflow\n├─ Strict contribution guidelines\n└─ Feature branching with review\n```\n\n**Building Trust:**\n- Consistent code quality\n- Comprehensive testing\n- Good communication\n- Shared coding standards\n- Mentorship programs\n\n---\n\n## Common Pitfalls\n\n### Integration Fear Loop\n\n```\nLow Integration Frequency\n    ↓\nLarge, Complex Merges\n    ↓\nFear of Breaking Things\n    ↓\nAvoid Refactoring\n    ↓\nCode Quality Declines\n    ↓\nEven Larger Merges\n    ↓\n[Loop continues...]\n```\n\n**Breaking the Cycle:**\n1. Increase integration frequency (even if painful initially)\n2. Add automated testing\n3. Improve modularity\n4. Build team trust\n5. Celebrate successful integrations\n\n### Long-Lived Feature Branches\n\n```\n❌ Problems:\nDay 1:  Branch created, 5 files changed\nDay 5:  20 files changed, mainline diverged (30 commits)\nDay 10: 50 files changed, mainline diverged (100 commits)\nDay 15: Merge attempt: 200 conflicts, semantic conflicts invisible\nDay 16: Debugging merge issues\nDay 17: Finally merged, production breaks due to semantic conflict\n\n✅ Alternative (Continuous Integration):\nDay 1:  5 files changed, commit to mainline\nDay 2:  10 more files, commit to mainline\nDay 3:  15 more files, commit to mainline\n...\nDay 15: Feature complete (15 small merges, no conflicts)\n```\n\n### Environment Branches\n\n```\n❌ Anti-Pattern:\nstaging branch:  config.db = \"staging-db.com\"\nproduction branch: config.db = \"production-db.com\"\n\nProblem: Can't test exact production code in staging\n\n✅ Correct:\nSame code everywhere, environment variables differ:\n.env.staging:    DB_HOST=staging-db.com\n.env.production: DB_HOST=production-db.com\n```\n\n### Metrics Without Context\n\n```\n❌ Misleading Metrics:\n- \"We have 20 branches!\" (Are they short-lived or abandoned?)\n- \"We merge 50 PRs/week!\" (After days or within hours?)\n- \"100% code review!\" (Timely or blocking integration?)\n\n✅ Meaningful Metrics:\n- Integration frequency (commits to main per day)\n- Time from commit to production\n- Mean time to recovery (MTTR)\n- Deployment frequency\n- Change failure rate\n```\n\n---\n\n## Pattern Selection Guide\n\n### Choose Based On Context\n\n**Team Maturity:**\n```\nBeginner Teams:\n└─ Start: Feature Branching + Pre-Integration Review + Release Branches\n└─ Goal: Build testing habits, learn version control\n└─ Timeline: 6-12 months\n\nIntermediate Teams:\n└─ Current: Shorter feature branches, faster reviews\n└─ Goal: Daily integration, automated testing\n└─ Timeline: 6-12 months\n\nElite Teams:\n└─ Current: Continuous Integration, Release-Ready Mainline\n└─ Maintain: High frequency, strong testing, minimal branching\n```\n\n**Project Type:**\n```\nOpen-Source:\n└─ Feature Branching + Fork-and-PR + Pre-Integration Review\n└─ Reason: Untrusted contributors, asynchronous collaboration\n\nCommercial Product:\n└─ Continuous Integration + Ship/Show/Ask + Release-Ready Mainline\n└─ Reason: Trusted team, rapid delivery, high frequency\n\nRegulated Industry:\n└─ Feature Branching + Extensive Testing + Release Branches\n└─ Reason: Audit trails, compliance, risk mitigation\n```\n\n**Release Friction:**\n```\nLow Friction (Modern SaaS):\n└─ Release-Ready Mainline + Continuous Deployment\n└─ Can release anytime with one click\n\nMedium Friction (Traditional Enterprise):\n└─ Release Branches + Scheduled Releases\n└─ Releases require coordination but predictable\n\nHigh Friction (Mobile Apps):\n└─ Release Trains + Release Branches\n└─ App store reviews create multi-week delay\n```\n\n### Decision Tree\n\n```\nStart Here: What's your integration frequency capability?\n\nCan your team commit to mainline daily?\n├─ Yes → Continuous Integration\n│   ├─ Strong testing? → Release-Ready Mainline\n│   └─ Building tests? → Release Branches\n│\n└─ No → Feature Branching\n    ├─ Open-source? → Pre-Integration Review required\n    ├─ Commercial? → Consider Ship/Show/Ask\n    └─ Timeline to daily integration: 6-12 months\n```\n\n---\n\n## Key Takeaways\n\n1. **Integration Frequency Matters Most**: Small, frequent merges safer than large, infrequent ones\n2. **\"If It Hurts, Do It More Often\"**: Counter-intuitive but proven by research\n3. **Healthy Branch is Foundation**: Can't do high-frequency integration without good testing\n4. **Context Over Dogma**: No universal best practice; choose patterns based on team context\n5. **Modularity Enables Everything**: Good architecture reduces conflicts regardless of strategy\n6. **Team Trust Critical**: High-trust teams benefit from minimal gates; low-trust needs reviews\n7. **Automation Reduces Friction**: Every manual step discourages frequent integration\n8. **Elite Teams Integrate More**: DevOps research shows correlation with performance\n9. **Feature Branching vs Continuous Integration**: Fundamentally different philosophies, both valid in context\n10. **Evolve Over Time**: Start where team is comfortable, gradually increase integration frequency\n\n**Strategic Goal:** \"Branches should be integrated frequently and efforts focused on a healthy mainline that can be deployed into production with minimal effort.\"\n\n**Remember:** Version control patterns are means to an end (rapid, reliable software delivery), not ends in themselves. Choose patterns that enable your team to deliver quality software frequently and safely.\n",
    "original/enterprise-patterns/base-patterns.md": "# Base Patterns\n\n## Overview\n\nBase patterns are foundational building blocks used throughout enterprise applications. They provide reusable solutions to common structural and organizational problems.\n\n## Pattern Categories\n\n| Category | Patterns | Purpose |\n|----------|---------|---------|\n| Value Objects | Value Object, Money, Special Case | Represent immutable concepts |\n| Service Access | Registry, Service Locator, Separated Interface | Manage service dependencies |\n| Data Handling | Record Set, Mapper | Work with data structures |\n| Code Organization | Layer Supertype, Plugin | Organize and extend code |\n\n---\n\n## Value Object\n\n### Definition\n\n**A small object that represents a simple entity whose equality is not based on identity but on value.**\n\n### Purpose\n\nModel concepts that are defined by their value, not their identity. Value objects are immutable and can be freely shared.\n\n### When to Use\n\n✅ **Good For:**\n- Modeling domain concepts (Email, Address, DateRange)\n- Money and currency\n- Coordinates, colors, measurements\n- Replacing primitive obsession\n- Ensuring immutability\n\n❌ **Not Ideal For:**\n- Entities with identity (User, Order)\n- Mutable state\n- Large objects with many fields\n\n### Example\n\n```typescript\nclass Email {\n  private readonly value: string;\n\n  constructor(email: string) {\n    if (!this.isValid(email)) {\n      throw new Error(`Invalid email: ${email}`);\n    }\n    this.value = email.toLowerCase();\n  }\n\n  private isValid(email: string): boolean {\n    return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email);\n  }\n\n  equals(other: Email): boolean {\n    return this.value === other.value;\n  }\n\n  toString(): string {\n    return this.value;\n  }\n\n  getDomain(): string {\n    return this.value.split('@')[1];\n  }\n}\n\nclass Address {\n  constructor(\n    public readonly street: string,\n    public readonly city: string,\n    public readonly state: string,\n    public readonly zipCode: string,\n    public readonly country: string\n  ) {\n    Object.freeze(this);\n  }\n\n  equals(other: Address): boolean {\n    return (\n      this.street === other.street &&\n      this.city === other.city &&\n      this.state === other.state &&\n      this.zipCode === other.zipCode &&\n      this.country === other.country\n    );\n  }\n\n  toString(): string {\n    return `${this.street}, ${this.city}, ${this.state} ${this.zipCode}`;\n  }\n}\n\nclass DateRange {\n  constructor(\n    public readonly start: Date,\n    public readonly end: Date\n  ) {\n    if (start > end) {\n      throw new Error('Start date must be before end date');\n    }\n    Object.freeze(this);\n  }\n\n  contains(date: Date): boolean {\n    return date >= this.start && date <= this.end;\n  }\n\n  overlaps(other: DateRange): boolean {\n    return this.start <= other.end && this.end >= other.start;\n  }\n\n  lengthInDays(): number {\n    return Math.ceil((this.end.getTime() - this.start.getTime()) / (1000 * 60 * 60 * 24));\n  }\n}\n\n// Usage\nconst email = new Email('user@example.com');\nconst address = new Address('123 Main St', 'Springfield', 'IL', '62701', 'USA');\nconst range = new DateRange(new Date('2024-01-01'), new Date('2024-01-31'));\n\nconsole.log(email.getDomain()); // 'example.com'\nconsole.log(range.lengthInDays()); // 31\n```\n\n### Best Practices\n\n✅ **DO:**\n- Make value objects immutable\n- Implement equality based on value\n- Validate in constructor\n- Use `Object.freeze()` for immutability\n- Override `toString()` for debugging\n\n❌ **DON'T:**\n- Use setters (make fields readonly)\n- Compare by reference\n- Allow invalid state\n- Make value objects entities\n\n---\n\n## Money\n\n### Definition\n\n**Represents monetary values with currency, handling precision and arithmetic correctly.**\n\n### Purpose\n\nAvoid floating-point precision errors and encapsulate currency-specific logic.\n\n### Example\n\n```typescript\nclass Money {\n  private readonly amount: number;\n  private readonly currency: Currency;\n\n  private constructor(amount: number, currency: Currency) {\n    this.amount = Math.round(amount);\n    this.currency = currency;\n    Object.freeze(this);\n  }\n\n  static fromCents(cents: number, currency: Currency): Money {\n    return new Money(cents, currency);\n  }\n\n  static fromDollars(dollars: number, currency: Currency = Currency.USD): Money {\n    return new Money(Math.round(dollars * 100), currency);\n  }\n\n  static zero(currency: Currency = Currency.USD): Money {\n    return new Money(0, currency);\n  }\n\n  get cents(): number {\n    return this.amount;\n  }\n\n  get dollars(): number {\n    return this.amount / 100;\n  }\n\n  add(other: Money): Money {\n    this.assertSameCurrency(other);\n    return new Money(this.amount + other.amount, this.currency);\n  }\n\n  subtract(other: Money): Money {\n    this.assertSameCurrency(other);\n    return new Money(this.amount - other.amount, this.currency);\n  }\n\n  multiply(multiplier: number): Money {\n    return new Money(Math.round(this.amount * multiplier), this.currency);\n  }\n\n  divide(divisor: number): Money {\n    if (divisor === 0) {\n      throw new Error('Cannot divide by zero');\n    }\n    return new Money(Math.round(this.amount / divisor), this.currency);\n  }\n\n  isGreaterThan(other: Money): boolean {\n    this.assertSameCurrency(other);\n    return this.amount > other.amount;\n  }\n\n  isLessThan(other: Money): boolean {\n    this.assertSameCurrency(other);\n    return this.amount < other.amount;\n  }\n\n  equals(other: Money): boolean {\n    return this.amount === other.amount && this.currency === other.currency;\n  }\n\n  private assertSameCurrency(other: Money): void {\n    if (this.currency !== other.currency) {\n      throw new Error(`Cannot operate on different currencies: ${this.currency} and ${other.currency}`);\n    }\n  }\n\n  toString(): string {\n    return `${this.currency} ${(this.amount / 100).toFixed(2)}`;\n  }\n\n  format(): string {\n    const formatter = new Intl.NumberFormat('en-US', {\n      style: 'currency',\n      currency: this.currency\n    });\n    return formatter.format(this.dollars);\n  }\n}\n\nenum Currency {\n  USD = 'USD',\n  EUR = 'EUR',\n  GBP = 'GBP',\n  JPY = 'JPY'\n}\n\n// Usage\nconst price = Money.fromDollars(99.99);\nconst tax = price.multiply(0.08);\nconst total = price.add(tax);\n\nconsole.log(total.format()); // \"$107.99\"\n\n// Safe currency handling\nconst usd = Money.fromDollars(100, Currency.USD);\nconst eur = Money.fromDollars(100, Currency.EUR);\n// usd.add(eur); // Throws error: different currencies\n```\n\n### Best Practices\n\n✅ **DO:**\n- Store amounts as integers (cents)\n- Check currency compatibility\n- Use precise arithmetic\n- Provide formatting methods\n- Make immutable\n\n❌ **DON'T:**\n- Use floating-point for money\n- Mix currencies without conversion\n- Allow negative amounts without validation\n- Use primitives for money\n\n---\n\n## Special Case\n\n### Definition\n\n**A subclass that provides special behavior for particular cases, replacing conditional logic.**\n\n### Purpose\n\nEliminate null checks and special-case conditionals with polymorphism.\n\n### Example\n\n```typescript\n// Instead of null checks everywhere\nclass CustomerService {\n  getDiscount(customer: Customer | null): number {\n    if (customer === null) {\n      return 0;\n    }\n    if (customer.isPreferred()) {\n      return 0.15;\n    }\n    return 0.05;\n  }\n}\n\n// Use Special Case pattern\nabstract class Customer {\n  abstract getName(): string;\n  abstract getDiscount(): number;\n  abstract isPreferred(): boolean;\n  abstract sendEmail(message: string): void;\n}\n\nclass RealCustomer extends Customer {\n  constructor(\n    private name: string,\n    private email: string,\n    private preferred: boolean = false\n  ) {\n    super();\n  }\n\n  getName(): string {\n    return this.name;\n  }\n\n  getDiscount(): number {\n    return this.preferred ? 0.15 : 0.05;\n  }\n\n  isPreferred(): boolean {\n    return this.preferred;\n  }\n\n  sendEmail(message: string): void {\n    emailService.send(this.email, message);\n  }\n}\n\nclass GuestCustomer extends Customer {\n  getName(): string {\n    return 'Guest';\n  }\n\n  getDiscount(): number {\n    return 0; // No discount for guests\n  }\n\n  isPreferred(): boolean {\n    return false;\n  }\n\n  sendEmail(message: string): void {\n    // Do nothing - guests don't have email\n  }\n}\n\nclass CustomerRepository {\n  findById(id: string): Customer {\n    const data = this.db.findById(id);\n    return data ? new RealCustomer(data.name, data.email, data.preferred) : new GuestCustomer();\n  }\n}\n\n// Usage - no null checks needed!\nconst customer = customerRepo.findById('123');\nconst discount = customer.getDiscount(); // Works for both real and guest\ncustomer.sendEmail('Welcome!'); // Safe - guest does nothing\n```\n\n### Common Special Cases\n\n```typescript\n// Null Object\nclass NullLogger implements Logger {\n  log(message: string): void {\n    // Do nothing\n  }\n}\n\n// Unknown Case\nclass UnknownProduct extends Product {\n  getName(): string {\n    return 'Unknown Product';\n  }\n\n  getPrice(): Money {\n    return Money.zero();\n  }\n}\n\n// Default Case\nclass DefaultConfiguration extends Configuration {\n  get(key: string): string {\n    return this.defaults[key] || '';\n  }\n}\n```\n\n### Best Practices\n\n✅ **DO:**\n- Replace null checks with special case objects\n- Implement same interface as real object\n- Use for common special cases (null, unknown, default)\n- Make behavior explicit\n\n❌ **DON'T:**\n- Use for rarely occurring cases\n- Create too many special cases\n- Hide important business logic in special cases\n\n---\n\n## Registry\n\n### Definition\n\n**A well-known object that other objects can use to find common objects and services.**\n\n### Purpose\n\nProvide global access to frequently used objects without global variables.\n\n### Example\n\n```typescript\nclass ServiceRegistry {\n  private static instance: ServiceRegistry;\n  private services = new Map<string, any>();\n\n  private constructor() {}\n\n  static getInstance(): ServiceRegistry {\n    if (!ServiceRegistry.instance) {\n      ServiceRegistry.instance = new ServiceRegistry();\n    }\n    return ServiceRegistry.instance;\n  }\n\n  register<T>(key: string, service: T): void {\n    this.services.set(key, service);\n  }\n\n  get<T>(key: string): T {\n    const service = this.services.get(key);\n    if (!service) {\n      throw new Error(`Service not found: ${key}`);\n    }\n    return service as T;\n  }\n\n  has(key: string): boolean {\n    return this.services.has(key);\n  }\n\n  clear(): void {\n    this.services.clear();\n  }\n}\n\n// Type-safe registry\nclass TypedRegistry {\n  private static userRepository: UserRepository;\n  private static orderRepository: OrderRepository;\n\n  static setUserRepository(repo: UserRepository): void {\n    this.userRepository = repo;\n  }\n\n  static getUserRepository(): UserRepository {\n    if (!this.userRepository) {\n      throw new Error('UserRepository not initialized');\n    }\n    return this.userRepository;\n  }\n\n  static setOrderRepository(repo: OrderRepository): void {\n    this.orderRepository = repo;\n  }\n\n  static getOrderRepository(): OrderRepository {\n    if (!this.orderRepository) {\n      throw new Error('OrderRepository not initialized');\n    }\n    return this.orderRepository;\n  }\n}\n\n// Usage\nconst registry = ServiceRegistry.getInstance();\nregistry.register('database', new PostgreSQLDatabase());\nregistry.register('logger', new ConsoleLogger());\n\nconst db = registry.get<Database>('database');\nconst logger = registry.get<Logger>('logger');\n\n// Type-safe usage\nTypedRegistry.setUserRepository(new PostgreSQLUserRepository());\nconst userRepo = TypedRegistry.getUserRepository();\n```\n\n### Best Practices\n\n✅ **DO:**\n- Use for truly global services\n- Make thread-safe if needed\n- Provide clear access methods\n- Consider type-safe alternatives\n\n❌ **DON'T:**\n- Overuse (prefer dependency injection)\n- Create multiple registries\n- Use for business objects\n- Make it a dumping ground\n\n---\n\n## Layer Supertype\n\n### Definition\n\n**A type that acts as the supertype for all types in its layer.**\n\n### Purpose\n\nConsolidate common behavior for all objects in a layer.\n\n### Example\n\n```typescript\n// Domain layer supertype\nabstract class Entity {\n  constructor(public readonly id: string) {}\n\n  equals(other: Entity): boolean {\n    return this.id === other.id;\n  }\n\n  abstract validate(): void;\n}\n\nclass User extends Entity {\n  constructor(\n    id: string,\n    public name: string,\n    public email: Email\n  ) {\n    super(id);\n  }\n\n  validate(): void {\n    if (!this.name) {\n      throw new ValidationError('Name is required');\n    }\n  }\n}\n\nclass Order extends Entity {\n  constructor(\n    id: string,\n    public customerId: string,\n    public items: OrderItem[]\n  ) {\n    super(id);\n  }\n\n  validate(): void {\n    if (this.items.length === 0) {\n      throw new ValidationError('Order must have items');\n    }\n  }\n}\n\n// Repository layer supertype\nabstract class Repository<T extends Entity> {\n  constructor(protected db: Database) {}\n\n  abstract findById(id: string): Promise<T | null>;\n\n  async save(entity: T): Promise<void> {\n    entity.validate(); // Common validation\n    await this.doSave(entity);\n  }\n\n  protected abstract doSave(entity: T): Promise<void>;\n\n  async delete(id: string): Promise<void> {\n    await this.db.execute(\n      `DELETE FROM ${this.getTableName()} WHERE id = $1`,\n      [id]\n    );\n  }\n\n  protected abstract getTableName(): string;\n}\n\nclass UserRepository extends Repository<User> {\n  async findById(id: string): Promise<User | null> {\n    const row = await this.db.queryOne(\n      'SELECT * FROM users WHERE id = $1',\n      [id]\n    );\n    return row ? this.mapToUser(row) : null;\n  }\n\n  protected async doSave(user: User): Promise<void> {\n    await this.db.execute(\n      'INSERT INTO users (id, name, email) VALUES ($1, $2, $3) ON CONFLICT (id) DO UPDATE SET name = $2, email = $3',\n      [user.id, user.name, user.email.toString()]\n    );\n  }\n\n  protected getTableName(): string {\n    return 'users';\n  }\n\n  private mapToUser(row: any): User {\n    return new User(row.id, row.name, new Email(row.email));\n  }\n}\n```\n\n### Best Practices\n\n✅ **DO:**\n- Use for truly common behavior\n- Keep layer supertypes focused\n- Make abstract when appropriate\n- Use for cross-cutting concerns\n\n❌ **DON'T:**\n- Create deep inheritance hierarchies\n- Put layer-specific logic in supertype\n- Force all classes to inherit\n\n---\n\n## Separated Interface\n\n### Definition\n\n**Define an interface in a separate package from its implementation to reduce coupling.**\n\n### Purpose\n\nAllow clients to depend on interfaces without depending on implementations.\n\n### Example\n\n```typescript\n// domain/interfaces/repositories.ts (high-level package)\nexport interface UserRepository {\n  findById(id: string): Promise<User | null>;\n  findByEmail(email: string): Promise<User | null>;\n  save(user: User): Promise<void>;\n}\n\nexport interface OrderRepository {\n  findById(id: string): Promise<Order | null>;\n  findByCustomerId(customerId: string): Promise<Order[]>;\n  save(order: Order): Promise<void>;\n}\n\n// domain/use-cases/create-order.ts (depends on interface)\nimport { UserRepository, OrderRepository } from '../interfaces/repositories';\n\nexport class CreateOrderUseCase {\n  constructor(\n    private userRepo: UserRepository,\n    private orderRepo: OrderRepository\n  ) {}\n\n  async execute(request: CreateOrderRequest): Promise<Order> {\n    const user = await this.userRepo.findById(request.userId);\n    if (!user) {\n      throw new Error('User not found');\n    }\n\n    const order = new Order(user.id, request.items);\n    await this.orderRepo.save(order);\n    return order;\n  }\n}\n\n// infrastructure/repositories/postgresql-user-repository.ts (low-level package)\nimport { UserRepository } from '../../domain/interfaces/repositories';\n\nexport class PostgreSQLUserRepository implements UserRepository {\n  async findById(id: string): Promise<User | null> {\n    // PostgreSQL specific implementation\n  }\n\n  async findByEmail(email: string): Promise<User | null> {\n    // PostgreSQL specific implementation\n  }\n\n  async save(user: User): Promise<void> {\n    // PostgreSQL specific implementation\n  }\n}\n\n// infrastructure/repositories/mongodb-user-repository.ts\nimport { UserRepository } from '../../domain/interfaces/repositories';\n\nexport class MongoDBUserRepository implements UserRepository {\n  async findById(id: string): Promise<User | null> {\n    // MongoDB specific implementation\n  }\n\n  // ... other methods\n}\n\n// main/composition-root.ts (wires everything together)\nimport { CreateOrderUseCase } from '../domain/use-cases/create-order';\nimport { PostgreSQLUserRepository } from '../infrastructure/repositories/postgresql-user-repository';\nimport { PostgreSQLOrderRepository } from '../infrastructure/repositories/postgresql-order-repository';\n\nconst userRepo = new PostgreSQLUserRepository(db);\nconst orderRepo = new PostgreSQLOrderRepository(db);\nconst createOrder = new CreateOrderUseCase(userRepo, orderRepo);\n```\n\n### Best Practices\n\n✅ **DO:**\n- Define interfaces in client package\n- Use for dependency inversion\n- Keep interfaces focused\n- Support multiple implementations\n\n❌ **DON'T:**\n- Create interfaces for every class\n- Put interfaces with implementations\n- Over-abstract simple cases\n\n---\n\n## Plugin\n\n### Definition\n\n**Links classes during configuration rather than compilation to enable extension without modification.**\n\n### Purpose\n\nAllow behavior to be extended without modifying core code.\n\n### Example\n\n```typescript\n// Plugin interface\ninterface ValidationPlugin {\n  name: string;\n  validate(user: User): ValidationResult;\n}\n\n// Core validator with plugin support\nclass UserValidator {\n  private plugins: ValidationPlugin[] = [];\n\n  registerPlugin(plugin: ValidationPlugin): void {\n    this.plugins.push(plugin);\n  }\n\n  validate(user: User): ValidationResult {\n    const results: ValidationResult[] = [];\n\n    // Core validation\n    if (!user.email) {\n      results.push({ valid: false, message: 'Email is required' });\n    }\n\n    // Plugin validations\n    for (const plugin of this.plugins) {\n      const result = plugin.validate(user);\n      results.push(result);\n    }\n\n    const allValid = results.every(r => r.valid);\n    const messages = results.filter(r => !r.valid).map(r => r.message);\n\n    return {\n      valid: allValid,\n      message: messages.join(', ')\n    };\n  }\n}\n\n// Plugin implementations\nclass PasswordStrengthPlugin implements ValidationPlugin {\n  name = 'password-strength';\n\n  validate(user: User): ValidationResult {\n    if (user.password.length < 8) {\n      return { valid: false, message: 'Password must be at least 8 characters' };\n    }\n    return { valid: true, message: '' };\n  }\n}\n\nclass EmailDomainPlugin implements ValidationPlugin {\n  constructor(private allowedDomains: string[]) {}\n\n  name = 'email-domain';\n\n  validate(user: User): ValidationResult {\n    const domain = user.email.getDomain();\n    if (!this.allowedDomains.includes(domain)) {\n      return { valid: false, message: `Email domain ${domain} not allowed` };\n    }\n    return { valid: true, message: '' };\n  }\n}\n\n// Usage\nconst validator = new UserValidator();\nvalidator.registerPlugin(new PasswordStrengthPlugin());\nvalidator.registerPlugin(new EmailDomainPlugin(['company.com']));\n\nconst result = validator.validate(user);\n```\n\n### Plugin Discovery\n\n```typescript\n// Auto-discovery pattern\nclass PluginManager {\n  private plugins = new Map<string, Plugin>();\n\n  async loadPlugins(directory: string): Promise<void> {\n    const files = await fs.readdir(directory);\n\n    for (const file of files) {\n      if (file.endsWith('.plugin.js')) {\n        const pluginModule = await import(path.join(directory, file));\n        const plugin = new pluginModule.default();\n        this.plugins.set(plugin.name, plugin);\n      }\n    }\n  }\n\n  getPlugin(name: string): Plugin | undefined {\n    return this.plugins.get(name);\n  }\n\n  getAllPlugins(): Plugin[] {\n    return Array.from(this.plugins.values());\n  }\n}\n```\n\n### Best Practices\n\n✅ **DO:**\n- Define clear plugin interfaces\n- Version plugin APIs\n- Provide plugin lifecycle hooks\n- Document plugin capabilities\n\n❌ **DON'T:**\n- Make plugins too complex\n- Allow plugins to break core functionality\n- Skip plugin validation\n- Create tight coupling between plugins\n\n---\n\n## Mapper\n\n### Definition\n\n**An object that sets up communication between two independent objects.**\n\n### Purpose\n\nConvert between different representations of data (domain ↔ database, domain ↔ DTO).\n\n### Example\n\n```typescript\nclass UserMapper {\n  toDomain(row: DatabaseRow): User {\n    return new User(\n      row.id,\n      row.name,\n      new Email(row.email),\n      new Date(row.created_at)\n    );\n  }\n\n  toDatabase(user: User): DatabaseRow {\n    return {\n      id: user.id,\n      name: user.name,\n      email: user.email.toString(),\n      created_at: user.createdAt.toISOString()\n    };\n  }\n\n  toDTO(user: User): UserDTO {\n    return {\n      id: user.id,\n      name: user.name,\n      email: user.email.toString(),\n      memberSince: user.createdAt.toISOString()\n    };\n  }\n\n  fromDTO(dto: CreateUserDTO): User {\n    return new User(\n      generateId(),\n      dto.name,\n      new Email(dto.email),\n      new Date()\n    );\n  }\n}\n\n// Bidirectional mapper\nclass OrderMapper {\n  constructor(\n    private productRepo: ProductRepository,\n    private customerRepo: CustomerRepository\n  ) {}\n\n  async toDomain(row: OrderRow, itemRows: OrderItemRow[]): Promise<Order> {\n    const customer = await this.customerRepo.findById(row.customer_id);\n\n    const items = await Promise.all(\n      itemRows.map(async itemRow => {\n        const product = await this.productRepo.findById(itemRow.product_id);\n        return new OrderItem(product, itemRow.quantity);\n      })\n    );\n\n    return new Order(row.id, customer, items, OrderStatus[row.status], new Date(row.created_at));\n  }\n\n  toDatabase(order: Order): { orderRow: OrderRow; itemRows: OrderItemRow[] } {\n    const orderRow = {\n      id: order.id,\n      customer_id: order.customer.id,\n      status: order.status.toString(),\n      created_at: order.createdAt.toISOString()\n    };\n\n    const itemRows = order.items.map(item => ({\n      order_id: order.id,\n      product_id: item.product.id,\n      quantity: item.quantity,\n      price: item.price.cents\n    }));\n\n    return { orderRow, itemRows };\n  }\n}\n```\n\n### Best Practices\n\n✅ **DO:**\n- Create focused mappers\n- Handle null/undefined gracefully\n- Use for boundary crossings\n- Keep mappers stateless\n\n❌ **DON'T:**\n- Put business logic in mappers\n- Create circular dependencies\n- Make mappers too generic\n\n---\n\n## Common Pitfalls\n\n❌ **Primitive Obsession:** Using primitives instead of value objects\n❌ **Null Everywhere:** Not using Special Case pattern\n❌ **Service Locator Overuse:** Using registry instead of dependency injection\n❌ **Deep Inheritance:** Creating complex layer supertype hierarchies\n❌ **Tight Coupling:** Not using separated interfaces\n\n## Key Takeaways\n\n1. **Value Object:** Immutable objects defined by value, not identity\n2. **Money:** Special value object for monetary values with currency\n3. **Special Case:** Replace null checks with polymorphism\n4. **Registry:** Global service access (use sparingly)\n5. **Layer Supertype:** Consolidate common layer behavior\n6. **Separated Interface:** Define interfaces separate from implementations\n7. **Plugin:** Extend behavior without modification\n8. **Mapper:** Convert between representations at boundaries\n",
    "original/enterprise-patterns/concurrency-patterns.md": "# Concurrency Patterns\n\n## Overview\n\nConcurrency patterns handle the challenges of managing data consistency when multiple users or processes access the same data simultaneously. These patterns address conflicts, locking strategies, and transaction isolation.\n\n## Pattern Selection Guide\n\n| Pattern | Lock Scope | Conflict Detection | Performance | Best For |\n|---------|-----------|-------------------|-------------|----------|\n| Optimistic Offline Lock | Record-level | On commit | High read, low write | Low contention scenarios |\n| Pessimistic Offline Lock | Record-level | On acquisition | Lower throughput | High contention scenarios |\n| Coarse-Grained Lock | Multiple records | On acquisition | Reduced overhead | Related entities |\n| Implicit Lock | Automatic | Transparent | Varies | Simple applications |\n\n---\n\n## Optimistic Offline Lock\n\n### Definition\n\n**Prevents conflicts between concurrent business transactions by detecting a conflict and rolling back the transaction.**\n\n### Purpose\n\nAllow multiple users to read and modify data, detecting conflicts only when trying to commit changes.\n\n### When to Use\n\n✅ **Good For:**\n- Low contention scenarios\n- Read-heavy workloads\n- Distributed systems where locks are expensive\n- Long-running business transactions\n- Better user experience (no blocking)\n\n❌ **Not Ideal For:**\n- High contention scenarios (many conflicts)\n- When rollback cost is high\n- Critical updates that must succeed\n\n### Example\n\n```typescript\ninterface Versioned {\n  id: string;\n  version: number;\n}\n\nclass Product implements Versioned {\n  constructor(\n    public id: string,\n    public name: string,\n    public price: number,\n    public version: number = 1\n  ) {}\n}\n\nclass ProductRepository {\n  async save(product: Product): Promise<void> {\n    const current = await this.db.queryOne(\n      'SELECT version FROM products WHERE id = $1',\n      [product.id]\n    );\n\n    if (!current) {\n      await this.db.execute(\n        'INSERT INTO products (id, name, price, version) VALUES ($1, $2, $3, $4)',\n        [product.id, product.name, product.price, product.version]\n      );\n      return;\n    }\n\n    if (current.version !== product.version) {\n      throw new OptimisticLockException(\n        `Product ${product.id} was modified by another user. Expected version ${product.version}, found ${current.version}`\n      );\n    }\n\n    await this.db.execute(\n      'UPDATE products SET name = $1, price = $2, version = version + 1 WHERE id = $3 AND version = $4',\n      [product.name, product.price, product.id, product.version]\n    );\n\n    product.version += 1;\n  }\n}\n\nclass OptimisticLockException extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'OptimisticLockException';\n  }\n}\n\n// Usage\nasync function updateProductPrice(productId: string, newPrice: number) {\n  const maxRetries = 3;\n  let attempt = 0;\n\n  while (attempt < maxRetries) {\n    try {\n      const product = await productRepo.findById(productId);\n      product.price = newPrice;\n      await productRepo.save(product);\n      return;\n    } catch (error) {\n      if (error instanceof OptimisticLockException) {\n        attempt++;\n        if (attempt >= maxRetries) {\n          throw new Error('Failed to update product after multiple retries');\n        }\n        await delay(100 * attempt);\n      } else {\n        throw error;\n      }\n    }\n  }\n}\n```\n\n### Implementation Strategies\n\n**1. Version Number**\n```typescript\nclass VersionedEntity {\n  version: number = 1;\n}\n\n// Increment on each update\nUPDATE entities SET data = $1, version = version + 1\nWHERE id = $2 AND version = $3\n```\n\n**2. Timestamp**\n```typescript\nclass TimestampedEntity {\n  lastModified: Date = new Date();\n}\n\n// Check timestamp hasn't changed\nUPDATE entities SET data = $1, last_modified = NOW()\nWHERE id = $2 AND last_modified = $3\n```\n\n**3. Hash/Checksum**\n```typescript\nclass HashedEntity {\n  checksum: string;\n\n  calculateChecksum(): string {\n    return hash(JSON.stringify(this.data));\n  }\n}\n```\n\n### Best Practices\n\n✅ **DO:**\n- Implement retry logic with exponential backoff\n- Provide clear error messages to users\n- Consider merging changes when possible\n- Use version numbers for simplicity\n- Handle conflicts gracefully\n\n❌ **DON'T:**\n- Retry indefinitely\n- Hide conflicts from users\n- Use optimistic locking for critical updates with high contention\n- Forget to increment version on successful update\n\n---\n\n## Pessimistic Offline Lock\n\n### Definition\n\n**Prevents conflicts by locking data when a user begins to edit it, releasing the lock only when the edit is complete.**\n\n### Purpose\n\nEnsure exclusive access to data during long-running business transactions.\n\n### When to Use\n\n✅ **Good For:**\n- High contention scenarios\n- Critical data that must be updated successfully\n- When cost of conflict is high\n- Financial transactions\n- Inventory management\n\n❌ **Not Ideal For:**\n- Low contention scenarios (unnecessary overhead)\n- Distributed systems (lock coordination complex)\n- Read-heavy workloads\n\n### Example\n\n```typescript\ninterface Lock {\n  resourceId: string;\n  ownerId: string;\n  acquiredAt: Date;\n  expiresAt: Date;\n}\n\nclass LockManager {\n  private locks = new Map<string, Lock>();\n\n  async acquireLock(\n    resourceId: string,\n    ownerId: string,\n    durationMs: number = 30000\n  ): Promise<boolean> {\n    const existing = this.locks.get(resourceId);\n    const now = new Date();\n\n    if (existing) {\n      if (existing.expiresAt > now) {\n        if (existing.ownerId === ownerId) {\n          this.extendLock(resourceId, durationMs);\n          return true;\n        }\n        return false;\n      }\n      this.locks.delete(resourceId);\n    }\n\n    const lock: Lock = {\n      resourceId,\n      ownerId,\n      acquiredAt: now,\n      expiresAt: new Date(now.getTime() + durationMs)\n    };\n\n    await this.db.execute(\n      'INSERT INTO locks (resource_id, owner_id, acquired_at, expires_at) VALUES ($1, $2, $3, $4)',\n      [resourceId, ownerId, lock.acquiredAt, lock.expiresAt]\n    );\n\n    this.locks.set(resourceId, lock);\n    return true;\n  }\n\n  async releaseLock(resourceId: string, ownerId: string): Promise<boolean> {\n    const lock = this.locks.get(resourceId);\n\n    if (!lock || lock.ownerId !== ownerId) {\n      return false;\n    }\n\n    await this.db.execute(\n      'DELETE FROM locks WHERE resource_id = $1 AND owner_id = $2',\n      [resourceId, ownerId]\n    );\n\n    this.locks.delete(resourceId);\n    return true;\n  }\n\n  private extendLock(resourceId: string, durationMs: number): void {\n    const lock = this.locks.get(resourceId);\n    if (lock) {\n      lock.expiresAt = new Date(Date.now() + durationMs);\n    }\n  }\n\n  async cleanupExpiredLocks(): Promise<void> {\n    const now = new Date();\n    for (const [resourceId, lock] of this.locks.entries()) {\n      if (lock.expiresAt <= now) {\n        this.locks.delete(resourceId);\n      }\n    }\n\n    await this.db.execute(\n      'DELETE FROM locks WHERE expires_at <= $1',\n      [now]\n    );\n  }\n}\n\nclass ProductService {\n  constructor(\n    private lockManager: LockManager,\n    private productRepo: ProductRepository\n  ) {}\n\n  async editProduct(productId: string, userId: string): Promise<Product | null> {\n    const acquired = await this.lockManager.acquireLock(productId, userId);\n\n    if (!acquired) {\n      throw new Error('Product is currently being edited by another user');\n    }\n\n    return this.productRepo.findById(productId);\n  }\n\n  async saveProduct(product: Product, userId: string): Promise<void> {\n    const lock = this.lockManager.getLock(product.id);\n\n    if (!lock || lock.ownerId !== userId) {\n      throw new Error('You do not own the lock for this product');\n    }\n\n    await this.productRepo.save(product);\n    await this.lockManager.releaseLock(product.id, userId);\n  }\n\n  async cancelEdit(productId: string, userId: string): Promise<void> {\n    await this.lockManager.releaseLock(productId, userId);\n  }\n}\n```\n\n### Lock Timeout Strategies\n\n**1. Fixed Timeout**\n```typescript\nconst LOCK_DURATION = 30000; // 30 seconds\nawait lockManager.acquireLock(resourceId, userId, LOCK_DURATION);\n```\n\n**2. Heartbeat Extension**\n```typescript\nclass LockHeartbeat {\n  private intervalId?: NodeJS.Timeout;\n\n  start(resourceId: string, userId: string, intervalMs: number = 10000) {\n    this.intervalId = setInterval(async () => {\n      await lockManager.extendLock(resourceId, userId, 30000);\n    }, intervalMs);\n  }\n\n  stop() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n}\n```\n\n**3. User Activity Detection**\n```typescript\nclass ActivityBasedLock {\n  private lastActivity = new Date();\n\n  onUserActivity() {\n    this.lastActivity = new Date();\n    this.extendLockIfNeeded();\n  }\n\n  private async extendLockIfNeeded() {\n    const timeSinceActivity = Date.now() - this.lastActivity.getTime();\n    if (timeSinceActivity < 5000) {\n      await lockManager.extendLock(this.resourceId, this.userId, 30000);\n    }\n  }\n}\n```\n\n### Best Practices\n\n✅ **DO:**\n- Always set lock timeouts to prevent deadlocks\n- Implement lock cleanup for expired locks\n- Provide clear UI feedback when resource is locked\n- Allow lock stealing for administrators\n- Log lock acquisitions and releases\n\n❌ **DON'T:**\n- Lock indefinitely\n- Forget to release locks on errors\n- Lock too many resources at once\n- Use pessimistic locks for read-only operations\n\n---\n\n## Coarse-Grained Lock\n\n### Definition\n\n**Locks a set of related objects with a single lock, simplifying lock management for aggregates.**\n\n### Purpose\n\nReduce locking overhead by locking an entire aggregate rather than individual entities.\n\n### When to Use\n\n✅ **Good For:**\n- Aggregate roots with children\n- Related entities that are always modified together\n- Reducing lock management complexity\n- Domain-driven design aggregates\n\n❌ **Not Ideal For:**\n- Unrelated entities\n- When fine-grained access is needed\n- High-contention on aggregate root\n\n### Example\n\n```typescript\nclass Order {\n  constructor(\n    public id: string,\n    public customerId: string,\n    public items: OrderItem[] = [],\n    public version: number = 1\n  ) {}\n\n  addItem(product: Product, quantity: number) {\n    const item = new OrderItem(product.id, product.price, quantity);\n    this.items.push(item);\n  }\n\n  removeItem(itemId: string) {\n    this.items = this.items.filter(item => item.id !== itemId);\n  }\n\n  get total(): number {\n    return this.items.reduce((sum, item) => sum + item.subtotal, 0);\n  }\n}\n\nclass OrderItem {\n  constructor(\n    public id: string = generateId(),\n    public productId: string,\n    public price: number,\n    public quantity: number\n  ) {}\n\n  get subtotal(): number {\n    return this.price * this.quantity;\n  }\n}\n\nclass OrderRepository {\n  async save(order: Order): Promise<void> {\n    const db = await Database.connect();\n    await db.beginTransaction();\n\n    try {\n      // Lock the aggregate root (coarse-grained lock)\n      const current = await db.queryOne(\n        'SELECT version FROM orders WHERE id = $1 FOR UPDATE',\n        [order.id]\n      );\n\n      if (current && current.version !== order.version) {\n        throw new OptimisticLockException('Order was modified');\n      }\n\n      // Update entire aggregate\n      await db.execute(\n        'UPDATE orders SET customer_id = $1, version = version + 1 WHERE id = $2',\n        [order.customerId, order.id]\n      );\n\n      // Delete and recreate all items (simple approach)\n      await db.execute('DELETE FROM order_items WHERE order_id = $1', [order.id]);\n\n      for (const item of order.items) {\n        await db.execute(\n          'INSERT INTO order_items (id, order_id, product_id, price, quantity) VALUES ($1, $2, $3, $4, $5)',\n          [item.id, order.id, item.productId, item.price, item.quantity]\n        );\n      }\n\n      await db.commit();\n      order.version += 1;\n    } catch (error) {\n      await db.rollback();\n      throw error;\n    }\n  }\n}\n\n// Pessimistic coarse-grained lock\nclass OrderLockManager {\n  async lockOrderAggregate(orderId: string, userId: string): Promise<boolean> {\n    const db = await Database.connect();\n\n    try {\n      // Lock both order and all items in one transaction\n      await db.beginTransaction();\n\n      await db.execute(\n        'SELECT * FROM orders WHERE id = $1 FOR UPDATE',\n        [orderId]\n      );\n\n      await db.execute(\n        'SELECT * FROM order_items WHERE order_id = $1 FOR UPDATE',\n        [orderId]\n      );\n\n      await this.lockManager.acquireLock(`order:${orderId}`, userId);\n\n      await db.commit();\n      return true;\n    } catch (error) {\n      await db.rollback();\n      return false;\n    }\n  }\n}\n```\n\n### Best Practices\n\n✅ **DO:**\n- Use for DDD aggregates\n- Lock at aggregate root level\n- Keep aggregates small\n- Document locking boundaries\n\n❌ **DON'T:**\n- Create overly large aggregates\n- Lock unrelated entities together\n- Mix fine-grained and coarse-grained locks\n\n---\n\n## Implicit Lock\n\n### Definition\n\n**Automatically manages locks without explicit lock/unlock calls, typically through framework or ORM support.**\n\n### Purpose\n\nSimplify concurrency control by having the framework handle locking automatically.\n\n### When to Use\n\n✅ **Good For:**\n- Simple applications\n- Framework-managed transactions\n- Rapid development\n- When framework provides good defaults\n\n❌ **Not Ideal For:**\n- Complex locking requirements\n- Fine-grained control needed\n- Performance-critical applications\n\n### Example\n\n```typescript\n// Using TypeORM with version-based optimistic locking\nimport { Entity, PrimaryGeneratedColumn, Column, VersionColumn } from 'typeorm';\n\n@Entity()\nclass Product {\n  @PrimaryGeneratedColumn('uuid')\n  id: string;\n\n  @Column()\n  name: string;\n\n  @Column('decimal')\n  price: number;\n\n  @VersionColumn()\n  version: number; // Automatically managed by TypeORM\n}\n\n// Repository usage - locking is implicit\nclass ProductService {\n  constructor(private productRepo: Repository<Product>) {}\n\n  async updatePrice(productId: string, newPrice: number): Promise<void> {\n    const product = await this.productRepo.findOneBy({ id: productId });\n\n    if (!product) {\n      throw new Error('Product not found');\n    }\n\n    product.price = newPrice;\n\n    try {\n      await this.productRepo.save(product); // Implicit optimistic lock check\n    } catch (error) {\n      if (error.name === 'OptimisticLockVersionMismatch') {\n        throw new Error('Product was modified by another user');\n      }\n      throw error;\n    }\n  }\n}\n\n// Pessimistic locking with TypeORM\nclass OrderService {\n  async processOrder(orderId: string): Promise<void> {\n    await this.dataSource.transaction(async (manager) => {\n      // Implicit pessimistic lock via FOR UPDATE\n      const order = await manager.findOne(Order, {\n        where: { id: orderId },\n        lock: { mode: 'pessimistic_write' }\n      });\n\n      if (!order) {\n        throw new Error('Order not found');\n      }\n\n      order.status = 'processing';\n      await manager.save(order); // Lock released on transaction commit\n    });\n  }\n}\n```\n\n### Best Practices\n\n✅ **DO:**\n- Understand framework locking behavior\n- Use for standard scenarios\n- Configure lock timeouts\n- Handle lock exceptions\n\n❌ **DON'T:**\n- Rely on implicit locking for complex scenarios\n- Ignore framework documentation\n- Mix implicit and explicit locking strategies\n\n---\n\n## Combining Patterns\n\n### Optimistic + Coarse-Grained\n\n```typescript\nclass OrderAggregate {\n  constructor(\n    public order: Order,\n    public items: OrderItem[],\n    public version: number\n  ) {}\n}\n\nclass OrderRepository {\n  async saveAggregate(aggregate: OrderAggregate): Promise<void> {\n    // Optimistic lock on entire aggregate\n    const result = await this.db.execute(\n      'UPDATE orders SET version = version + 1 WHERE id = $1 AND version = $2',\n      [aggregate.order.id, aggregate.version]\n    );\n\n    if (result.rowCount === 0) {\n      throw new OptimisticLockException('Order aggregate was modified');\n    }\n\n    // Update all items\n    for (const item of aggregate.items) {\n      await this.saveItem(item);\n    }\n\n    aggregate.version += 1;\n  }\n}\n```\n\n## Common Pitfalls\n\n❌ **Deadlocks:** Two transactions waiting for each other's locks\n❌ **Lock Escalation:** Too many fine-grained locks becoming table locks\n❌ **Forgotten Locks:** Not releasing locks on error paths\n❌ **Phantom Reads:** Reading data that gets modified before transaction completes\n❌ **Timeout Hell:** Locks timing out due to long operations\n\n## Key Takeaways\n\n1. **Optimistic Locking:** Best for low contention, detect conflicts on commit\n2. **Pessimistic Locking:** Best for high contention, prevent conflicts upfront\n3. **Coarse-Grained Lock:** Lock aggregates, not individual entities\n4. **Implicit Lock:** Let framework manage, good for simple cases\n5. **Always use timeouts** to prevent deadlocks\n6. **Choose based on contention** level and conflict cost\n",
    "original/enterprise-patterns/data-access-patterns.md": "# Data Access Patterns\n\n## Overview\n\nData access patterns manage the interaction between domain objects and databases, solving the object-relational impedance mismatch.\n\n## Pattern Selection Guide\n\n| Pattern | Coupling | Complexity | Testability | Best For |\n|---------|----------|-----------|-------------|----------|\n| Active Record | High | Low | Medium | Simple domains |\n| Data Mapper | Low | High | High | Complex domains |\n| Repository | Low | Medium | High | Clean architecture |\n| Table Data Gateway | Medium | Low | Medium | Procedural code |\n| Row Data Gateway | Medium | Low | Medium | Simple objects |\n\n---\n\n## Repository\n\n### Definition\n\n**Mediates between the domain and data mapping layers using a collection-like interface for accessing domain objects.**\n\n### Purpose\n\nProvides an abstraction over data access, allowing domain code to work with objects through a simple collection interface.\n\n### When to Use\n\n✅ **Good For:**\n- Domain-driven design\n- Clean architecture\n- Complex querying needs\n- Testable code\n- Multiple data sources\n\n❌ **Not Ideal For:**\n- Very simple CRUD\n- Highly procedural code\n- Direct SQL requirements\n\n### Example\n\n```typescript\ninterface UserRepository {\n  findById(id: string): Promise<User | null>;\n  findByEmail(email: string): Promise<User | null>;\n  findAll(): Promise<User[]>;\n  save(user: User): Promise<void>;\n  delete(user: User): Promise<void>;\n}\n\nclass PostgreSQLUserRepository implements UserRepository {\n  constructor(private db: Database) {}\n\n  async findById(id: string): Promise<User | null> {\n    const row = await this.db.queryOne(\n      'SELECT * FROM users WHERE id = $1',\n      [id]\n    );\n\n    return row ? this.mapToUser(row) : null;\n  }\n\n  async findByEmail(email: string): Promise<User | null> {\n    const row = await this.db.queryOne(\n      'SELECT * FROM users WHERE email = $1',\n      [email]\n    );\n\n    return row ? this.mapToUser(row) : null;\n  }\n\n  async save(user: User): Promise<void> {\n    const exists = await this.findById(user.id);\n\n    if (exists) {\n      await this.db.execute(\n        'UPDATE users SET name = $1, email = $2 WHERE id = $3',\n        [user.name, user.email, user.id]\n      );\n    } else {\n      await this.db.execute(\n        'INSERT INTO users (id, name, email) VALUES ($1, $2, $3)',\n        [user.id, user.name, user.email]\n      );\n    }\n  }\n\n  private mapToUser(row: any): User {\n    return new User(row.id, row.name, row.email);\n  }\n}\n```\n\n### Best Practices\n\n✅ **DO:**\n- Return domain objects, not data structures\n- Use collection-like interface (findAll, findById)\n- Keep repositories focused on single aggregate root\n- Use specification pattern for complex queries\n- Make repositories interfaces (program to abstraction)\n\n❌ **DON'T:**\n- Expose database details\n- Return DTOs from repositories\n- Create generic repositories for all entities\n- Put business logic in repositories\n- Leak query objects into domain layer\n\n### Specification Pattern with Repository\n\n```typescript\ninterface Specification<T> {\n  isSatisfiedBy(entity: T): boolean;\n  toSql(): { where: string; params: any[] };\n}\n\nclass ActiveUserSpecification implements Specification<User> {\n  isSatisfiedBy(user: User): boolean {\n    return user.isActive;\n  }\n\n  toSql() {\n    return {\n      where: 'is_active = $1',\n      params: [true]\n    };\n  }\n}\n\ninterface UserRepository {\n  find(spec: Specification<User>): Promise<User[]>;\n}\n\n// Usage\nconst activeUsers = await userRepo.find(new ActiveUserSpecification());\n```\n\n---\n\n## Data Mapper\n\n### Definition\n\n**A layer of mappers that moves data between objects and a database while keeping them independent of each other.**\n\n### Purpose\n\nComplete separation between domain objects and database. Domain knows nothing about persistence.\n\n### When to Use\n\n✅ **Good For:**\n- Rich domain models\n- Complex object graphs\n- Domain-driven design\n- When domain and schema differ significantly\n\n❌ **Not Ideal For:**\n- Simple CRUD applications\n- Schemas that closely match objects\n- Small applications\n\n### Example\n\n```typescript\nclass User {\n  constructor(\n    public readonly id: string,\n    private name: string,\n    private email: Email\n  ) {}\n\n  changeName(newName: string) {\n    this.name = newName;\n  }\n\n  // No database awareness\n}\n\nclass UserMapper {\n  constructor(private db: Database) {}\n\n  async find(id: string): Promise<User | null> {\n    const row = await this.db.queryOne(\n      'SELECT u.*, e.address FROM users u JOIN emails e ON u.email_id = e.id WHERE u.id = $1',\n      [id]\n    );\n\n    if (!row) return null;\n\n    return new User(\n      row.id,\n      row.name,\n      new Email(row.address)\n    );\n  }\n\n  async insert(user: User): Promise<void> {\n    // Complex mapping logic\n    const emailId = await this.insertEmail(user.email);\n\n    await this.db.execute(\n      'INSERT INTO users (id, name, email_id) VALUES ($1, $2, $3)',\n      [user.id, user.name, emailId]\n    );\n  }\n\n  async update(user: User): Promise<void> {\n    await this.updateEmail(user.email);\n\n    await this.db.execute(\n      'UPDATE users SET name = $1 WHERE id = $2',\n      [user.name, user.id]\n    );\n  }\n\n  private async insertEmail(email: Email): Promise<string> {\n    const id = generateId();\n    await this.db.execute(\n      'INSERT INTO emails (id, address) VALUES ($1, $2)',\n      [id, email.address]\n    );\n    return id;\n  }\n}\n```\n\n### Best Practices\n\n✅ **DO:**\n- Keep domain objects persistence ignorant\n- Handle complex object graphs\n- Map between different schemas\n- Use metadata for configuration\n- Separate mapper from domain\n\n❌ **DON'T:**\n- Mix mapper logic with domain logic\n- Create circular dependencies\n- Ignore lazy loading strategies\n- Map every property manually if ORM available\n\n---\n\n## Active Record\n\n### Definition\n\n**An object that wraps a row in a database table, encapsulates database access, and adds domain logic on that data.**\n\n### Purpose\n\nCombine data and behavior in a single class that knows how to persist itself.\n\n### When to Use\n\n✅ **Good For:**\n- Simple domain logic\n- Objects that map closely to database tables\n- Rapid development\n- Ruby on Rails, Laravel style apps\n\n❌ **Not Ideal For:**\n- Complex domain models\n- When domain and schema differ significantly\n- Test-driven development (harder to test)\n\n### Example\n\n```typescript\nclass User extends ActiveRecord {\n  id: string;\n  name: string;\n  email: string;\n\n  static async find(id: string): Promise<User | null> {\n    const row = await this.db.queryOne(\n      'SELECT * FROM users WHERE id = $1',\n      [id]\n    );\n\n    if (!row) return null;\n\n    const user = new User();\n    user.id = row.id;\n    user.name = row.name;\n    user.email = row.email;\n    return user;\n  }\n\n  async save(): Promise<void> {\n    if (await User.find(this.id)) {\n      await this.db.execute(\n        'UPDATE users SET name = $1, email = $2 WHERE id = $3',\n        [this.name, this.email, this.id]\n      );\n    } else {\n      await this.db.execute(\n        'INSERT INTO users (id, name, email) VALUES ($1, $2, $3)',\n        [this.id, this.name, this.email]\n      );\n    }\n  }\n\n  async delete(): Promise<void> {\n    await this.db.execute('DELETE FROM users WHERE id = $1', [this.id]);\n  }\n\n  // Domain logic mixed with persistence\n  async sendWelcomeEmail(): Promise<void> {\n    const mailer = new Mailer();\n    await mailer.send(this.email, 'Welcome!');\n    // Could also update database\n    this.emailSent = true;\n    await this.save();\n  }\n}\n\n// Usage\nconst user = await User.find('123');\nuser.name = 'New Name';\nawait user.save();\n```\n\n### Best Practices\n\n✅ **DO:**\n- Use for simple domains\n- Keep database logic in base class\n- Use for rapid prototyping\n- Leverage framework support (TypeORM, Sequelize)\n\n❌ **DON'T:**\n- Use for complex domains\n- Mix too much business logic with persistence\n- Use when domain model complex\n- Ignore testability issues\n\n### Trade-offs\n\n**Advantages:**\n- Simple and intuitive\n- Less code\n- Rapid development\n- Good framework support\n\n**Disadvantages:**\n- Tight coupling to database\n- Harder to test\n- Domain depends on infrastructure\n- Not suitable for complex domains\n\n---\n\n## Unit of Work\n\n### Definition\n\n**Maintains a list of objects affected by a business transaction and coordinates writing out changes and resolving concurrency problems.**\n\n### Purpose\n\nTrack all changes in a transaction and commit them together, ensuring consistency.\n\n### When to Use\n\n✅ **Good For:**\n- Complex transactions affecting multiple objects\n- Managing database transactions\n- Batch updates\n- Optimizing database calls\n\n❌ **Not Ideal For:**\n- Simple single-object updates\n- Read-only operations\n- Stateless services\n\n### Example\n\n```typescript\nclass UnitOfWork {\n  private newObjects: Set<any> = new Set();\n  private dirtyObjects: Set<any> = new Set();\n  private removedObjects: Set<any> = new Set();\n\n  registerNew(obj: any): void {\n    if (this.removedObjects.has(obj)) {\n      throw new Error('Cannot register removed object as new');\n    }\n    if (this.dirtyObjects.has(obj)) {\n      throw new Error('Cannot register dirty object as new');\n    }\n    this.newObjects.add(obj);\n  }\n\n  registerDirty(obj: any): void {\n    if (!this.newObjects.has(obj) && !this.dirtyObjects.has(obj)) {\n      this.dirtyObjects.add(obj);\n    }\n  }\n\n  registerRemoved(obj: any): void {\n    if (this.newObjects.has(obj)) {\n      this.newObjects.delete(obj);\n    } else {\n      this.dirtyObjects.delete(obj);\n      this.removedObjects.add(obj);\n    }\n  }\n\n  async commit(): Promise<void> {\n    const db = await Database.connect();\n    await db.beginTransaction();\n\n    try {\n      // Insert new objects\n      for (const obj of this.newObjects) {\n        await this.insertObject(db, obj);\n      }\n\n      // Update dirty objects\n      for (const obj of this.dirtyObjects) {\n        await this.updateObject(db, obj);\n      }\n\n      // Delete removed objects\n      for (const obj of this.removedObjects) {\n        await this.deleteObject(db, obj);\n      }\n\n      await db.commit();\n      this.clear();\n    } catch (error) {\n      await db.rollback();\n      throw error;\n    }\n  }\n\n  private clear(): void {\n    this.newObjects.clear();\n    this.dirtyObjects.clear();\n    this.removedObjects.clear();\n  }\n\n  private async insertObject(db: Database, obj: any): Promise<void> {\n    // Use mapper to insert object\n  }\n\n  private async updateObject(db: Database, obj: any): Promise<void> {\n    // Use mapper to update object\n  }\n\n  private async deleteObject(db: Database, obj: any): Promise<void> {\n    // Use mapper to delete object\n  }\n}\n\n// Usage\nconst uow = new UnitOfWork();\n\nconst user = new User('1', 'John');\nuow.registerNew(user);\n\nconst order = await orderRepo.find('order-1');\norder.addItem(product);\nuow.registerDirty(order);\n\nconst oldProduct = await productRepo.find('old-1');\nuow.registerRemoved(oldProduct);\n\nawait uow.commit(); // All changes committed together\n```\n\n### Best Practices\n\n✅ **DO:**\n- Commit or rollback atomically\n- Track changes automatically when possible\n- Clear state after commit\n- Handle concurrency conflicts\n\n❌ **DON'T:**\n- Keep UnitOfWork alive too long\n- Share UnitOfWork across threads\n- Commit partially on error\n- Ignore transaction boundaries\n\n---\n\n## Identity Map\n\n### Definition\n\n**Ensures that each object gets loaded only once by keeping every loaded object in a map, looking up objects using the map when referring to them.**\n\n### Purpose\n\nPrevent duplicate objects and ensure object identity within a session.\n\n### When to Use\n\n✅ **Good For:**\n- Maintaining object identity\n- Preventing duplicate loads\n- Circular references\n- Performance optimization\n\n❌ **Not Ideal For:**\n- Stateless services\n- Large datasets (memory concerns)\n- Read-only scenarios\n\n### Example\n\n```typescript\nclass IdentityMap {\n  private map = new Map<string, any>();\n\n  get(key: string): any | null {\n    return this.map.get(key) || null;\n  }\n\n  put(key: string, value: any): void {\n    this.map.set(key, value);\n  }\n\n  has(key: string): boolean {\n    return this.map.has(key);\n  }\n\n  clear(): void {\n    this.map.clear();\n  }\n}\n\nclass UserMapper {\n  constructor(\n    private db: Database,\n    private identityMap: IdentityMap\n  ) {}\n\n  async find(id: string): Promise<User | null> {\n    // Check identity map first\n    if (this.identityMap.has(id)) {\n      return this.identityMap.get(id);\n    }\n\n    // Load from database\n    const row = await this.db.queryOne(\n      'SELECT * FROM users WHERE id = $1',\n      [id]\n    );\n\n    if (!row) return null;\n\n    const user = new User(row.id, row.name, row.email);\n\n    // Store in identity map\n    this.identityMap.put(id, user);\n\n    return user;\n  }\n}\n\n// Usage ensures same instance\nconst user1 = await userMapper.find('123');\nconst user2 = await userMapper.find('123');\nconsole.log(user1 === user2); // true - same instance\n```\n\n---\n\n## Lazy Load\n\n### Definition\n\n**An object that doesn't contain all of the data you need but knows how to get it.**\n\n### Purpose\n\nDefer loading of expensive data until actually needed.\n\n### Types\n\n1. **Lazy Initialization:** Load on first access\n2. **Virtual Proxy:** Proxy object loads real object on demand\n3. **Value Holder:** Wrapper that loads value when accessed\n4. **Ghost:** Partial object that loads full data on access\n\n### Example\n\n```typescript\n// Lazy Initialization\nclass Order {\n  constructor(\n    private id: string,\n    private customerId: string,\n    private _customer?: Customer\n  ) {}\n\n  async getCustomer(): Promise<Customer> {\n    if (!this._customer) {\n      this._customer = await customerRepo.find(this.customerId);\n    }\n    return this._customer;\n  }\n}\n\n// Virtual Proxy\nclass CustomerProxy extends Customer {\n  private realCustomer?: Customer;\n\n  constructor(private id: string, private loader: CustomerLoader) {\n    super();\n  }\n\n  get name(): string {\n    return this.getRealCustomer().name;\n  }\n\n  get email(): string {\n    return this.getRealCustomer().email;\n  }\n\n  private getRealCustomer(): Customer {\n    if (!this.realCustomer) {\n      this.realCustomer = this.loader.load(this.id);\n    }\n    return this.realCustomer;\n  }\n}\n```\n\n---\n\n## Pattern Combinations\n\n### Repository + Unit of Work\n\n```typescript\nclass UserRepository {\n  constructor(private unitOfWork: UnitOfWork) {}\n\n  async save(user: User): Promise<void> {\n    if (user.isNew()) {\n      this.unitOfWork.registerNew(user);\n    } else {\n      this.unitOfWork.registerDirty(user);\n    }\n  }\n}\n\n// Service layer commits unit of work\nclass UserService {\n  async updateUserEmail(userId: string, newEmail: string): Promise<void> {\n    const user = await this.userRepo.findById(userId);\n    user.changeEmail(newEmail);\n    await this.userRepo.save(user); // Registers with UoW\n    await this.unitOfWork.commit(); // Commits transaction\n  }\n}\n```\n\n### Data Mapper + Identity Map\n\n```typescript\nclass OrderMapper {\n  constructor(\n    private db: Database,\n    private identityMap: IdentityMap\n  ) {}\n\n  async find(id: string): Promise<Order> {\n    // Check cache\n    let order = this.identityMap.get(id);\n    if (order) return order;\n\n    // Load from DB\n    const row = await this.db.queryOne('SELECT * FROM orders WHERE id = $1', [id]);\n    order = this.mapToOrder(row);\n\n    // Cache it\n    this.identityMap.put(id, order);\n\n    return order;\n  }\n}\n```\n\n## Common Pitfalls\n\n❌ **Leaky Abstractions:** Repository exposing SQL details\n❌ **Anemic Repositories:** Just CRUD, no domain queries\n❌ **N+1 Queries:** Lazy loading causing performance issues\n❌ **Stale Identity Map:** Not clearing between requests\n❌ **Wrong Pattern:** Using Active Record for complex domains\n\n## Key Takeaways\n\n1. **Repository:** Collection-like interface for domain objects\n2. **Data Mapper:** Complete separation of domain and persistence\n3. **Active Record:** Simple pattern for simple domains\n4. **Unit of Work:** Coordinate changes across multiple objects\n5. **Identity Map:** Ensure object identity and prevent duplicates\n6. **Lazy Load:** Defer expensive loads until needed\n",
    "original/enterprise-patterns/distribution-patterns.md": "# Distribution Patterns\n\n## Overview\n\nDistribution patterns handle the challenges of designing systems that communicate across process boundaries, addressing issues like network latency, data serialization, and coupling between distributed components.\n\n## Pattern Selection Guide\n\n| Pattern | Purpose | Network Calls | Coupling | Best For |\n|---------|---------|--------------|----------|----------|\n| Remote Facade | Coarse-grained interface | Minimal | Low | Reducing network overhead |\n| Data Transfer Object | Data bundling | Reduced | Medium | Cross-boundary data transfer |\n| Gateway | External system access | Encapsulated | Low | Third-party API integration |\n| Service Stub | Testing doubles | None (mock) | Low | Testing distributed systems |\n\n---\n\n## Remote Facade\n\n### Definition\n\n**Provides a coarse-grained facade on fine-grained objects to improve efficiency over a network.**\n\n### Purpose\n\nReduce network round trips by bundling multiple fine-grained operations into a single coarse-grained call.\n\n### When to Use\n\n✅ **Good For:**\n- Distributed systems with network latency\n- Microservices communication\n- API design for external clients\n- Reducing chattiness between layers\n- Remote procedure calls (RPC, REST APIs)\n\n❌ **Not Ideal For:**\n- In-process communication\n- When fine-grained control is required\n- Single-deployment applications\n\n### Example\n\n❌ **Without Remote Facade (Chatty):**\n```typescript\nclass CustomerService {\n  async getCustomer(id: string): Promise<Customer> {\n    return this.customerRepo.findById(id);\n  }\n\n  async getOrders(customerId: string): Promise<Order[]> {\n    return this.orderRepo.findByCustomerId(customerId);\n  }\n\n  async getAddresses(customerId: string): Promise<Address[]> {\n    return this.addressRepo.findByCustomerId(customerId);\n  }\n}\n\n// Client makes 3 network calls\nconst customer = await api.getCustomer('123');        // Network call 1\nconst orders = await api.getOrders('123');            // Network call 2\nconst addresses = await api.getAddresses('123');      // Network call 3\n```\n\n✅ **With Remote Facade (Efficient):**\n```typescript\ninterface CustomerDetails {\n  customer: Customer;\n  orders: Order[];\n  addresses: Address[];\n  recentActivity: Activity[];\n}\n\nclass CustomerFacade {\n  constructor(\n    private customerRepo: CustomerRepository,\n    private orderRepo: OrderRepository,\n    private addressRepo: AddressRepository,\n    private activityRepo: ActivityRepository\n  ) {}\n\n  async getCustomerDetails(customerId: string): Promise<CustomerDetails> {\n    // Single coarse-grained operation\n    const [customer, orders, addresses, recentActivity] = await Promise.all([\n      this.customerRepo.findById(customerId),\n      this.orderRepo.findByCustomerId(customerId),\n      this.addressRepo.findByCustomerId(customerId),\n      this.activityRepo.findRecentByCustomerId(customerId, 10)\n    ]);\n\n    if (!customer) {\n      throw new Error('Customer not found');\n    }\n\n    return {\n      customer,\n      orders,\n      addresses,\n      recentActivity\n    };\n  }\n\n  async updateCustomerProfile(\n    customerId: string,\n    profileData: {\n      name?: string;\n      email?: string;\n      primaryAddress?: Address;\n    }\n  ): Promise<void> {\n    // Bundle multiple updates into single call\n    const customer = await this.customerRepo.findById(customerId);\n\n    if (!customer) {\n      throw new Error('Customer not found');\n    }\n\n    if (profileData.name) {\n      customer.name = profileData.name;\n    }\n\n    if (profileData.email) {\n      customer.email = profileData.email;\n    }\n\n    await this.customerRepo.save(customer);\n\n    if (profileData.primaryAddress) {\n      await this.addressRepo.setPrimary(customerId, profileData.primaryAddress);\n    }\n  }\n}\n\n// Client makes 1 network call instead of 3\nconst details = await api.getCustomerDetails('123'); // Single network call\n```\n\n### Best Practices\n\n✅ **DO:**\n- Design operations based on client use cases\n- Bundle related data together\n- Use DTOs for data transfer\n- Keep facade stateless\n- Document expected usage patterns\n- Version your API\n\n❌ **DON'T:**\n- Expose fine-grained domain objects directly\n- Create generic \"get everything\" methods\n- Return more data than needed\n- Make facade stateful\n- Violate domain boundaries\n\n### REST API Example\n\n```typescript\nclass OrderFacadeController {\n  constructor(\n    private orderService: OrderService,\n    private productService: ProductService,\n    private customerService: CustomerService\n  ) {}\n\n  @Get('/api/orders/:id/complete-details')\n  async getOrderCompleteDetails(\n    @Param('id') orderId: string\n  ): Promise<OrderCompleteDetailsDTO> {\n    const order = await this.orderService.findById(orderId);\n    const customer = await this.customerService.findById(order.customerId);\n    const productIds = order.items.map(item => item.productId);\n    const products = await this.productService.findByIds(productIds);\n\n    return {\n      order: {\n        id: order.id,\n        status: order.status,\n        total: order.total,\n        createdAt: order.createdAt\n      },\n      customer: {\n        id: customer.id,\n        name: customer.name,\n        email: customer.email\n      },\n      items: order.items.map(item => ({\n        product: products.find(p => p.id === item.productId),\n        quantity: item.quantity,\n        price: item.price\n      }))\n    };\n  }\n\n  @Post('/api/orders/:id/complete')\n  async completeOrder(\n    @Param('id') orderId: string,\n    @Body() completion: OrderCompletionDTO\n  ): Promise<void> {\n    // Bundle multiple operations\n    await this.orderService.markComplete(orderId);\n    await this.orderService.sendConfirmationEmail(orderId);\n    if (completion.createInvoice) {\n      await this.orderService.generateInvoice(orderId);\n    }\n  }\n}\n```\n\n---\n\n## Data Transfer Object (DTO)\n\n### Definition\n\n**An object that carries data between processes, reducing the number of method calls.**\n\n### Purpose\n\nBundle multiple values into a single object for transfer across process boundaries.\n\n### When to Use\n\n✅ **Good For:**\n- Remote method calls\n- API boundaries (REST, GraphQL, gRPC)\n- Serialization across network\n- Isolating internal models from external contracts\n- Version isolation\n\n❌ **Not Ideal For:**\n- In-process communication\n- When domain objects can be safely exposed\n- Simple single-value transfers\n\n### Example\n\n```typescript\n// Domain model (internal)\nclass Order {\n  constructor(\n    public id: string,\n    public customer: Customer,\n    public items: OrderItem[],\n    public status: OrderStatus,\n    public createdAt: Date,\n    public updatedAt: Date\n  ) {}\n\n  calculateTotal(): Money {\n    return this.items.reduce(\n      (sum, item) => sum.add(item.subtotal()),\n      Money.zero()\n    );\n  }\n\n  canCancel(): boolean {\n    return this.status === OrderStatus.Pending;\n  }\n}\n\n// DTO for external API (simplified, serializable)\ninterface OrderDTO {\n  id: string;\n  customerId: string;\n  customerName: string;\n  items: OrderItemDTO[];\n  status: string;\n  total: number;\n  currency: string;\n  createdAt: string;\n}\n\ninterface OrderItemDTO {\n  productId: string;\n  productName: string;\n  quantity: number;\n  unitPrice: number;\n  subtotal: number;\n}\n\n// Mapper to convert between domain and DTO\nclass OrderDTOMapper {\n  static toDTO(order: Order): OrderDTO {\n    return {\n      id: order.id,\n      customerId: order.customer.id,\n      customerName: order.customer.name,\n      items: order.items.map(item => ({\n        productId: item.product.id,\n        productName: item.product.name,\n        quantity: item.quantity,\n        unitPrice: item.price.amount,\n        subtotal: item.subtotal().amount\n      })),\n      status: order.status.toString(),\n      total: order.calculateTotal().amount,\n      currency: order.calculateTotal().currency,\n      createdAt: order.createdAt.toISOString()\n    };\n  }\n\n  static toDomain(dto: CreateOrderDTO, customer: Customer, products: Map<string, Product>): Order {\n    const items = dto.items.map(itemDto => {\n      const product = products.get(itemDto.productId);\n      if (!product) {\n        throw new Error(`Product ${itemDto.productId} not found`);\n      }\n      return new OrderItem(product, itemDto.quantity);\n    });\n\n    return new Order(\n      generateId(),\n      customer,\n      items,\n      OrderStatus.Pending,\n      new Date(),\n      new Date()\n    );\n  }\n}\n\n// API endpoint using DTO\nclass OrderController {\n  @Post('/api/orders')\n  async createOrder(@Body() dto: CreateOrderDTO): Promise<OrderDTO> {\n    const customer = await this.customerService.findById(dto.customerId);\n    const productIds = dto.items.map(item => item.productId);\n    const products = await this.productService.findByIds(productIds);\n\n    const order = OrderDTOMapper.toDomain(dto, customer, products);\n    await this.orderService.create(order);\n\n    return OrderDTOMapper.toDTO(order);\n  }\n\n  @Get('/api/orders/:id')\n  async getOrder(@Param('id') id: string): Promise<OrderDTO> {\n    const order = await this.orderService.findById(id);\n    return OrderDTOMapper.toDTO(order);\n  }\n}\n```\n\n### DTO Variations\n\n**1. Request DTO**\n```typescript\ninterface CreateOrderRequest {\n  customerId: string;\n  items: Array<{\n    productId: string;\n    quantity: number;\n  }>;\n  shippingAddressId: string;\n  paymentMethodId: string;\n}\n```\n\n**2. Response DTO**\n```typescript\ninterface OrderResponse {\n  id: string;\n  status: string;\n  total: number;\n  estimatedDelivery: string;\n}\n```\n\n**3. Nested DTOs**\n```typescript\ninterface CustomerDetailsDTO {\n  customer: CustomerDTO;\n  orders: OrderDTO[];\n  addresses: AddressDTO[];\n  paymentMethods: PaymentMethodDTO[];\n}\n```\n\n**4. Versioned DTOs**\n```typescript\ninterface OrderDTOV1 {\n  id: string;\n  total: number;\n}\n\ninterface OrderDTOV2 {\n  id: string;\n  total: number;\n  currency: string; // Added in v2\n  tax: number;      // Added in v2\n}\n```\n\n### Best Practices\n\n✅ **DO:**\n- Keep DTOs simple and serializable\n- Use primitive types when possible\n- Separate request and response DTOs\n- Version your DTOs\n- Validate DTO data\n- Use mappers to convert domain ↔ DTO\n\n❌ **DON'T:**\n- Put business logic in DTOs\n- Expose domain objects as DTOs\n- Create one DTO per domain object automatically\n- Include circular references\n- Use complex types that don't serialize well\n\n---\n\n## Gateway\n\n### Definition\n\n**An object that encapsulates access to an external system or resource.**\n\n### Purpose\n\nProvide a simple interface to complex external systems, isolating your code from third-party APIs.\n\n### When to Use\n\n✅ **Good For:**\n- Third-party API integration\n- Legacy system integration\n- External service abstraction\n- Testability (can mock gateway)\n- Isolating vendor-specific code\n\n❌ **Not Ideal For:**\n- Simple in-process calls\n- When direct access is sufficient\n\n### Example\n\n```typescript\n// Gateway interface (internal abstraction)\ninterface PaymentGateway {\n  charge(amount: Money, paymentMethod: PaymentMethod): Promise<PaymentResult>;\n  refund(transactionId: string, amount: Money): Promise<RefundResult>;\n  getTransaction(transactionId: string): Promise<Transaction>;\n}\n\n// Stripe implementation\nclass StripePaymentGateway implements PaymentGateway {\n  constructor(private stripeClient: Stripe) {}\n\n  async charge(amount: Money, paymentMethod: PaymentMethod): Promise<PaymentResult> {\n    try {\n      // Map internal types to Stripe API\n      const paymentIntent = await this.stripeClient.paymentIntents.create({\n        amount: amount.cents, // Stripe uses cents\n        currency: amount.currency.toLowerCase(),\n        payment_method: paymentMethod.stripeId,\n        confirm: true\n      });\n\n      // Map Stripe response to internal type\n      return {\n        success: paymentIntent.status === 'succeeded',\n        transactionId: paymentIntent.id,\n        amount: amount,\n        timestamp: new Date(paymentIntent.created * 1000)\n      };\n    } catch (error) {\n      // Translate Stripe errors to internal errors\n      if (error.type === 'StripeCardError') {\n        throw new PaymentDeclinedError(error.message);\n      }\n      throw new PaymentGatewayError('Payment failed', error);\n    }\n  }\n\n  async refund(transactionId: string, amount: Money): Promise<RefundResult> {\n    const refund = await this.stripeClient.refunds.create({\n      payment_intent: transactionId,\n      amount: amount.cents\n    });\n\n    return {\n      success: refund.status === 'succeeded',\n      refundId: refund.id,\n      amount: Money.fromCents(refund.amount, amount.currency)\n    };\n  }\n\n  async getTransaction(transactionId: string): Promise<Transaction> {\n    const paymentIntent = await this.stripeClient.paymentIntents.retrieve(transactionId);\n\n    return {\n      id: paymentIntent.id,\n      amount: Money.fromCents(paymentIntent.amount, paymentIntent.currency),\n      status: this.mapStripeStatus(paymentIntent.status),\n      createdAt: new Date(paymentIntent.created * 1000)\n    };\n  }\n\n  private mapStripeStatus(stripeStatus: string): TransactionStatus {\n    switch (stripeStatus) {\n      case 'succeeded': return TransactionStatus.Completed;\n      case 'processing': return TransactionStatus.Pending;\n      case 'canceled': return TransactionStatus.Canceled;\n      default: return TransactionStatus.Failed;\n    }\n  }\n}\n\n// PayPal implementation (same interface, different vendor)\nclass PayPalPaymentGateway implements PaymentGateway {\n  constructor(private paypalClient: PayPalClient) {}\n\n  async charge(amount: Money, paymentMethod: PaymentMethod): Promise<PaymentResult> {\n    // Different implementation, same interface\n    const order = await this.paypalClient.createOrder({\n      intent: 'CAPTURE',\n      purchase_units: [{\n        amount: {\n          currency_code: amount.currency,\n          value: amount.toString()\n        }\n      }]\n    });\n\n    const capture = await this.paypalClient.captureOrder(order.id);\n\n    return {\n      success: capture.status === 'COMPLETED',\n      transactionId: capture.id,\n      amount: amount,\n      timestamp: new Date(capture.create_time)\n    };\n  }\n\n  // ... other methods\n}\n\n// Usage in service (vendor-agnostic)\nclass OrderService {\n  constructor(private paymentGateway: PaymentGateway) {}\n\n  async processPayment(order: Order): Promise<void> {\n    const result = await this.paymentGateway.charge(\n      order.total,\n      order.paymentMethod\n    );\n\n    if (!result.success) {\n      throw new PaymentFailedError('Payment processing failed');\n    }\n\n    order.markAsPaid(result.transactionId);\n  }\n}\n```\n\n### Gateway Pattern Variations\n\n**1. API Gateway**\n```typescript\nclass GitHubGateway {\n  constructor(private httpClient: HttpClient, private apiKey: string) {}\n\n  async getRepository(owner: string, repo: string): Promise<Repository> {\n    const response = await this.httpClient.get(\n      `https://api.github.com/repos/${owner}/${repo}`,\n      {\n        headers: {\n          'Authorization': `Bearer ${this.apiKey}`,\n          'Accept': 'application/vnd.github.v3+json'\n        }\n      }\n    );\n\n    return this.mapToRepository(response.data);\n  }\n\n  private mapToRepository(data: any): Repository {\n    return {\n      name: data.name,\n      owner: data.owner.login,\n      stars: data.stargazers_count,\n      url: data.html_url\n    };\n  }\n}\n```\n\n**2. Database Gateway**\n```typescript\nclass UserGateway {\n  constructor(private db: Database) {}\n\n  async findById(id: string): Promise<User | null> {\n    const row = await this.db.queryOne(\n      'SELECT * FROM users WHERE id = $1',\n      [id]\n    );\n\n    return row ? this.mapRowToUser(row) : null;\n  }\n\n  async findByEmail(email: string): Promise<User | null> {\n    const row = await this.db.queryOne(\n      'SELECT * FROM users WHERE email = $1',\n      [email]\n    );\n\n    return row ? this.mapRowToUser(row) : null;\n  }\n\n  private mapRowToUser(row: any): User {\n    return new User(row.id, row.name, row.email, row.created_at);\n  }\n}\n```\n\n### Best Practices\n\n✅ **DO:**\n- Define gateway interface in your domain\n- Isolate vendor-specific code\n- Map external types to internal types\n- Translate external errors to domain errors\n- Make gateways testable with mocks\n- Version gateway interfaces\n\n❌ **DON'T:**\n- Expose third-party types in gateway interface\n- Let external API structure leak into domain\n- Create tight coupling to vendor\n- Skip error translation\n\n---\n\n## Service Stub\n\n### Definition\n\n**Removes dependence on problematic services during testing by providing a simplified implementation.**\n\n### Purpose\n\nEnable testing of distributed systems without requiring actual external services.\n\n### When to Use\n\n✅ **Good For:**\n- Unit testing distributed systems\n- Development without external dependencies\n- Simulating error conditions\n- Performance testing\n- Continuous integration\n\n❌ **Not Ideal For:**\n- Production code\n- Integration testing (use real services)\n- End-to-end testing\n\n### Example\n\n```typescript\n// Real payment gateway\nclass StripePaymentGateway implements PaymentGateway {\n  async charge(amount: Money, paymentMethod: PaymentMethod): Promise<PaymentResult> {\n    // Real Stripe API call\n    const paymentIntent = await this.stripeClient.paymentIntents.create({...});\n    return {...};\n  }\n}\n\n// Stub for testing\nclass StubPaymentGateway implements PaymentGateway {\n  private shouldSucceed = true;\n  private delay = 0;\n  private transactionCounter = 1000;\n\n  configureSuccess(shouldSucceed: boolean): void {\n    this.shouldSucceed = shouldSucceed;\n  }\n\n  configureDelay(delayMs: number): void {\n    this.delay = delayMs;\n  }\n\n  async charge(amount: Money, paymentMethod: PaymentMethod): Promise<PaymentResult> {\n    if (this.delay > 0) {\n      await sleep(this.delay);\n    }\n\n    if (!this.shouldSucceed) {\n      throw new PaymentDeclinedError('Card declined (stub)');\n    }\n\n    return {\n      success: true,\n      transactionId: `stub-txn-${this.transactionCounter++}`,\n      amount: amount,\n      timestamp: new Date()\n    };\n  }\n\n  async refund(transactionId: string, amount: Money): Promise<RefundResult> {\n    return {\n      success: this.shouldSucceed,\n      refundId: `stub-refund-${this.transactionCounter++}`,\n      amount: amount\n    };\n  }\n\n  async getTransaction(transactionId: string): Promise<Transaction> {\n    return {\n      id: transactionId,\n      amount: Money.dollars(100),\n      status: TransactionStatus.Completed,\n      createdAt: new Date()\n    };\n  }\n}\n\n// Test usage\ndescribe('OrderService', () => {\n  it('should process payment successfully', async () => {\n    const stubGateway = new StubPaymentGateway();\n    stubGateway.configureSuccess(true);\n\n    const orderService = new OrderService(stubGateway);\n    const order = createTestOrder();\n\n    await orderService.processPayment(order);\n\n    expect(order.status).toBe(OrderStatus.Paid);\n  });\n\n  it('should handle payment failure', async () => {\n    const stubGateway = new StubPaymentGateway();\n    stubGateway.configureSuccess(false); // Simulate failure\n\n    const orderService = new OrderService(stubGateway);\n    const order = createTestOrder();\n\n    await expect(orderService.processPayment(order))\n      .rejects.toThrow(PaymentFailedError);\n  });\n});\n```\n\n### Configurable Stubs\n\n```typescript\nclass ConfigurableEmailStub implements EmailGateway {\n  private sentEmails: Email[] = [];\n  private shouldFail = false;\n  private failureRate = 0;\n\n  async send(email: Email): Promise<void> {\n    if (this.shouldFail || Math.random() < this.failureRate) {\n      throw new EmailSendError('Failed to send email (stub)');\n    }\n\n    this.sentEmails.push(email);\n  }\n\n  getSentEmails(): Email[] {\n    return [...this.sentEmails];\n  }\n\n  wasEmailSentTo(recipient: string): boolean {\n    return this.sentEmails.some(email => email.to === recipient);\n  }\n\n  configureFail(shouldFail: boolean): void {\n    this.shouldFail = shouldFail;\n  }\n\n  configureFailureRate(rate: number): void {\n    this.failureRate = rate;\n  }\n\n  reset(): void {\n    this.sentEmails = [];\n    this.shouldFail = false;\n    this.failureRate = 0;\n  }\n}\n```\n\n### Best Practices\n\n✅ **DO:**\n- Implement same interface as real service\n- Make stubs configurable for different scenarios\n- Record calls for verification\n- Simulate realistic delays\n- Support error simulation\n\n❌ **DON'T:**\n- Use stubs in production\n- Make stubs too complex\n- Test stub implementation details\n- Skip integration tests with real services\n\n---\n\n## Common Pitfalls\n\n❌ **Chatty Communication:** Too many fine-grained network calls\n❌ **God DTOs:** DTOs that contain everything\n❌ **Leaky Abstraction:** Gateway exposing vendor details\n❌ **Missing Facades:** Direct access to fine-grained services\n❌ **Tight Coupling:** Domain depending on external APIs\n❌ **No Versioning:** Breaking API changes affecting clients\n\n## Key Takeaways\n\n1. **Remote Facade:** Bundle operations to reduce network overhead\n2. **DTO:** Transfer data across boundaries with simple, serializable objects\n3. **Gateway:** Isolate external systems, map types at boundary\n4. **Service Stub:** Enable testing without external dependencies\n5. **Always version** your APIs and DTOs\n6. **Map at boundaries** - don't let external types leak into domain\n",
    "original/enterprise-patterns/domain-logic-patterns.md": "# Domain Logic Patterns\n\n## Overview\n\nDomain logic patterns organize the business logic that is the core of enterprise applications. Different patterns suit different levels of complexity.\n\n## Pattern Selection Guide\n\n| Pattern | Complexity | Database Integration | Testability | Best For |\n|---------|-----------|---------------------|-------------|----------|\n| Transaction Script | Low | Direct SQL | Low | Simple CRUD, reports |\n| Table Module | Medium | Coupled | Medium | Table-centric logic |\n| Domain Model | High | Separated | High | Complex business rules |\n| Service Layer | Any | Abstraction | High | API boundaries |\n\n---\n\n## Transaction Script\n\n### Definition\n\n**Organize business logic through procedures, where each procedure handles a single request from the presentation.**\n\n### Structure\n\nEach business transaction becomes a procedure (function or method) that performs the complete operation.\n\n### When to Use\n\n✅ **Good For:**\n- Simple applications with minimal business logic\n- Applications where procedures map cleanly to database tables\n- Quick prototypes or MVPs\n- Reporting and data analysis tools\n\n❌ **Not Ideal For:**\n- Complex business rules with many variations\n- Applications requiring high reusability\n- Systems with complex object interactions\n\n### Example\n\n```typescript\nclass TransferMoneyScript {\n  async execute(fromAccountId: string, toAccountId: string, amount: number) {\n    // Start transaction\n    const db = await Database.connect();\n    await db.beginTransaction();\n\n    try {\n      // Get accounts\n      const fromAccount = await db.query(\n        'SELECT * FROM accounts WHERE id = ?',\n        [fromAccountId]\n      );\n      const toAccount = await db.query(\n        'SELECT * FROM accounts WHERE id = ?',\n        [toAccountId]\n      );\n\n      // Business logic\n      if (fromAccount.balance < amount) {\n        throw new Error('Insufficient funds');\n      }\n\n      // Update balances\n      await db.execute(\n        'UPDATE accounts SET balance = balance - ? WHERE id = ?',\n        [amount, fromAccountId]\n      );\n      await db.execute(\n        'UPDATE accounts SET balance = balance + ? WHERE id = ?',\n        [amount, toAccountId]\n      );\n\n      // Log transaction\n      await db.execute(\n        'INSERT INTO transactions (from_id, to_id, amount, date) VALUES (?, ?, ?, ?)',\n        [fromAccountId, toAccountId, amount, new Date()]\n      );\n\n      await db.commit();\n    } catch (error) {\n      await db.rollback();\n      throw error;\n    }\n  }\n}\n```\n\n### Best Practices\n\n✅ **DO:**\n- Keep scripts focused on single operations\n- Use database transactions appropriately\n- Extract common code into utility functions\n- Keep scripts stateless\n\n❌ **DON'T:**\n- Duplicate logic across multiple scripts\n- Mix presentation logic with business logic\n- Create overly complex procedural code\n- Ignore database transaction boundaries\n\n### Trade-offs\n\n**Advantages:**\n- Simple to understand\n- Works well with procedural tools\n- Minimal ceremony\n- Direct database access\n\n**Disadvantages:**\n- Code duplication across scripts\n- Difficult to maintain complex logic\n- Poor reusability\n- Tight coupling to database\n\n---\n\n## Table Module\n\n### Definition\n\n**A single instance that handles the business logic for all rows in a database table or view.**\n\n### Structure\n\nOne class per table with methods that operate on multiple rows simultaneously.\n\n### When to Use\n\n✅ **Good For:**\n- Record-set oriented platforms (.NET DataSet)\n- Applications with table-centric operations\n- Batch processing\n- Systems where database tables drive design\n\n❌ **Not Ideal For:**\n- Object-oriented designs\n- Complex object graphs\n- Rich domain models\n\n### Example\n\n```typescript\nclass AccountModule {\n  constructor(private recordSet: RecordSet) {}\n\n  calculateTotalBalance(): number {\n    let total = 0;\n    for (const record of this.recordSet.rows) {\n      total += record.balance;\n    }\n    return total;\n  }\n\n  applyInterest(rate: number): void {\n    for (const record of this.recordSet.rows) {\n      const interest = record.balance * rate;\n      record.balance += interest;\n    }\n  }\n\n  findOverdrawn(): RecordSet {\n    return this.recordSet.filter(r => r.balance < 0);\n  }\n\n  static async load(db: Database): Promise<AccountModule> {\n    const recordSet = await db.query('SELECT * FROM accounts');\n    return new AccountModule(recordSet);\n  }\n\n  async save(db: Database): Promise<void> {\n    for (const record of this.recordSet.rows) {\n      if (record.isDirty) {\n        await db.update('accounts', record);\n      }\n    }\n  }\n}\n```\n\n### Best Practices\n\n✅ **DO:**\n- Operate on multiple rows efficiently\n- Use record-set abstractions\n- Keep table modules stateless\n- Combine with Table Data Gateway\n\n❌ **DON'T:**\n- Mix multiple tables in one module\n- Create complex object relationships\n- Use when rich object model is needed\n\n### Trade-offs\n\n**Advantages:**\n- Natural fit for record-set platforms\n- Batch operations efficient\n- Clear table-to-code mapping\n\n**Disadvantages:**\n- Doesn't support rich object models\n- Awkward for complex relationships\n- Limited polymorphism\n\n---\n\n## Domain Model\n\n### Definition\n\n**An object model of the domain that incorporates both behavior and data.**\n\n### Structure\n\nObjects represent domain concepts with business logic encapsulated within them. Rich object graphs with inheritance, composition, and polymorphism.\n\n### When to Use\n\n✅ **Good For:**\n- Complex business logic\n- Applications with intricate business rules\n- Long-term, evolving applications\n- Object-oriented teams\n\n❌ **Not Ideal For:**\n- Simple CRUD applications\n- Highly procedural systems\n- Rapid prototypes (initially)\n\n### Example\n\n```typescript\nclass Account {\n  constructor(\n    private readonly id: string,\n    private balance: Money,\n    private overdraftLimit: Money\n  ) {}\n\n  withdraw(amount: Money): void {\n    if (!this.canWithdraw(amount)) {\n      throw new InsufficientFundsError(amount, this.availableBalance());\n    }\n    this.balance = this.balance.subtract(amount);\n  }\n\n  deposit(amount: Money): void {\n    this.balance = this.balance.add(amount);\n  }\n\n  private canWithdraw(amount: Money): boolean {\n    return this.availableBalance().isGreaterThanOrEqual(amount);\n  }\n\n  private availableBalance(): Money {\n    return this.balance.add(this.overdraftLimit);\n  }\n\n  transfer(amount: Money, recipient: Account): void {\n    this.withdraw(amount);\n    recipient.deposit(amount);\n  }\n}\n\nclass PremiumAccount extends Account {\n  constructor(id: string, balance: Money) {\n    super(id, balance, new Money(5000, Currency.USD)); // Higher overdraft\n  }\n\n  // Premium accounts get cashback\n  override withdraw(amount: Money): void {\n    super.withdraw(amount);\n    const cashback = amount.multiply(0.01); // 1% cashback\n    this.deposit(cashback);\n  }\n}\n```\n\n### Best Practices\n\n✅ **DO:**\n- Use rich domain models with behavior\n- Encapsulate business rules in domain objects\n- Use value objects for concepts like Money\n- Employ inheritance and polymorphism\n- Separate domain from infrastructure\n\n❌ **DON'T:**\n- Create anemic domain models (just getters/setters)\n- Mix persistence logic with domain logic\n- Use domain objects as DTOs\n- Let database schema drive domain design\n\n### Trade-offs\n\n**Advantages:**\n- Handles complexity well\n- Highly maintainable\n- Excellent code reuse\n- Supports sophisticated designs\n\n**Disadvantages:**\n- Steeper learning curve\n- More initial development\n- Requires O/R mapping\n- Can be over-engineering for simple cases\n\n---\n\n## Service Layer\n\n### Definition\n\n**Defines an application's boundary with a layer of services that establishes available operations and coordinates application responses.**\n\n### Structure\n\nA set of operations (services) that define the application's API. Sits between presentation and domain layers.\n\n### When to Use\n\n✅ **Good For:**\n- Multiple client types (web, mobile, API)\n- Complex transaction control\n- Security boundaries\n- Remote access scenarios\n\n❌ **Not Ideal For:**\n- Very simple applications\n- Single presentation layer\n- When direct domain access suffices\n\n### Example\n\n```typescript\ninterface TransferMoneyRequest {\n  fromAccountId: string;\n  toAccountId: string;\n  amount: number;\n  currency: string;\n}\n\ninterface TransferMoneyResponse {\n  transactionId: string;\n  newBalance: number;\n  timestamp: Date;\n}\n\nclass AccountService {\n  constructor(\n    private accountRepository: AccountRepository,\n    private transactionRepository: TransactionRepository,\n    private unitOfWork: UnitOfWork\n  ) {}\n\n  async transferMoney(request: TransferMoneyRequest): Promise<TransferMoneyResponse> {\n    // Service orchestrates domain objects\n    const fromAccount = await this.accountRepository.findById(request.fromAccountId);\n    const toAccount = await this.accountRepository.findById(request.toAccountId);\n\n    if (!fromAccount || !toAccount) {\n      throw new AccountNotFoundError();\n    }\n\n    const amount = new Money(request.amount, request.currency);\n\n    // Domain logic executed\n    fromAccount.transfer(amount, toAccount);\n\n    // Create transaction record\n    const transaction = new Transaction(\n      fromAccount.id,\n      toAccount.id,\n      amount,\n      new Date()\n    );\n\n    // Coordinate persistence\n    await this.accountRepository.save(fromAccount);\n    await this.accountRepository.save(toAccount);\n    await this.transactionRepository.save(transaction);\n    await this.unitOfWork.commit();\n\n    return {\n      transactionId: transaction.id,\n      newBalance: fromAccount.balance.amount,\n      timestamp: transaction.date\n    };\n  }\n\n  async getAccountBalance(accountId: string): Promise<number> {\n    const account = await this.accountRepository.findById(accountId);\n    if (!account) {\n      throw new AccountNotFoundError();\n    }\n    return account.balance.amount;\n  }\n}\n```\n\n### Responsibilities\n\n**Service Layer Should:**\n- Define application operations\n- Coordinate domain objects\n- Manage transactions\n- Handle security/authorization\n- Provide API for presentation layer\n\n**Service Layer Should NOT:**\n- Contain business logic (that's in domain)\n- Access database directly (use repositories)\n- Know about UI concerns\n- Duplicate domain logic\n\n### Best Practices\n\n✅ **DO:**\n- Keep services thin (orchestration, not logic)\n- Use DTOs for service boundaries\n- Implement transaction boundaries at service level\n- Make services stateless\n- Design for remote invocation\n\n❌ **DON'T:**\n- Put business logic in services\n- Create services for every domain object\n- Mix service and domain responsibilities\n- Create chatty interfaces with many calls\n\n### Trade-offs\n\n**Advantages:**\n- Clear API boundary\n- Multiple client support\n- Transaction demarcation\n- Security enforcement point\n- Facade for complex operations\n\n**Disadvantages:**\n- Additional layer\n- Risk of anemic domain if overused\n- Can become procedural\n\n---\n\n## Combining Patterns\n\n### Domain Model + Service Layer\n\n```typescript\n// Domain\nclass Order {\n  private items: OrderItem[] = [];\n\n  addItem(product: Product, quantity: number) {\n    this.items.push(new OrderItem(product, quantity));\n  }\n\n  calculateTotal(): Money {\n    return this.items.reduce(\n      (sum, item) => sum.add(item.subtotal()),\n      Money.zero()\n    );\n  }\n}\n\n// Service Layer\nclass OrderService {\n  constructor(\n    private orderRepo: OrderRepository,\n    private productRepo: ProductRepository\n  ) {}\n\n  async createOrder(request: CreateOrderRequest): Promise<OrderResponse> {\n    const order = new Order(request.customerId);\n\n    for (const item of request.items) {\n      const product = await this.productRepo.findById(item.productId);\n      order.addItem(product, item.quantity);\n    }\n\n    await this.orderRepo.save(order);\n    return { orderId: order.id, total: order.calculateTotal().amount };\n  }\n}\n```\n\n## Pattern Selection Decision Tree\n\n```\nStart\n  ├─ Simple logic, SQL-focused? → Transaction Script\n  ├─ Table-centric, batch operations? → Table Module\n  ├─ Complex business rules? → Domain Model\n  │   └─ Multiple clients or remote access? → + Service Layer\n  └─ Need clear API boundary? → Service Layer\n      └─ What underneath? → Choose from above\n```\n\n## Common Pitfalls\n\n❌ **Anemic Domain Model:** Domain objects with no behavior (just data)\n❌ **Fat Services:** All logic in service layer, domain just data\n❌ **Wrong Pattern:** Using Domain Model for simple CRUD\n❌ **No Separation:** Mixing scripts with presentation\n❌ **Over-Layering:** Service layer with no real orchestration\n\n## Key Takeaways\n\n1. **Transaction Script:** Simple, procedural, direct SQL\n2. **Table Module:** One class per table, batch operations\n3. **Domain Model:** Rich objects, complex rules, OO design\n4. **Service Layer:** API boundary, orchestration, transaction control\n5. **Combine patterns** for best results (Domain Model + Service Layer)\n",
    "original/enterprise-patterns/gang-of-four-patterns.md": "# Gang of Four Design Patterns\n\n## Overview\n\nClassic design patterns from \"Design Patterns: Elements of Reusable Object-Oriented Software\" by Gang of Four (GoF). These patterns solve common object-oriented design problems.\n\n## Pattern Categories\n\n- **Creational:** Object creation mechanisms\n- **Structural:** Object composition and relationships\n- **Behavioral:** Communication between objects\n\n---\n\n# Creational Patterns\n\n## Singleton\n\n### Definition\n\n**Ensure a class has only one instance and provide a global access point to it.**\n\n### When to Use\n\n✅ **Good For:**\n- Configuration management\n- Connection pools\n- Logging\n- Caching\n\n❌ **Avoid When:**\n- Testing is important (hard to mock)\n- Multiple instances might be needed later\n- State management is complex\n\n### Example\n\n```typescript\nclass Database {\n  private static instance: Database;\n  private connection: any;\n\n  private constructor() {\n    this.connection = this.createConnection();\n  }\n\n  static getInstance(): Database {\n    if (!Database.instance) {\n      Database.instance = new Database();\n    }\n    return Database.instance;\n  }\n\n  query(sql: string): any {\n    return this.connection.execute(sql);\n  }\n\n  private createConnection(): any {\n    return { /* connection logic */ };\n  }\n}\n\n// Usage\nconst db = Database.getInstance();\ndb.query('SELECT * FROM users');\n```\n\n### Better Alternative (Dependency Injection)\n\n```typescript\n// Instead of singleton, use DI container\nclass Database {\n  constructor(private config: DatabaseConfig) {\n    this.connection = this.createConnection(config);\n  }\n}\n\n// DI container ensures single instance\ncontainer.registerSingleton('database', () => new Database(config));\n```\n\n---\n\n## Factory Method\n\n### Definition\n\n**Define an interface for creating an object, but let subclasses decide which class to instantiate.**\n\n### When to Use\n\n✅ **Good For:**\n- When class can't anticipate object types to create\n- Subclasses specify objects to create\n- Delegating responsibility to helper subclasses\n\n### Example\n\n```typescript\ninterface Logger {\n  log(message: string): void;\n}\n\nclass ConsoleLogger implements Logger {\n  log(message: string): void {\n    console.log(message);\n  }\n}\n\nclass FileLogger implements Logger {\n  log(message: string): void {\n    // Write to file\n  }\n}\n\nabstract class Application {\n  abstract createLogger(): Logger;\n\n  run(): void {\n    const logger = this.createLogger();\n    logger.log('Application started');\n  }\n}\n\nclass DevelopmentApp extends Application {\n  createLogger(): Logger {\n    return new ConsoleLogger();\n  }\n}\n\nclass ProductionApp extends Application {\n  createLogger(): Logger {\n    return new FileLogger();\n  }\n}\n```\n\n---\n\n## Abstract Factory\n\n### Definition\n\n**Provide an interface for creating families of related or dependent objects without specifying their concrete classes.**\n\n### When to Use\n\n✅ **Good For:**\n- Systems with multiple product families\n- Need to enforce product family constraints\n- Hide concrete implementations\n\n### Example\n\n```typescript\ninterface Button {\n  render(): void;\n}\n\ninterface Checkbox {\n  render(): void;\n}\n\ninterface GUIFactory {\n  createButton(): Button;\n  createCheckbox(): Checkbox;\n}\n\nclass WindowsButton implements Button {\n  render(): void {\n    console.log('Rendering Windows button');\n  }\n}\n\nclass MacButton implements Button {\n  render(): void {\n    console.log('Rendering Mac button');\n  }\n}\n\nclass WindowsFactory implements GUIFactory {\n  createButton(): Button {\n    return new WindowsButton();\n  }\n\n  createCheckbox(): Checkbox {\n    return new WindowsCheckbox();\n  }\n}\n\nclass MacFactory implements GUIFactory {\n  createButton(): Button {\n    return new MacButton();\n  }\n\n  createCheckbox(): Checkbox {\n    return new MacCheckbox();\n  }\n}\n\n// Usage\nfunction renderUI(factory: GUIFactory) {\n  const button = factory.createButton();\n  const checkbox = factory.createCheckbox();\n\n  button.render();\n  checkbox.render();\n}\n\nconst os = getOS();\nconst factory = os === 'windows' ? new WindowsFactory() : new MacFactory();\nrenderUI(factory);\n```\n\n---\n\n## Builder\n\n### Definition\n\n**Separate construction of a complex object from its representation, allowing same construction process to create different representations.**\n\n### When to Use\n\n✅ **Good For:**\n- Objects with many optional parameters\n- Step-by-step construction\n- Immutable objects\n- Complex initialization logic\n\n### Example\n\n```typescript\nclass Query {\n  constructor(\n    public table: string,\n    public columns: string[],\n    public where?: string,\n    public orderBy?: string,\n    public limit?: number\n  ) {}\n\n  toString(): string {\n    let sql = `SELECT ${this.columns.join(', ')} FROM ${this.table}`;\n    if (this.where) sql += ` WHERE ${this.where}`;\n    if (this.orderBy) sql += ` ORDER BY ${this.orderBy}`;\n    if (this.limit) sql += ` LIMIT ${this.limit}`;\n    return sql;\n  }\n}\n\nclass QueryBuilder {\n  private table: string = '';\n  private columns: string[] = ['*'];\n  private where?: string;\n  private orderBy?: string;\n  private limit?: number;\n\n  from(table: string): this {\n    this.table = table;\n    return this;\n  }\n\n  select(...columns: string[]): this {\n    this.columns = columns;\n    return this;\n  }\n\n  whereClause(condition: string): this {\n    this.where = condition;\n    return this;\n  }\n\n  order(column: string): this {\n    this.orderBy = column;\n    return this;\n  }\n\n  take(count: number): this {\n    this.limit = count;\n    return this;\n  }\n\n  build(): Query {\n    if (!this.table) {\n      throw new Error('Table is required');\n    }\n    return new Query(\n      this.table,\n      this.columns,\n      this.where,\n      this.orderBy,\n      this.limit\n    );\n  }\n}\n\n// Usage\nconst query = new QueryBuilder()\n  .from('users')\n  .select('id', 'name', 'email')\n  .whereClause('age > 18')\n  .order('name')\n  .take(10)\n  .build();\n\nconsole.log(query.toString());\n// SELECT id, name, email FROM users WHERE age > 18 ORDER BY name LIMIT 10\n```\n\n---\n\n## Prototype\n\n### Definition\n\n**Specify kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.**\n\n### When to Use\n\n✅ **Good For:**\n- Avoiding expensive initialization\n- Creating objects similar to existing ones\n- Runtime object specification\n\n### Example\n\n```typescript\ninterface Cloneable<T> {\n  clone(): T;\n}\n\nclass Configuration implements Cloneable<Configuration> {\n  constructor(\n    public database: string,\n    public port: number,\n    public settings: Map<string, any>\n  ) {}\n\n  clone(): Configuration {\n    return new Configuration(\n      this.database,\n      this.port,\n      new Map(this.settings)\n    );\n  }\n}\n\n// Usage\nconst defaultConfig = new Configuration(\n  'postgres://localhost',\n  5432,\n  new Map([['timeout', 3000]])\n);\n\nconst testConfig = defaultConfig.clone();\ntestConfig.database = 'postgres://test-db';\ntestConfig.settings.set('timeout', 5000);\n```\n\n---\n\n# Structural Patterns\n\n## Adapter\n\n### Definition\n\n**Convert interface of a class into another interface clients expect, allowing incompatible interfaces to work together.**\n\n### When to Use\n\n✅ **Good For:**\n- Integrating third-party libraries\n- Working with legacy code\n- Creating reusable components\n\n### Example\n\n```typescript\n// Third-party library we can't modify\nclass OldPaymentSystem {\n  makePayment(accountNumber: string, amount: number): boolean {\n    console.log(`Old system: Paid ${amount} from account ${accountNumber}`);\n    return true;\n  }\n}\n\n// Our application interface\ninterface PaymentProcessor {\n  processPayment(userId: string, amount: number): Promise<boolean>;\n}\n\n// Adapter\nclass PaymentAdapter implements PaymentProcessor {\n  constructor(private oldSystem: OldPaymentSystem) {}\n\n  async processPayment(userId: string, amount: number): Promise<boolean> {\n    // Adapt new interface to old\n    const accountNumber = await this.getUserAccountNumber(userId);\n    return this.oldSystem.makePayment(accountNumber, amount);\n  }\n\n  private async getUserAccountNumber(userId: string): Promise<string> {\n    // Convert user ID to account number\n    return `ACC-${userId}`;\n  }\n}\n\n// Usage\nconst oldSystem = new OldPaymentSystem();\nconst processor: PaymentProcessor = new PaymentAdapter(oldSystem);\nawait processor.processPayment('user-123', 100.00);\n```\n\n---\n\n## Decorator\n\n### Definition\n\n**Attach additional responsibilities to an object dynamically, providing flexible alternative to subclassing for extending functionality.**\n\n### When to Use\n\n✅ **Good For:**\n- Adding features to individual objects\n- Composable behaviors\n- Open/Closed Principle\n- Avoiding feature explosion through inheritance\n\n### Example\n\n```typescript\ninterface Coffee {\n  cost(): number;\n  description(): string;\n}\n\nclass SimpleCoffee implements Coffee {\n  cost(): number {\n    return 5;\n  }\n\n  description(): string {\n    return 'Simple coffee';\n  }\n}\n\nabstract class CoffeeDecorator implements Coffee {\n  constructor(protected coffee: Coffee) {}\n\n  cost(): number {\n    return this.coffee.cost();\n  }\n\n  description(): string {\n    return this.coffee.description();\n  }\n}\n\nclass MilkDecorator extends CoffeeDecorator {\n  cost(): number {\n    return this.coffee.cost() + 2;\n  }\n\n  description(): string {\n    return this.coffee.description() + ', milk';\n  }\n}\n\nclass SugarDecorator extends CoffeeDecorator {\n  cost(): number {\n    return this.coffee.cost() + 1;\n  }\n\n  description(): string {\n    return this.coffee.description() + ', sugar';\n  }\n}\n\n// Usage\nlet coffee: Coffee = new SimpleCoffee();\nconsole.log(`${coffee.description()}: $${coffee.cost()}`);\n// Simple coffee: $5\n\ncoffee = new MilkDecorator(coffee);\ncoffee = new SugarDecorator(coffee);\nconsole.log(`${coffee.description()}: $${coffee.cost()}`);\n// Simple coffee, milk, sugar: $8\n```\n\n---\n\n## Facade\n\n### Definition\n\n**Provide a unified interface to a set of interfaces in a subsystem, making the subsystem easier to use.**\n\n### When to Use\n\n✅ **Good For:**\n- Simplifying complex systems\n- Providing high-level interface\n- Decoupling clients from subsystems\n- Layered architecture\n\n### Example\n\n```typescript\n// Complex subsystem\nclass CPU {\n  freeze(): void { console.log('CPU frozen'); }\n  jump(position: number): void { console.log(`CPU jumped to ${position}`); }\n  execute(): void { console.log('CPU executing'); }\n}\n\nclass Memory {\n  load(position: number, data: string): void {\n    console.log(`Memory loaded ${data} at ${position}`);\n  }\n}\n\nclass HardDrive {\n  read(lba: number, size: number): string {\n    console.log(`HardDrive read ${size} bytes from ${lba}`);\n    return 'boot data';\n  }\n}\n\n// Facade\nclass ComputerFacade {\n  constructor(\n    private cpu: CPU,\n    private memory: Memory,\n    private hardDrive: HardDrive\n  ) {}\n\n  start(): void {\n    this.cpu.freeze();\n    const bootData = this.hardDrive.read(0, 1024);\n    this.memory.load(0, bootData);\n    this.cpu.jump(0);\n    this.cpu.execute();\n  }\n}\n\n// Usage\nconst computer = new ComputerFacade(\n  new CPU(),\n  new Memory(),\n  new HardDrive()\n);\n\ncomputer.start(); // Simple interface for complex operation\n```\n\n---\n\n## Proxy\n\n### Definition\n\n**Provide a surrogate or placeholder for another object to control access to it.**\n\n### Types\n\n1. **Remote Proxy:** Represents object in different address space\n2. **Virtual Proxy:** Lazy initialization\n3. **Protection Proxy:** Access control\n4. **Smart Proxy:** Additional actions when accessing\n\n### Example\n\n```typescript\ninterface Image {\n  display(): void;\n}\n\nclass RealImage implements Image {\n  constructor(private filename: string) {\n    this.loadFromDisk();\n  }\n\n  private loadFromDisk(): void {\n    console.log(`Loading ${this.filename} from disk...`);\n  }\n\n  display(): void {\n    console.log(`Displaying ${this.filename}`);\n  }\n}\n\nclass ImageProxy implements Image {\n  private realImage?: RealImage;\n\n  constructor(private filename: string) {}\n\n  display(): void {\n    if (!this.realImage) {\n      this.realImage = new RealImage(this.filename); // Lazy load\n    }\n    this.realImage.display();\n  }\n}\n\n// Usage\nconst image: Image = new ImageProxy('photo.jpg');\n// Image not loaded yet\n\nimage.display(); // Loads and displays\n// Loading photo.jpg from disk...\n// Displaying photo.jpg\n\nimage.display(); // Just displays (already loaded)\n// Displaying photo.jpg\n```\n\n---\n\n# Behavioral Patterns\n\n## Strategy\n\n### Definition\n\n**Define a family of algorithms, encapsulate each one, and make them interchangeable.**\n\n### When to Use\n\n✅ **Good For:**\n- Multiple algorithms for same purpose\n- Avoiding conditional logic\n- Runtime algorithm selection\n- Open/Closed Principle\n\n### Example\n\n```typescript\ninterface SortStrategy {\n  sort(data: number[]): number[];\n}\n\nclass QuickSort implements SortStrategy {\n  sort(data: number[]): number[] {\n    console.log('Using QuickSort');\n    // QuickSort implementation\n    return data.sort((a, b) => a - b);\n  }\n}\n\nclass MergeSort implements SortStrategy {\n  sort(data: number[]): number[] {\n    console.log('Using MergeSort');\n    // MergeSort implementation\n    return data.sort((a, b) => a - b);\n  }\n}\n\nclass Sorter {\n  constructor(private strategy: SortStrategy) {}\n\n  setStrategy(strategy: SortStrategy): void {\n    this.strategy = strategy;\n  }\n\n  sort(data: number[]): number[] {\n    return this.strategy.sort(data);\n  }\n}\n\n// Usage\nconst sorter = new Sorter(new QuickSort());\nsorter.sort([3, 1, 4, 1, 5, 9]);\n\nsorter.setStrategy(new MergeSort());\nsorter.sort([2, 7, 1, 8, 2, 8]);\n```\n\n---\n\n## Observer\n\n### Definition\n\n**Define one-to-many dependency so when one object changes state, all dependents are notified automatically.**\n\n### When to Use\n\n✅ **Good For:**\n- Event handling systems\n- MVC/MVVM patterns\n- Reactive programming\n- Loosely coupled systems\n\n### Example\n\n```typescript\ninterface Observer {\n  update(subject: Subject): void;\n}\n\ninterface Subject {\n  attach(observer: Observer): void;\n  detach(observer: Observer): void;\n  notify(): void;\n}\n\nclass Stock implements Subject {\n  private observers: Observer[] = [];\n  private price: number = 0;\n\n  attach(observer: Observer): void {\n    this.observers.push(observer);\n  }\n\n  detach(observer: Observer): void {\n    const index = this.observers.indexOf(observer);\n    if (index > -1) {\n      this.observers.splice(index, 1);\n    }\n  }\n\n  notify(): void {\n    for (const observer of this.observers) {\n      observer.update(this);\n    }\n  }\n\n  setPrice(price: number): void {\n    this.price = price;\n    this.notify();\n  }\n\n  getPrice(): number {\n    return this.price;\n  }\n}\n\nclass StockDisplay implements Observer {\n  constructor(private name: string) {}\n\n  update(subject: Subject): void {\n    if (subject instanceof Stock) {\n      console.log(`${this.name}: Stock price changed to $${subject.getPrice()}`);\n    }\n  }\n}\n\n// Usage\nconst stock = new Stock();\nconst display1 = new StockDisplay('Display 1');\nconst display2 = new StockDisplay('Display 2');\n\nstock.attach(display1);\nstock.attach(display2);\n\nstock.setPrice(100);\n// Display 1: Stock price changed to $100\n// Display 2: Stock price changed to $100\n```\n\n---\n\n## Command\n\n### Definition\n\n**Encapsulate a request as an object, allowing parameterization and queuing of requests.**\n\n### When to Use\n\n✅ **Good For:**\n- Undo/redo functionality\n- Queuing operations\n- Logging changes\n- Transaction systems\n\n### Example\n\n```typescript\ninterface Command {\n  execute(): void;\n  undo(): void;\n}\n\nclass TextEditor {\n  private text: string = '';\n\n  append(text: string): void {\n    this.text += text;\n  }\n\n  delete(length: number): void {\n    this.text = this.text.slice(0, -length);\n  }\n\n  getText(): string {\n    return this.text;\n  }\n}\n\nclass AppendCommand implements Command {\n  constructor(\n    private editor: TextEditor,\n    private text: string\n  ) {}\n\n  execute(): void {\n    this.editor.append(this.text);\n  }\n\n  undo(): void {\n    this.editor.delete(this.text.length);\n  }\n}\n\nclass CommandHistory {\n  private history: Command[] = [];\n  private current: number = -1;\n\n  execute(command: Command): void {\n    // Remove any commands after current position\n    this.history = this.history.slice(0, this.current + 1);\n\n    command.execute();\n    this.history.push(command);\n    this.current++;\n  }\n\n  undo(): void {\n    if (this.current >= 0) {\n      this.history[this.current].undo();\n      this.current--;\n    }\n  }\n\n  redo(): void {\n    if (this.current < this.history.length - 1) {\n      this.current++;\n      this.history[this.current].execute();\n    }\n  }\n}\n\n// Usage\nconst editor = new TextEditor();\nconst history = new CommandHistory();\n\nhistory.execute(new AppendCommand(editor, 'Hello '));\nhistory.execute(new AppendCommand(editor, 'World'));\nconsole.log(editor.getText()); // Hello World\n\nhistory.undo();\nconsole.log(editor.getText()); // Hello\n\nhistory.redo();\nconsole.log(editor.getText()); // Hello World\n```\n\n---\n\n## Template Method\n\n### Definition\n\n**Define skeleton of algorithm in operation, deferring some steps to subclasses.**\n\n### When to Use\n\n✅ **Good For:**\n- Common algorithm structure with variations\n- Enforcing algorithm steps\n- Avoiding code duplication\n\n### Example\n\n```typescript\nabstract class DataProcessor {\n  process(): void {\n    this.readData();\n    this.processData();\n    this.writeData();\n  }\n\n  abstract readData(): void;\n  abstract processData(): void;\n  abstract writeData(): void;\n}\n\nclass CSVProcessor extends DataProcessor {\n  private data: string[] = [];\n\n  readData(): void {\n    console.log('Reading CSV file');\n    this.data = ['row1', 'row2', 'row3'];\n  }\n\n  processData(): void {\n    console.log('Processing CSV data');\n    this.data = this.data.map(row => row.toUpperCase());\n  }\n\n  writeData(): void {\n    console.log('Writing CSV file');\n    console.log(this.data);\n  }\n}\n\nclass JSONProcessor extends DataProcessor {\n  private data: any;\n\n  readData(): void {\n    console.log('Reading JSON file');\n    this.data = { items: [1, 2, 3] };\n  }\n\n  processData(): void {\n    console.log('Processing JSON data');\n    this.data.items = this.data.items.map((x: number) => x * 2);\n  }\n\n  writeData(): void {\n    console.log('Writing JSON file');\n    console.log(this.data);\n  }\n}\n\n// Usage\nconst csvProcessor = new CSVProcessor();\ncsvProcessor.process();\n\nconst jsonProcessor = new JSONProcessor();\njsonProcessor.process();\n```\n\n---\n\n## Chain of Responsibility\n\n### Definition\n\n**Pass request along chain of handlers where each handler decides to process or pass to next handler.**\n\n### When to Use\n\n✅ **Good For:**\n- Request processing pipelines\n- Middleware systems\n- Event bubbling\n- Multiple handlers for single request\n\n### Example\n\n```typescript\ninterface Handler {\n  setNext(handler: Handler): Handler;\n  handle(request: string): string | null;\n}\n\nabstract class AbstractHandler implements Handler {\n  private nextHandler?: Handler;\n\n  setNext(handler: Handler): Handler {\n    this.nextHandler = handler;\n    return handler;\n  }\n\n  handle(request: string): string | null {\n    if (this.nextHandler) {\n      return this.nextHandler.handle(request);\n    }\n    return null;\n  }\n}\n\nclass AuthHandler extends AbstractHandler {\n  handle(request: string): string | null {\n    if (request.includes('auth')) {\n      return 'AuthHandler: Request authenticated';\n    }\n    return super.handle(request);\n  }\n}\n\nclass LoggingHandler extends AbstractHandler {\n  handle(request: string): string | null {\n    console.log(`LoggingHandler: Logging request - ${request}`);\n    return super.handle(request);\n  }\n}\n\nclass ValidationHandler extends AbstractHandler {\n  handle(request: string): string | null {\n    if (request.length > 0) {\n      console.log('ValidationHandler: Request valid');\n      return super.handle(request);\n    }\n    return 'ValidationHandler: Invalid request';\n  }\n}\n\n// Usage\nconst auth = new AuthHandler();\nconst logging = new LoggingHandler();\nconst validation = new ValidationHandler();\n\nauth.setNext(logging).setNext(validation);\n\nconsole.log(auth.handle('auth request'));\n// LoggingHandler: Logging request - auth request\n// AuthHandler: Request authenticated\n```\n\n---\n\n## Common Pattern Combinations\n\n### Strategy + Factory\n\n```typescript\ninterface PaymentStrategy {\n  pay(amount: number): void;\n}\n\nclass PaymentStrategyFactory {\n  static create(type: string): PaymentStrategy {\n    switch (type) {\n      case 'credit': return new CreditCardStrategy();\n      case 'paypal': return new PayPalStrategy();\n      default: throw new Error('Unknown payment type');\n    }\n  }\n}\n```\n\n### Observer + Singleton\n\n```typescript\nclass EventBus {\n  private static instance: EventBus;\n  private observers = new Map<string, Observer[]>();\n\n  static getInstance(): EventBus {\n    if (!EventBus.instance) {\n      EventBus.instance = new EventBus();\n    }\n    return EventBus.instance;\n  }\n\n  subscribe(event: string, observer: Observer): void {\n    // Observer pattern implementation\n  }\n}\n```\n\n## Key Takeaways\n\n**Creational:**\n- Singleton: One instance\n- Factory: Create objects without specifying class\n- Builder: Construct complex objects step-by-step\n\n**Structural:**\n- Adapter: Make incompatible interfaces work\n- Decorator: Add behavior dynamically\n- Facade: Simplify complex systems\n\n**Behavioral:**\n- Strategy: Interchangeable algorithms\n- Observer: Notify dependents of changes\n- Command: Encapsulate requests as objects\n",
    "patterns/base-patterns.md": "# Base Patterns\n\n## Value Object\n\nImmutable object defined by its value, not identity.\n\n```typescript\nclass Email {\n  private readonly value: string;\n\n  constructor(email: string) {\n    if (!this.isValid(email)) throw new Error('Invalid email');\n    this.value = email.toLowerCase();\n  }\n\n  equals(other: Email): boolean {\n    return this.value === other.value;\n  }\n}\n\nclass Money {\n  constructor(\n    public readonly amount: number,\n    public readonly currency: Currency\n  ) {\n    Object.freeze(this);\n  }\n\n  add(other: Money): Money {\n    this.assertSameCurrency(other);\n    return new Money(this.amount + other.amount, this.currency);\n  }\n}\n```\n\n## Special Case (Null Object)\n\nReplace null checks with polymorphism.\n\n```typescript\nabstract class Customer {\n  abstract getDiscount(): number;\n}\n\nclass RealCustomer extends Customer {\n  getDiscount(): number { return 0.1; }\n}\n\nclass GuestCustomer extends Customer {\n  getDiscount(): number { return 0; } // No discount\n}\n\n// No null checks needed\nconst customer = repo.findById(id) || new GuestCustomer();\nconst discount = customer.getDiscount();\n```\n\n## Registry\n\nGlobal access point for services.\n\n```typescript\nclass ServiceRegistry {\n  private static services = new Map<string, any>();\n\n  static register<T>(key: string, service: T): void {\n    this.services.set(key, service);\n  }\n\n  static get<T>(key: string): T {\n    return this.services.get(key);\n  }\n}\n\n// Prefer dependency injection over registry\n```\n\n## Plugin\n\nExtend behavior without modifying core code.\n\n```typescript\ninterface ValidationPlugin {\n  validate(user: User): ValidationResult;\n}\n\nclass UserValidator {\n  private plugins: ValidationPlugin[] = [];\n\n  registerPlugin(plugin: ValidationPlugin): void {\n    this.plugins.push(plugin);\n  }\n\n  validate(user: User): ValidationResult[] {\n    return this.plugins.map(p => p.validate(user));\n  }\n}\n```\n\n## Best Practices\n\n- Use Value Objects to avoid primitive obsession\n- Make Value Objects immutable\n- Use Special Case instead of null checks\n- Prefer dependency injection over Registry\n",
    "patterns/concurrency.md": "# Concurrency Patterns\n\n## Optimistic Locking\n\nDetect conflicts on commit using version numbers.\n\n```typescript\nclass Product {\n  constructor(\n    public id: string,\n    public name: string,\n    public version: number = 1\n  ) {}\n}\n\nclass ProductRepository {\n  async save(product: Product): Promise<void> {\n    const result = await this.db.execute(\n      `UPDATE products SET name = $1, version = version + 1\n       WHERE id = $2 AND version = $3`,\n      [product.name, product.id, product.version]\n    );\n\n    if (result.rowCount === 0) {\n      throw new OptimisticLockException('Product was modified');\n    }\n    product.version++;\n  }\n}\n```\n\n## Pessimistic Locking\n\nLock resources before editing.\n\n```typescript\nclass LockManager {\n  async acquireLock(resourceId: string, ownerId: string): Promise<boolean> {\n    const existing = await this.db.queryOne(\n      'SELECT * FROM locks WHERE resource_id = $1 AND expires_at > NOW()',\n      [resourceId]\n    );\n\n    if (existing) return false;\n\n    await this.db.execute(\n      'INSERT INTO locks (resource_id, owner_id, expires_at) VALUES ($1, $2, $3)',\n      [resourceId, ownerId, new Date(Date.now() + 30000)]\n    );\n    return true;\n  }\n\n  async releaseLock(resourceId: string, ownerId: string): Promise<void> {\n    await this.db.execute(\n      'DELETE FROM locks WHERE resource_id = $1 AND owner_id = $2',\n      [resourceId, ownerId]\n    );\n  }\n}\n```\n\n## Coarse-Grained Lock\n\nLock entire aggregate rather than individual entities.\n\n```typescript\nclass OrderRepository {\n  async save(order: Order): Promise<void> {\n    // Lock aggregate root, all children implicitly locked\n    await this.db.execute(\n      'SELECT * FROM orders WHERE id = $1 FOR UPDATE',\n      [order.id]\n    );\n\n    // Update order and all items in single transaction\n    await this.updateOrder(order);\n    await this.updateOrderItems(order.items);\n  }\n}\n```\n\n## Best Practices\n\n- Use optimistic locking for low-contention scenarios\n- Use pessimistic locking for high-contention or critical data\n- Always set lock timeouts\n- Implement retry logic with exponential backoff\n",
    "patterns/data-access.md": "# Data Access Patterns\n\n## Repository\n\nCollection-like interface for domain objects.\n\n```typescript\ninterface UserRepository {\n  findById(id: string): Promise<User | null>;\n  findByEmail(email: string): Promise<User | null>;\n  save(user: User): Promise<void>;\n  delete(user: User): Promise<void>;\n}\n\nclass PostgreSQLUserRepository implements UserRepository {\n  async findById(id: string): Promise<User | null> {\n    const row = await this.db.queryOne('SELECT * FROM users WHERE id = $1', [id]);\n    return row ? this.mapToUser(row) : null;\n  }\n}\n```\n\n## Data Mapper\n\nComplete separation between domain and persistence.\n\n```typescript\nclass UserMapper {\n  toDomain(row: DbRow): User {\n    return new User(row.id, row.name, new Email(row.email));\n  }\n\n  toDatabase(user: User): DbRow {\n    return { id: user.id, name: user.name, email: user.email.toString() };\n  }\n}\n```\n\n## Unit of Work\n\nTrack changes and commit together.\n\n```typescript\nclass UnitOfWork {\n  private newObjects = new Set<any>();\n  private dirtyObjects = new Set<any>();\n\n  registerNew(obj: any): void { this.newObjects.add(obj); }\n  registerDirty(obj: any): void { this.dirtyObjects.add(obj); }\n\n  async commit(): Promise<void> {\n    await this.db.beginTransaction();\n    try {\n      for (const obj of this.newObjects) await this.insert(obj);\n      for (const obj of this.dirtyObjects) await this.update(obj);\n      await this.db.commit();\n    } catch (e) {\n      await this.db.rollback();\n      throw e;\n    }\n  }\n}\n```\n\n## Identity Map\n\nEnsure each object loaded only once per session.\n\n```typescript\nclass IdentityMap {\n  private map = new Map<string, any>();\n\n  get(id: string): any | null { return this.map.get(id) || null; }\n  put(id: string, obj: any): void { this.map.set(id, obj); }\n}\n```\n\n## Best Practices\n\n- Return domain objects from repositories\n- Use one repository per aggregate root\n- Keep repositories focused on persistence\n- Don't leak database details into domain\n",
    "patterns/distribution.md": "# Distribution Patterns\n\n## Remote Facade\n\nCoarse-grained interface to reduce network calls.\n\n```typescript\n// Bad: Multiple network calls\nconst customer = await api.getCustomer(id);\nconst orders = await api.getOrders(id);\nconst addresses = await api.getAddresses(id);\n\n// Good: Single call via facade\nconst details = await api.getCustomerDetails(id);\n// Returns { customer, orders, addresses }\n```\n\n## Data Transfer Object (DTO)\n\nBundle data for transfer across boundaries.\n\n```typescript\ninterface OrderDTO {\n  id: string;\n  customerId: string;\n  items: OrderItemDTO[];\n  total: number;\n  status: string;\n}\n\nclass OrderDTOMapper {\n  static toDTO(order: Order): OrderDTO {\n    return {\n      id: order.id,\n      customerId: order.customer.id,\n      items: order.items.map(i => this.itemToDTO(i)),\n      total: order.total.amount,\n      status: order.status.toString()\n    };\n  }\n}\n```\n\n## Gateway\n\nAbstract external system access.\n\n```typescript\ninterface PaymentGateway {\n  charge(amount: Money, method: PaymentMethod): Promise<PaymentResult>;\n}\n\nclass StripeGateway implements PaymentGateway {\n  async charge(amount: Money, method: PaymentMethod): Promise<PaymentResult> {\n    const result = await this.stripe.paymentIntents.create({\n      amount: amount.cents,\n      currency: amount.currency\n    });\n    return this.mapToResult(result);\n  }\n}\n```\n\n## Service Stub\n\nTest double for external services.\n\n```typescript\nclass StubPaymentGateway implements PaymentGateway {\n  private shouldSucceed = true;\n\n  async charge(amount: Money): Promise<PaymentResult> {\n    if (!this.shouldSucceed) throw new PaymentDeclinedError();\n    return { success: true, transactionId: 'stub-123' };\n  }\n\n  configureFail(): void { this.shouldSucceed = false; }\n}\n```\n\n## Best Practices\n\n- Design facades around client use cases\n- Keep DTOs simple and serializable\n- Isolate vendor code in gateways\n- Use stubs for testing, not production\n",
    "patterns/domain-logic.md": "# Domain Logic Patterns\n\n## Transaction Script\n\nProcedural approach - one procedure per operation.\n\n```typescript\nasync function transferMoney(fromId: string, toId: string, amount: number) {\n  const db = await Database.connect();\n  await db.beginTransaction();\n\n  try {\n    const from = await db.query('SELECT * FROM accounts WHERE id = $1', [fromId]);\n    if (from.balance < amount) throw new Error('Insufficient funds');\n\n    await db.execute('UPDATE accounts SET balance = balance - $1 WHERE id = $2', [amount, fromId]);\n    await db.execute('UPDATE accounts SET balance = balance + $1 WHERE id = $2', [amount, toId]);\n    await db.commit();\n  } catch (e) {\n    await db.rollback();\n    throw e;\n  }\n}\n```\n\n**Use for:** Simple apps, CRUD, reports.\n\n## Domain Model\n\nRich objects with behavior.\n\n```typescript\nclass Account {\n  constructor(private balance: Money, private overdraftLimit: Money) {}\n\n  withdraw(amount: Money): void {\n    if (!this.canWithdraw(amount)) throw new InsufficientFundsError();\n    this.balance = this.balance.subtract(amount);\n  }\n\n  transfer(amount: Money, recipient: Account): void {\n    this.withdraw(amount);\n    recipient.deposit(amount);\n  }\n}\n```\n\n**Use for:** Complex business rules, rich domains.\n\n## Service Layer\n\nApplication boundary coordinating domain objects.\n\n```typescript\nclass AccountService {\n  constructor(\n    private accountRepo: AccountRepository,\n    private unitOfWork: UnitOfWork\n  ) {}\n\n  async transfer(fromId: string, toId: string, amount: Money): Promise<void> {\n    const from = await this.accountRepo.findById(fromId);\n    const to = await this.accountRepo.findById(toId);\n\n    from.transfer(amount, to); // Domain logic\n\n    await this.accountRepo.save(from);\n    await this.accountRepo.save(to);\n    await this.unitOfWork.commit();\n  }\n}\n```\n\n**Use for:** API boundaries, multiple clients, transaction coordination.\n\n## Best Practices\n\n- Choose pattern based on complexity\n- Service layer orchestrates, domain model contains logic\n- Keep services thin, domain objects rich\n- Combine Domain Model + Service Layer for complex apps\n",
    "patterns/gof.md": "# Gang of Four Patterns\n\n## Creational\n\n### Factory Method\n```typescript\ninterface Logger { log(msg: string): void; }\n\nabstract class Application {\n  abstract createLogger(): Logger;\n  run(): void { this.createLogger().log('Started'); }\n}\n\nclass DevApp extends Application {\n  createLogger(): Logger { return new ConsoleLogger(); }\n}\n```\n\n### Builder\n```typescript\nconst query = new QueryBuilder()\n  .from('users')\n  .select('id', 'name')\n  .where('active = true')\n  .limit(10)\n  .build();\n```\n\n## Structural\n\n### Adapter\n```typescript\nclass PaymentAdapter implements PaymentProcessor {\n  constructor(private legacy: OldPaymentSystem) {}\n\n  async process(amount: number): Promise<boolean> {\n    return this.legacy.makePayment(amount);\n  }\n}\n```\n\n### Decorator\n```typescript\ninterface Coffee { cost(): number; }\n\nclass MilkDecorator implements Coffee {\n  constructor(private coffee: Coffee) {}\n  cost(): number { return this.coffee.cost() + 2; }\n}\n\nlet coffee: Coffee = new SimpleCoffee();\ncoffee = new MilkDecorator(coffee);\n```\n\n### Facade\n```typescript\nclass ComputerFacade {\n  start(): void {\n    this.cpu.freeze();\n    this.memory.load(0, this.hdd.read(0, 1024));\n    this.cpu.execute();\n  }\n}\n```\n\n## Behavioral\n\n### Strategy\n```typescript\ninterface SortStrategy { sort(data: number[]): number[]; }\n\nclass Sorter {\n  constructor(private strategy: SortStrategy) {}\n  sort(data: number[]): number[] { return this.strategy.sort(data); }\n}\n```\n\n### Observer\n```typescript\nclass Stock {\n  private observers: Observer[] = [];\n\n  attach(o: Observer): void { this.observers.push(o); }\n  notify(): void { this.observers.forEach(o => o.update(this)); }\n\n  setPrice(price: number): void {\n    this.price = price;\n    this.notify();\n  }\n}\n```\n\n### Command\n```typescript\ninterface Command { execute(): void; undo(): void; }\n\nclass AppendCommand implements Command {\n  constructor(private editor: Editor, private text: string) {}\n  execute(): void { this.editor.append(this.text); }\n  undo(): void { this.editor.delete(this.text.length); }\n}\n```\n\n## Best Practices\n\n- Use patterns to solve specific problems, not everywhere\n- Combine patterns when appropriate\n- Favor composition over inheritance\n- Keep implementations simple\n",
    "patterns/index.md": "# Enterprise Patterns\n\nThis directory contains enterprise application patterns.\n\n## Available Chunks\n\n- **base-patterns.md** - Value Objects, Money, Special Case, Registry, Plugin\n- **concurrency.md** - Optimistic/Pessimistic locking, Coarse-Grained Lock\n- **data-access.md** - Repository, Data Mapper, Active Record, Unit of Work\n- **distribution.md** - Remote Facade, DTO, Gateway, Service Stub\n- **domain-logic.md** - Transaction Script, Domain Model, Service Layer\n- **gof.md** - Gang of Four: Creational, Structural, Behavioral patterns\n",
    "performance/async.md": "# Async Performance Patterns\n\n## Parallel Execution\n\n```typescript\n// ❌ Sequential - slow\nasync function getUserData(userId: string) {\n  const user = await fetchUser(userId);       // 100ms\n  const posts = await fetchPosts(userId);     // 150ms\n  const comments = await fetchComments(userId); // 120ms\n  return { user, posts, comments }; // Total: 370ms\n}\n\n// ✅ Parallel - fast\nasync function getUserData(userId: string) {\n  const [user, posts, comments] = await Promise.all([\n    fetchUser(userId),\n    fetchPosts(userId),\n    fetchComments(userId)\n  ]);\n  return { user, posts, comments }; // Total: 150ms\n}\n\n// ✅ Partial parallel with dependencies\nasync function getOrderDetails(orderId: string) {\n  const order = await fetchOrder(orderId); // Must fetch first\n\n  const [customer, items, shipping] = await Promise.all([\n    fetchCustomer(order.customerId),\n    fetchOrderItems(orderId),\n    fetchShippingInfo(orderId)\n  ]);\n\n  return { order, customer, items, shipping };\n}\n```\n\n## Promise.allSettled for Partial Failures\n\n```typescript\n// Return partial data instead of complete failure\nasync function getDashboard(userId: string) {\n  const [user, orders, stats] = await Promise.allSettled([\n    getUser(userId),\n    getOrders(userId),\n    getStats(userId)\n  ]);\n\n  return {\n    user: user.status === 'fulfilled' ? user.value : null,\n    orders: orders.status === 'fulfilled' ? orders.value : [],\n    stats: stats.status === 'fulfilled' ? stats.value : null,\n    errors: {\n      user: user.status === 'rejected' ? user.reason.message : null,\n      orders: orders.status === 'rejected' ? orders.reason.message : null,\n      stats: stats.status === 'rejected' ? stats.reason.message : null\n    }\n  };\n}\n```\n\n## Batch Processing\n\n```typescript\n// ❌ One at a time - slow\nasync function processUsers(userIds: string[]) {\n  for (const id of userIds) {\n    await updateUser(id);\n  }\n}\n\n// ✅ Batch processing\nasync function processUsers(userIds: string[]) {\n  const BATCH_SIZE = 50;\n\n  for (let i = 0; i < userIds.length; i += BATCH_SIZE) {\n    const batch = userIds.slice(i, i + BATCH_SIZE);\n    await Promise.all(batch.map(id => updateUser(id)));\n  }\n}\n\n// ✅ Bulk database operations\nasync function createUsers(users: User[]) {\n  await db.query(`\n    INSERT INTO users (name, email)\n    VALUES ${users.map(() => '(?, ?)').join(', ')}\n  `, users.flatMap(u => [u.name, u.email]));\n}\n```\n\n## Debouncing and Throttling\n\n```typescript\n// Debounce: Wait until user stops typing\nconst debounce = <T extends (...args: any[]) => any>(\n  fn: T,\n  delay: number\n): ((...args: Parameters<T>) => void) => {\n  let timeoutId: NodeJS.Timeout;\n\n  return (...args: Parameters<T>) => {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => fn(...args), delay);\n  };\n};\n\n// Throttle: Execute at most once per interval\nconst throttle = <T extends (...args: any[]) => any>(\n  fn: T,\n  limit: number\n): ((...args: Parameters<T>) => void) => {\n  let inThrottle: boolean;\n\n  return (...args: Parameters<T>) => {\n    if (!inThrottle) {\n      fn(...args);\n      inThrottle = true;\n      setTimeout(() => (inThrottle = false), limit);\n    }\n  };\n};\n\n// Usage\nconst searchUsers = debounce(query => api.search(query), 300);\nconst handleScroll = throttle(() => console.log('scroll'), 100);\n```\n\n## Rate Limiting Concurrent Operations\n\n```typescript\nasync function processWithLimit<T>(\n  items: T[],\n  fn: (item: T) => Promise<void>,\n  concurrency: number\n): Promise<void> {\n  const chunks = [];\n  for (let i = 0; i < items.length; i += concurrency) {\n    chunks.push(items.slice(i, i + concurrency));\n  }\n\n  for (const chunk of chunks) {\n    await Promise.all(chunk.map(fn));\n  }\n}\n\n// Usage: Process 100 items, max 10 at a time\nawait processWithLimit(users, updateUser, 10);\n```\n",
    "performance/caching-strategies.md": "# Caching Strategies\n\n## Cache Patterns\n\n### Cache-Aside (Lazy Loading)\n```typescript\nasync function getUser(id: string): Promise<User> {\n  const cached = await cache.get(`user:${id}`);\n  if (cached) return cached;\n\n  const user = await db.findUser(id);\n  await cache.set(`user:${id}`, user, { ttl: 3600 });\n  return user;\n}\n```\n\n### Write-Through\n```typescript\nasync function updateUser(user: User): Promise<void> {\n  await db.saveUser(user);\n  await cache.set(`user:${user.id}`, user);\n}\n```\n\n### Write-Behind (Write-Back)\n```typescript\nasync function updateUser(user: User): Promise<void> {\n  await cache.set(`user:${user.id}`, user);\n  await queue.add('sync-to-db', { user }); // Async persistence\n}\n```\n\n## Cache Invalidation\n\n```typescript\n// Time-based expiration\nawait cache.set('key', value, { ttl: 3600 });\n\n// Event-based invalidation\neventBus.on('user.updated', async (userId) => {\n  await cache.delete(`user:${userId}`);\n});\n\n// Pattern-based invalidation\nawait cache.deleteByPattern('user:*');\n```\n\n## HTTP Caching\n\n```typescript\n// Cache-Control headers\nres.setHeader('Cache-Control', 'public, max-age=3600');\nres.setHeader('ETag', etag(content));\n\n// Conditional requests\nif (req.headers['if-none-match'] === currentEtag) {\n  return res.status(304).end();\n}\n```\n\n## Best Practices\n\n- Cache at appropriate layers (CDN, app, DB)\n- Use consistent cache keys\n- Set appropriate TTLs\n- Monitor cache hit rates\n- Plan for cache failures (fallback to source)\n- Avoid caching sensitive data\n",
    "performance/caching.md": "# Caching Strategies\n\n## In-Memory Caching\n\n```typescript\nclass Cache<T> {\n  private cache = new Map<string, { value: T; expiry: number }>();\n\n  set(key: string, value: T, ttlMs: number = 60000): void {\n    this.cache.set(key, {\n      value,\n      expiry: Date.now() + ttlMs\n    });\n  }\n\n  get(key: string): T | null {\n    const item = this.cache.get(key);\n    if (!item) return null;\n\n    if (Date.now() > item.expiry) {\n      this.cache.delete(key);\n      return null;\n    }\n\n    return item.value;\n  }\n}\n\n// Usage\nconst userCache = new Cache<User>();\n\nasync function getUser(id: string): Promise<User> {\n  const cached = userCache.get(id);\n  if (cached) return cached;\n\n  const user = await db.findUser(id);\n  userCache.set(id, user, 300000); // 5 minutes\n  return user;\n}\n```\n\n## Redis Caching\n\n```typescript\nimport Redis from 'ioredis';\n\nconst redis = new Redis();\n\nasync function getCachedUser(id: string): Promise<User | null> {\n  const cached = await redis.get(`user:${id}`);\n  if (cached) return JSON.parse(cached);\n\n  const user = await db.findUser(id);\n  await redis.setex(`user:${id}`, 300, JSON.stringify(user)); // 5 min TTL\n  return user;\n}\n\n// Cache invalidation on update\nasync function updateUser(id: string, data: Partial<User>) {\n  const user = await db.updateUser(id, data);\n  await redis.del(`user:${id}`); // Invalidate cache\n  return user;\n}\n```\n\n## HTTP Caching\n\n```typescript\n// Cache-Control headers\napp.get('/api/products', (req, res) => {\n  res.set('Cache-Control', 'public, max-age=300'); // 5 minutes\n  res.json(products);\n});\n\n// ETag for conditional requests\napp.get('/api/user/:id', async (req, res) => {\n  const user = await getUser(req.params.id);\n  const etag = generateETag(user);\n\n  res.set('ETag', etag);\n\n  if (req.headers['if-none-match'] === etag) {\n    return res.status(304).end(); // Not Modified\n  }\n\n  res.json(user);\n});\n```\n\n## Cache-Aside Pattern\n\n```typescript\n// Also called \"lazy loading\"\nasync function getProduct(id: string): Promise<Product> {\n  // 1. Check cache\n  const cached = await redis.get(`product:${id}`);\n  if (cached) return JSON.parse(cached);\n\n  // 2. Cache miss - load from database\n  const product = await db.findProduct(id);\n\n  // 3. Store in cache\n  await redis.setex(`product:${id}`, 600, JSON.stringify(product));\n\n  return product;\n}\n```\n\n## Memoization\n\n```typescript\nconst memoize = <T extends (...args: any[]) => any>(fn: T): T => {\n  const cache = new Map<string, ReturnType<T>>();\n\n  return ((...args: any[]) => {\n    const key = JSON.stringify(args);\n    if (cache.has(key)) return cache.get(key);\n\n    const result = fn(...args);\n    cache.set(key, result);\n    return result;\n  }) as T;\n};\n\n// Cache expensive computations\nconst calculateDiscount = memoize((price: number, tier: string) => {\n  // Complex calculation\n  return result;\n});\n```\n\n## Cache Invalidation Strategies\n\n```typescript\n// Time-based expiry\nawait redis.setex(key, 300, value); // Expires after 5 minutes\n\n// Event-based invalidation\nasync function updateProduct(id: string, data: ProductUpdate) {\n  await db.updateProduct(id, data);\n  await redis.del(`product:${id}`);\n  await redis.del('products:list'); // Invalidate list cache too\n}\n\n// Cache warming\nasync function warmCache() {\n  const popularProducts = await db.getMostViewed(100);\n  for (const product of popularProducts) {\n    await redis.setex(`product:${product.id}`, 3600, JSON.stringify(product));\n  }\n}\n```\n",
    "performance/index.md": "# Performance Guidelines\n\nThis directory contains performance optimization patterns.\n\n## Available Chunks\n\n- **caching.md** - In-memory, Redis, HTTP caching, memoization\n- **async.md** - Parallel execution, batching, debouncing, throttling\n",
    "practices/code-review.md": "# Code Review Practices\n\n## Review Checklist\n\n- [ ] Code follows project style guidelines\n- [ ] No obvious bugs or logic errors\n- [ ] Error handling is appropriate\n- [ ] Tests cover new functionality\n- [ ] No security vulnerabilities introduced\n- [ ] Performance implications considered\n- [ ] Documentation updated if needed\n\n## Giving Feedback\n\n**Good:**\n```\nConsider using `Array.find()` here instead of `filter()[0]` -\nit's more readable and stops at the first match.\n```\n\n**Bad:**\n```\nThis is wrong.\n```\n\n## PR Description Template\n\n```markdown\n## Summary\nBrief description of changes\n\n## Changes\n- Added X feature\n- Fixed Y bug\n- Refactored Z\n\n## Testing\n- [ ] Unit tests added\n- [ ] Manual testing performed\n\n## Screenshots (if UI changes)\n```\n\n## Best Practices\n\n- Review promptly (within 24 hours)\n- Focus on logic and design, not style (use linters)\n- Ask questions rather than make demands\n- Praise good solutions\n- Keep PRs small and focused\n- Use \"nitpick:\" prefix for minor suggestions\n- Approve with minor comments when appropriate\n",
    "practices/documentation.md": "# Documentation Organization\n\n## Keep Root Clean\n\n**RULE: Documentation must NOT clutter the project root.**\n\n```\n❌ BAD: Root folder mess\nproject/\n├── README.md\n├── ARCHITECTURE.md\n├── API_DOCS.md\n├── DEPLOYMENT.md\n├── TROUBLESHOOTING.md\n├── USER_GUIDE.md\n├── DATABASE_SCHEMA.md\n├── TESTING_GUIDE.md\n└── ... (20 more .md files)\n\n✅ GOOD: Organized structure\nproject/\n├── README.md              (overview only)\n├── docs/\n│   ├── architecture/\n│   ├── api/\n│   ├── deployment/\n│   └── guides/\n└── src/\n```\n\n## Documentation Structure\n\n**Standard documentation folder:**\n\n```\ndocs/\n├── architecture/\n│   ├── overview.md\n│   ├── decisions/         # Architecture Decision Records\n│   │   ├── 001-database-choice.md\n│   │   └── 002-api-design.md\n│   └── diagrams/\n│\n├── api/\n│   ├── endpoints.md\n│   ├── authentication.md\n│   └── examples/\n│\n├── guides/\n│   ├── getting-started.md\n│   ├── development.md\n│   ├── deployment.md\n│   └── troubleshooting.md\n│\n├── features/              # Organize by feature\n│   ├── user-auth/\n│   │   ├── overview.md\n│   │   ├── implementation.md\n│   │   └── testing.md\n│   ├── payments/\n│   └── notifications/\n│\n└── planning/              # Active work planning\n    ├── memory-lane.md     # Context preservation\n    ├── current-phase.md   # Active work\n    └── next-steps.md      # Backlog\n```\n\n## Memory Lane Document\n\n**CRITICAL: Maintain context across sessions**\n\n### Purpose\nWhen AI context limit is reached, reload from memory lane to restore working context.\n\n### Structure\n\n```markdown\n# Memory Lane - Project Context\n\n## Last Updated\n2024-12-10 15:30\n\n## Current Objective\nImplementing user authentication system with OAuth2 support\n\n## Recent Progress\n- ✅ Set up database schema (2024-12-08)\n- ✅ Implemented user registration (2024-12-09)\n- 🔄 Working on: OAuth2 integration (2024-12-10)\n- ⏳ Next: Session management\n\n## Key Decisions\n1. **Database**: PostgreSQL chosen for ACID compliance\n2. **Auth Strategy**: OAuth2 + JWT tokens\n3. **Session Store**: Redis for performance\n\n## Important Files\n- `src/auth/oauth.ts` - OAuth2 implementation (IN PROGRESS)\n- `src/models/user.ts` - User model and validation\n- `docs/architecture/decisions/003-auth-system.md` - Full context\n\n## Active Questions\n1. Should we support refresh tokens? (Pending user decision)\n2. Token expiry: 1h or 24h? (Pending user decision)\n\n## Technical Context\n- Using Passport.js for OAuth\n- Google and GitHub providers configured\n- Callback URLs: /auth/google/callback, /auth/github/callback\n\n## Known Issues\n- OAuth redirect not working in development (investigating)\n- Need to add rate limiting to prevent abuse\n\n## Next Session\n1. Fix OAuth redirect issue\n2. Implement refresh token rotation\n3. Add comprehensive auth tests\n```\n\n### Update Frequency\n- Update after each significant milestone\n- Update before context limit is reached\n- Update when switching between features\n\n## Context Reload Strategy\n\n**For AI Tools with Hooks:**\n\nCreate a hook to reload memory lane on startup:\n\n```json\n{\n  \"hooks\": {\n    \"startup\": {\n      \"command\": \"cat docs/planning/memory-lane.md\"\n    }\n  }\n}\n```\n\n**For AI Tools with Agents:**\n\nCreate a context restoration agent:\n\n```markdown\n# Context Restoration Agent\n\nTask: Read and summarize current project state\n\nSources:\n1. docs/planning/memory-lane.md\n2. docs/architecture/decisions/ (recent ADRs)\n3. git log --oneline -10 (recent commits)\n\nOutput: Concise summary of where we are and what's next\n```\n\n## Feature Documentation\n\n**Organize by feature/scope, not by type:**\n\n```\n❌ BAD: Organized by document type\ndocs/\n├── specifications/\n│   ├── auth.md\n│   ├── payments.md\n│   └── notifications.md\n├── implementations/\n│   ├── auth.md\n│   ├── payments.md\n│   └── notifications.md\n└── tests/\n    ├── auth.md\n    └── payments.md\n\n✅ GOOD: Organized by feature\ndocs/features/\n├── auth/\n│   ├── specification.md\n│   ├── implementation.md\n│   ├── api.md\n│   └── testing.md\n├── payments/\n│   ├── specification.md\n│   ├── implementation.md\n│   └── providers.md\n└── notifications/\n    ├── specification.md\n    └── channels.md\n```\n\n**Benefits:**\n- All related docs in one place\n- Easy to find feature-specific information\n- Natural scope boundaries\n- Easier to maintain\n\n## Planning Documents\n\n**Active planning should be in docs/planning/:**\n\n```\ndocs/planning/\n├── memory-lane.md         # Context preservation\n├── current-sprint.md      # Active work\n├── backlog.md             # Future work\n└── spike-results/         # Research findings\n    ├── database-options.md\n    └── auth-libraries.md\n```\n\n## Documentation Principles\n\n1. **Separate folder**: All docs in `docs/` directory\n2. **Organize by scope**: Group by feature, not document type\n3. **Keep root clean**: Only README.md in project root\n4. **Maintain memory lane**: Update regularly for context preservation\n5. **Link related docs**: Use relative links between related documents\n\n## README Guidelines\n\n**Root README should be concise:**\n\n```markdown\n# Project Name\n\nBrief description\n\n## Quick Start\n[Link to docs/guides/getting-started.md]\n\n## Documentation\n- [Architecture](docs/architecture/overview.md)\n- [API Docs](docs/api/endpoints.md)\n- [Development Guide](docs/guides/development.md)\n\n## Contributing\n[Link to CONTRIBUTING.md or docs/guides/contributing.md]\n```\n\n**Keep it short, link to detailed docs.**\n\n## Anti-Patterns\n\n❌ **Don't:**\n- Put 10+ markdown files in project root\n- Mix documentation types in same folder\n- Forget to update memory lane before context expires\n- Create documentation without clear organization\n- Duplicate information across multiple docs\n\n✅ **Do:**\n- Use `docs/` directory for all documentation\n- Organize by feature/scope\n- Maintain memory lane for context preservation\n- Link related documents together\n- Update docs as code evolves\n",
    "practices/index.md": "# Development Practices\n\nThis directory contains development best practices.\n\n## Available Chunks\n\n- **planning.md** - Planning workflow, phases, asking for clarification, getting approval\n- **documentation.md** - Documentation organization, folder structure, memory lane\n- **code-review.md** - Review guidelines, PR templates, feedback\n- **refactoring.md** - Code smells, refactoring patterns\n- **version-control.md** - Git workflows, branching strategies\n",
    "practices/planning.md": "# Planning Best Practices\n\n## Plan Before Implementation\n\n**ALWAYS design and plan before writing code:**\n\n1. **Understand Requirements**\n   - Clarify the goal and scope\n   - Identify constraints and dependencies\n   - Ask questions about ambiguous requirements\n\n2. **Break Down Into Phases**\n   - Divide work into logical phases\n   - Define deliverables for each phase\n   - Prioritize phases by value and dependencies\n\n3. **Design First**\n   - Sketch architecture and data flow\n   - Identify components and interfaces\n   - Consider edge cases and error scenarios\n\n4. **Get User Approval**\n   - Present the plan to stakeholders\n   - Explain trade-offs and alternatives\n   - Wait for approval before implementation\n\n## Never Make Assumptions\n\n**CRITICAL: When in doubt, ASK:**\n\n```typescript\n// ❌ BAD: Assuming what user wants\nasync function processOrder(orderId: string) {\n  // Assuming we should send email, but maybe not?\n  await sendConfirmationEmail(orderId);\n  // Assuming payment is already captured?\n  await fulfillOrder(orderId);\n}\n\n// ✅ GOOD: Clarify requirements first\n// Q: Should we send confirmation email at this stage?\n// Q: Is payment already captured or should we capture it here?\n// Q: What happens if fulfillment fails?\n```\n\n**Ask about:**\n- Expected behavior in edge cases\n- Error handling strategy\n- Performance requirements\n- Security considerations\n- User experience preferences\n\n## Plan in Phases\n\n**Structure work into clear phases:**\n\n### Phase 1: Foundation\n- Set up project structure\n- Configure tooling and dependencies\n- Create basic types and interfaces\n\n### Phase 2: Core Implementation\n- Implement main business logic\n- Add error handling\n- Write unit tests\n\n### Phase 3: Integration\n- Connect components\n- Add integration tests\n- Handle edge cases\n\n### Phase 4: Polish\n- Performance optimization\n- Documentation\n- Final review\n\n**Checkpoint after each phase:**\n- Demo functionality\n- Get feedback\n- Adjust plan if needed\n\n## Planning Template\n\n```markdown\n## Goal\n[What are we building and why?]\n\n## Requirements\n- [ ] Requirement 1\n- [ ] Requirement 2\n- [ ] Requirement 3\n\n## Questions for Clarification\n1. [Question about requirement X]\n2. [Question about edge case Y]\n3. [Question about preferred approach for Z]\n\n## Proposed Approach\n[Describe the solution]\n\n## Phases\n1. **Phase 1**: [Description]\n   - Task 1\n   - Task 2\n\n2. **Phase 2**: [Description]\n   - Task 1\n   - Task 2\n\n## Risks & Mitigation\n- **Risk**: [Description]\n  **Mitigation**: [How to handle]\n\n## Alternatives Considered\n- **Option A**: [Pros/Cons]\n- **Option B**: [Pros/Cons]\n- **Chosen**: Option A because [reason]\n```\n\n## Communication Principles\n\n1. **Ask Early**: Don't wait until you're stuck\n2. **Be Specific**: \"Should error X retry or fail immediately?\"\n3. **Propose Options**: \"Would you prefer A or B?\"\n4. **Explain Trade-offs**: \"Fast but risky vs. Slow but safe\"\n5. **Document Decisions**: Record what was decided and why\n\n## Anti-Patterns\n\n❌ **Don't:**\n- Start coding without understanding requirements\n- Assume you know what the user wants\n- Skip the planning phase to \"save time\"\n- Make architectural decisions without discussion\n- Proceed with unclear requirements\n\n✅ **Do:**\n- Ask questions when requirements are vague\n- Create a plan and get it approved\n- Break work into reviewable phases\n- Document decisions and reasoning\n- Communicate early and often\n",
    "practices/refactoring.md": "# Refactoring Patterns\n\n## Common Code Smells\n\n### Long Method\nSplit into smaller, focused functions.\n\n```typescript\n// Before\nfunction processOrder(order: Order) {\n  // 100 lines of code...\n}\n\n// After\nfunction processOrder(order: Order) {\n  validateOrder(order);\n  calculateTotals(order);\n  applyDiscounts(order);\n  saveOrder(order);\n}\n```\n\n### Duplicate Code\nExtract common logic.\n\n```typescript\n// Before\nfunction getAdminUsers() {\n  return users.filter(u => u.role === 'admin' && u.active);\n}\nfunction getModeratorUsers() {\n  return users.filter(u => u.role === 'moderator' && u.active);\n}\n\n// After\nfunction getActiveUsersByRole(role: string) {\n  return users.filter(u => u.role === role && u.active);\n}\n```\n\n### Primitive Obsession\nUse value objects.\n\n```typescript\n// Before\nfunction sendEmail(email: string) { /* ... */ }\n\n// After\nclass Email {\n  constructor(private value: string) {\n    if (!this.isValid(value)) throw new Error('Invalid email');\n  }\n}\nfunction sendEmail(email: Email) { /* ... */ }\n```\n\n### Feature Envy\nMove method to class it uses most.\n\n```typescript\n// Before - Order is accessing customer too much\nclass Order {\n  getDiscount() {\n    return this.customer.isPremium() ?\n      this.customer.premiumDiscount :\n      this.customer.regularDiscount;\n  }\n}\n\n// After\nclass Customer {\n  getDiscount(): number {\n    return this.isPremium() ? this.premiumDiscount : this.regularDiscount;\n  }\n}\n```\n\n## Safe Refactoring Steps\n\n1. Ensure tests pass before refactoring\n2. Make one small change at a time\n3. Run tests after each change\n4. Commit frequently\n5. Refactor in separate commits from feature work\n\n## Best Practices\n\n- Refactor when adding features, not separately\n- Keep refactoring commits separate\n- Use IDE refactoring tools when available\n- Write tests before refactoring if missing\n",
    "practices/version-control.md": "# Version Control Patterns\n\n## Branching Strategies\n\n### GitHub Flow\nSimple: main + feature branches.\n\n```\nmain ─────●─────●─────●─────●─────\n           \\         /\nfeature     ●───●───●\n```\n\n### Git Flow\nFor scheduled releases: main, develop, feature, release, hotfix.\n\n```\nmain    ─────●─────────────●─────\n              \\           /\nrelease        ●─────────●\n                \\       /\ndevelop  ●───●───●───●───●───●───\n          \\     /\nfeature    ●───●\n```\n\n## Commit Messages\n\n```\nfeat: add user authentication\n\n- Implement JWT-based auth\n- Add login/logout endpoints\n- Include password hashing\n\nCloses #123\n```\n\n**Prefixes:**\n- `feat:` - New feature\n- `fix:` - Bug fix\n- `refactor:` - Code change that doesn't fix bug or add feature\n- `docs:` - Documentation only\n- `test:` - Adding tests\n- `chore:` - Maintenance tasks\n\n## Best Practices\n\n- Keep commits atomic and focused\n- Write descriptive commit messages\n- Pull/rebase before pushing\n- Never force push to shared branches\n- Use pull requests for code review\n- Delete merged branches\n- Tag releases with semantic versions\n",
    "security/auth-jwt.md": "# Authentication & JWT Security\n\n## Password Storage\n\n```typescript\nimport bcrypt from 'bcrypt';\n\nconst SALT_ROUNDS = 12; // Work factor\n\n// ✅ Hash password with bcrypt\nasync function hashPassword(password: string): Promise<string> {\n  return bcrypt.hash(password, SALT_ROUNDS);\n}\n\nasync function verifyPassword(password: string, hash: string): Promise<boolean> {\n  return bcrypt.compare(password, hash);\n}\n\n// ✅ Validate password strength\nfunction validatePassword(password: string): void {\n  if (password.length < 12) {\n    throw new Error('Password must be at least 12 characters');\n  }\n  if (password.length > 160) {\n    throw new Error('Password too long'); // Prevent DoS via bcrypt\n  }\n}\n```\n\n## JWT Best Practices\n\n```typescript\nimport jwt from 'jsonwebtoken';\n\nconst JWT_SECRET = process.env.JWT_SECRET!;\nconst ACCESS_TOKEN_EXPIRY = '15m';\nconst REFRESH_TOKEN_EXPIRY = '7d';\n\n// ✅ Generate tokens\nfunction generateTokens(userId: string) {\n  const accessToken = jwt.sign(\n    { sub: userId, type: 'access' },\n    JWT_SECRET,\n    { expiresIn: ACCESS_TOKEN_EXPIRY }\n  );\n\n  const refreshToken = jwt.sign(\n    { sub: userId, type: 'refresh' },\n    JWT_SECRET,\n    { expiresIn: REFRESH_TOKEN_EXPIRY }\n  );\n\n  return { accessToken, refreshToken };\n}\n\n// ✅ Verify and decode token\nfunction verifyToken(token: string) {\n  try {\n    return jwt.verify(token, JWT_SECRET);\n  } catch (error) {\n    if (error instanceof jwt.TokenExpiredError) {\n      throw new UnauthorizedError('Token expired');\n    }\n    throw new UnauthorizedError('Invalid token');\n  }\n}\n```\n\n## Login Protection\n\n```typescript\nimport rateLimit from 'express-rate-limit';\n\n// ✅ Rate limit login attempts\nconst loginLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 5, // 5 attempts\n  message: 'Too many login attempts, please try again later',\n});\n\napp.post('/login', loginLimiter, async (req, res) => {\n  const { email, password } = req.body;\n\n  const user = await userService.findByEmail(email);\n\n  // ✅ Generic error message (don't reveal if user exists)\n  if (!user || !await verifyPassword(password, user.passwordHash)) {\n    return res.status(401).json({ error: 'Invalid email or password' });\n  }\n\n  const tokens = generateTokens(user.id);\n\n  // Regenerate session to prevent fixation\n  req.session.regenerate(() => {\n    res.json({ ...tokens });\n  });\n});\n```\n\n## Session Security\n\n```typescript\napp.use(session({\n  secret: process.env.SESSION_SECRET!,\n  name: 'sessionId', // Don't use default 'connect.sid'\n\n  cookie: {\n    secure: true,        // HTTPS only\n    httpOnly: true,      // Prevent XSS access\n    sameSite: 'strict',  // CSRF protection\n    maxAge: 30 * 60 * 1000, // 30 minutes\n  },\n\n  resave: false,\n  saveUninitialized: false,\n  store: new RedisStore({ client: redisClient })\n}));\n\n// ✅ Session regeneration after login\napp.post('/login', async (req, res, next) => {\n  // ... authenticate user ...\n\n  req.session.regenerate((err) => {\n    req.session.userId = user.id;\n    res.json({ success: true });\n  });\n});\n```\n\n## Authorization Middleware\n\n```typescript\n// ✅ Require authentication\nconst requireAuth = async (req: Request, res: Response, next: NextFunction) => {\n  const token = req.headers.authorization?.replace('Bearer ', '');\n\n  if (!token) {\n    return res.status(401).json({ error: 'Authentication required' });\n  }\n\n  try {\n    const payload = verifyToken(token);\n    req.user = await userService.findById(payload.sub);\n    next();\n  } catch (error) {\n    res.status(401).json({ error: 'Invalid token' });\n  }\n};\n\n// ✅ Require specific role\nconst requireRole = (...roles: string[]) => {\n  return (req: Request, res: Response, next: NextFunction) => {\n    if (!roles.includes(req.user.role)) {\n      return res.status(403).json({ error: 'Forbidden' });\n    }\n    next();\n  };\n};\n```\n",
    "security/headers.md": "# Security Headers\n\n## Essential Headers with Helmet\n\n```typescript\nimport helmet from 'helmet';\n\n// ✅ Apply security headers with sensible defaults\napp.use(helmet());\n\n// ✅ Custom configuration\napp.use(helmet({\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      scriptSrc: [\"'self'\", \"'unsafe-inline'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n      imgSrc: [\"'self'\", \"data:\", \"https:\"],\n    }\n  },\n  hsts: {\n    maxAge: 31536000,\n    includeSubDomains: true,\n    preload: true\n  }\n}));\n```\n\n## Manual Header Configuration\n\n```typescript\napp.use((req, res, next) => {\n  // Prevent MIME sniffing\n  res.setHeader('X-Content-Type-Options', 'nosniff');\n\n  // Prevent clickjacking\n  res.setHeader('X-Frame-Options', 'DENY');\n\n  // XSS protection\n  res.setHeader('X-XSS-Protection', '1; mode=block');\n\n  // Force HTTPS\n  res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');\n\n  // Referrer policy\n  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');\n\n  // Permissions policy\n  res.setHeader('Permissions-Policy', 'geolocation=(), microphone=(), camera=()');\n\n  next();\n});\n```\n\n## Content Security Policy (CSP)\n\n```typescript\n// ✅ Strict CSP for maximum protection\nres.setHeader('Content-Security-Policy', [\n  \"default-src 'self'\",\n  \"script-src 'self'\",\n  \"style-src 'self' 'unsafe-inline'\",\n  \"img-src 'self' data: https:\",\n  \"font-src 'self'\",\n  \"connect-src 'self' https://api.example.com\",\n  \"frame-ancestors 'none'\",\n  \"form-action 'self'\"\n].join('; '));\n\n// For APIs that don't serve HTML\nres.setHeader('Content-Security-Policy', \"default-src 'none'\");\n```\n\n## CORS Configuration\n\n```typescript\nimport cors from 'cors';\n\n// ✅ Configure CORS properly\napp.use(cors({\n  origin: ['https://example.com', 'https://app.example.com'],\n  methods: ['GET', 'POST', 'PUT', 'DELETE'],\n  allowedHeaders: ['Content-Type', 'Authorization'],\n  credentials: true,\n  maxAge: 86400 // Cache preflight for 24 hours\n}));\n\n// ❌ Never use in production\napp.use(cors({ origin: '*' })); // Allows any origin\n```\n\n## HTTPS Enforcement\n\n```typescript\n// ✅ Redirect HTTP to HTTPS\napp.use((req, res, next) => {\n  if (!req.secure && req.get('x-forwarded-proto') !== 'https') {\n    return res.redirect(301, `https://${req.hostname}${req.url}`);\n  }\n  next();\n});\n\n// ✅ HSTS header (included in helmet)\nres.setHeader(\n  'Strict-Transport-Security',\n  'max-age=31536000; includeSubDomains; preload'\n);\n```\n\n## Cookie Security\n\n```typescript\n// ✅ Secure cookie settings\napp.use(session({\n  cookie: {\n    secure: true,        // Only send over HTTPS\n    httpOnly: true,      // Not accessible via JavaScript\n    sameSite: 'strict',  // CSRF protection\n    maxAge: 30 * 60 * 1000\n  }\n}));\n\n// ✅ Set secure cookies manually\nres.cookie('token', value, {\n  httpOnly: true,\n  secure: process.env.NODE_ENV === 'production',\n  sameSite: 'strict',\n  maxAge: 3600000\n});\n```\n\n## Header Checklist\n\n```\n✅ X-Content-Type-Options: nosniff\n✅ X-Frame-Options: DENY\n✅ X-XSS-Protection: 1; mode=block\n✅ Strict-Transport-Security: max-age=31536000\n✅ Content-Security-Policy: (appropriate policy)\n✅ Referrer-Policy: strict-origin-when-cross-origin\n✅ Permissions-Policy: restrict unused features\n✅ Secure, HttpOnly, SameSite cookies\n```\n",
    "security/index.md": "# Security Guidelines\n\nThis directory contains security best practices.\n\n## Available Chunks\n\n- **injection.md** - SQL injection, NoSQL injection, command injection prevention\n- **auth-jwt.md** - Password storage, JWT, session management, authorization\n- **secrets.md** - Environment variables, secret generation, CI/CD secrets\n- **headers.md** - Security headers, CORS, HTTPS, CSP\n",
    "security/injection.md": "# Injection Prevention\n\n## SQL Injection Prevention\n\n```typescript\n// ❌ DANGEROUS: String concatenation\nconst getUserByEmail = async (email: string) => {\n  const query = `SELECT * FROM users WHERE email = '${email}'`;\n  // Input: ' OR '1'='1\n  // Result: SELECT * FROM users WHERE email = '' OR '1'='1'\n  return db.query(query);\n};\n\n// ✅ SAFE: Parameterized queries\nconst getUserByEmail = async (email: string) => {\n  return db.query('SELECT * FROM users WHERE email = ?', [email]);\n};\n\n// ✅ SAFE: Using ORM\nconst getUserByEmail = async (email: string) => {\n  return userRepository.findOne({ where: { email } });\n};\n\n// ✅ SAFE: Query builder\nconst getUsers = async (minAge: number) => {\n  return db\n    .select('*')\n    .from('users')\n    .where('age', '>', minAge); // Automatically parameterized\n};\n```\n\n## NoSQL Injection Prevention\n\n```typescript\n// ❌ DANGEROUS: Accepting objects from user input\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  // If password = {$gt: \"\"}, it bypasses password check!\n  db.users.findOne({ username, password });\n});\n\n// ✅ SAFE: Validate input types\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n\n  if (typeof username !== 'string' || typeof password !== 'string') {\n    throw new Error('Invalid input types');\n  }\n\n  db.users.findOne({ username, password });\n});\n```\n\n## Command Injection Prevention\n\n```typescript\n// ❌ DANGEROUS: Shell command with user input\nconst convertImage = async (filename: string) => {\n  exec(`convert ${filename} output.jpg`);\n  // Input: \"file.png; rm -rf /\"\n};\n\n// ✅ SAFE: Use arrays, avoid shell\nimport { execFile } from 'child_process';\n\nconst convertImage = async (filename: string) => {\n  execFile('convert', [filename, 'output.jpg']);\n};\n\n// ✅ SAFE: Validate input against whitelist\nconst allowedFilename = /^[a-zA-Z0-9_-]+\\.(png|jpg|gif)$/;\nif (!allowedFilename.test(filename)) {\n  throw new Error('Invalid filename');\n}\n```\n\n## Path Traversal Prevention\n\n```typescript\n// ❌ DANGEROUS: Direct path usage\napp.get('/files/:filename', (req, res) => {\n  res.sendFile(`/uploads/${req.params.filename}`);\n  // Input: ../../etc/passwd\n});\n\n// ✅ SAFE: Validate and normalize path\nimport path from 'path';\n\napp.get('/files/:filename', (req, res) => {\n  const safeName = path.basename(req.params.filename);\n  const filePath = path.join('/uploads', safeName);\n  const normalizedPath = path.normalize(filePath);\n\n  if (!normalizedPath.startsWith('/uploads/')) {\n    return res.status(400).json({ error: 'Invalid filename' });\n  }\n\n  res.sendFile(normalizedPath);\n});\n```\n\n## Input Validation\n\n```typescript\n// ✅ Whitelist validation\nimport { z } from 'zod';\n\nconst userSchema = z.object({\n  email: z.string().email(),\n  password: z.string().min(12).max(160),\n  age: z.number().int().min(0).max(150),\n  role: z.enum(['user', 'admin'])\n});\n\nconst validateUser = (data: unknown) => {\n  return userSchema.parse(data);\n};\n```\n",
    "security/secrets.md": "# Secrets Management\n\n## Environment Variables\n\n```typescript\n// ❌ NEVER hardcode secrets\nconst config = {\n  dbPassword: 'super_secret_password',\n  apiKey: 'sk-1234567890abcdef'\n};\n\n// ✅ Use environment variables\nimport dotenv from 'dotenv';\ndotenv.config();\n\nconst config = {\n  dbPassword: process.env.DB_PASSWORD,\n  apiKey: process.env.API_KEY,\n  sessionSecret: process.env.SESSION_SECRET\n};\n```\n\n## Validate Required Secrets\n\n```typescript\n// ✅ Fail fast if secrets missing\nconst requiredEnvVars = [\n  'DB_PASSWORD',\n  'API_KEY',\n  'SESSION_SECRET',\n  'JWT_SECRET'\n];\n\nrequiredEnvVars.forEach(varName => {\n  if (!process.env[varName]) {\n    throw new Error(`Missing required environment variable: ${varName}`);\n  }\n});\n\n// ✅ Type-safe config\ninterface Config {\n  dbPassword: string;\n  apiKey: string;\n  sessionSecret: string;\n}\n\nfunction loadConfig(): Config {\n  const dbPassword = process.env.DB_PASSWORD;\n  if (!dbPassword) throw new Error('DB_PASSWORD required');\n\n  // ... validate all required vars\n\n  return { dbPassword, apiKey, sessionSecret };\n}\n```\n\n## Generate Strong Secrets\n\n```bash\n# Generate cryptographically secure secrets\nnode -e \"console.log(require('crypto').randomBytes(32).toString('base64'))\"\n\n# Or using OpenSSL\nopenssl rand -base64 32\n\n# Or using head\nhead -c32 /dev/urandom | base64\n```\n\n## .gitignore Configuration\n\n```bash\n# .gitignore - NEVER commit secrets\n.env\n.env.local\n.env.*.local\n*.key\n*.pem\nsecrets/\ncredentials.json\n```\n\n## Environment Example File\n\n```bash\n# .env.example - commit this to show required variables\nDB_HOST=localhost\nDB_PORT=5432\nDB_NAME=myapp\nDB_USER=\nDB_PASSWORD=\n\nAPI_KEY=\nSESSION_SECRET=\nJWT_SECRET=\n\n# Copy to .env and fill in actual values\n```\n\n## Secrets in CI/CD\n\n```yaml\n# GitHub Actions\n- name: Deploy\n  env:\n    DB_PASSWORD: ${{ secrets.DB_PASSWORD }}\n    API_KEY: ${{ secrets.API_KEY }}\n  run: ./deploy.sh\n\n# ❌ Never echo secrets in logs\n- name: Configure\n  run: |\n    echo \"Configuring application...\"\n    # echo \"DB_PASSWORD=$DB_PASSWORD\"  # NEVER do this!\n```\n\n## Secrets Rotation\n\n```typescript\n// ✅ Support for rotating secrets\nclass SecretManager {\n  async getSecret(name: string): Promise<string> {\n    // Check for new secret first (during rotation)\n    const newSecret = process.env[`${name}_NEW`];\n    if (newSecret) {\n      return newSecret;\n    }\n\n    const secret = process.env[name];\n    if (!secret) {\n      throw new Error(`Secret ${name} not found`);\n    }\n    return secret;\n  }\n}\n\n// ✅ Accept multiple JWT signing keys during rotation\nfunction verifyToken(token: string) {\n  const keys = [process.env.JWT_SECRET, process.env.JWT_SECRET_OLD].filter(Boolean);\n\n  for (const key of keys) {\n    try {\n      return jwt.verify(token, key);\n    } catch {}\n  }\n  throw new Error('Invalid token');\n}\n```\n",
    "style/index.md": "# Code Style Guidelines\n\nThis directory contains coding style and organization patterns.\n\n## Available Chunks\n\n- **naming.md** - Variables, constants, classes, files, avoiding magic numbers\n- **organization.md** - Function length, nesting depth, file structure, SRP\n",
    "style/naming.md": "# Naming Conventions\n\n## Variables and Functions\n\n```typescript\n// camelCase for variables and functions\nconst userName = 'John';\nconst isActive = true;\nconst itemCount = 42;\n\nfunction calculateTotal(items: Item[]): number {\n  return items.reduce((sum, item) => sum + item.price, 0);\n}\n\n// Boolean variables: use is/has/can/should prefix\nconst isValid = validate(input);\nconst hasPermission = checkPermission(user);\nconst canEdit = user.role === 'admin';\nconst shouldRetry = error.code === 'TIMEOUT';\n\n// Collections: use plural names\nconst users = getUsers();\nconst activeOrders = orders.filter(o => o.status === 'active');\n```\n\n## Constants\n\n```typescript\n// UPPER_SNAKE_CASE for constants\nconst MAX_RETRY_ATTEMPTS = 3;\nconst DEFAULT_TIMEOUT_MS = 5000;\nconst API_BASE_URL = 'https://api.example.com';\n\n// Enum-like objects\nconst ORDER_STATUS = {\n  PENDING: 'pending',\n  PROCESSING: 'processing',\n  SHIPPED: 'shipped',\n  DELIVERED: 'delivered',\n  CANCELLED: 'cancelled'\n} as const;\n\nconst HTTP_STATUS = {\n  OK: 200,\n  CREATED: 201,\n  BAD_REQUEST: 400,\n  NOT_FOUND: 404\n} as const;\n```\n\n## Classes and Types\n\n```typescript\n// PascalCase for classes and types\nclass UserService {\n  constructor(private userRepository: UserRepository) {}\n}\n\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n}\n\ntype UserRole = 'admin' | 'editor' | 'viewer';\n\n// Avoid prefixes\n// ❌ IUser, CUser, TUser\n// ✅ User\n```\n\n## Files and Modules\n\n```typescript\n// kebab-case for files\nuser-service.ts\norder-repository.ts\ncreate-user.dto.ts\n\n// Match file name to primary export\n// user-service.ts exports UserService\n// order-repository.ts exports OrderRepository\n```\n\n## Avoid Bad Names\n\n```typescript\n// ❌ Bad - unclear\nconst d = Date.now();\nconst tmp = user.name;\nconst data = fetchData();\nconst flag = true;\n\n// ✅ Good - descriptive\nconst currentDate = Date.now();\nconst originalUserName = user.name;\nconst customerOrders = fetchCustomerOrders();\nconst isEmailVerified = true;\n```\n\n## Avoid Magic Numbers\n\n```typescript\n// ❌ Magic numbers\nif (user.age >= 18) { ... }\nif (items.length > 100) { ... }\nsetTimeout(callback, 5000);\n\n// ✅ Named constants\nconst LEGAL_AGE = 18;\nconst MAX_BATCH_SIZE = 100;\nconst DEFAULT_TIMEOUT_MS = 5000;\n\nif (user.age >= LEGAL_AGE) { ... }\nif (items.length > MAX_BATCH_SIZE) { ... }\nsetTimeout(callback, DEFAULT_TIMEOUT_MS);\n```\n\n## Consistency\n\n```typescript\n// Pick ONE style and stick with it across the project\n\n// ✅ Consistent camelCase in APIs\n{\n  \"userId\": 123,\n  \"firstName\": \"John\",\n  \"createdAt\": \"2024-01-01\"\n}\n\n// ❌ Mixed styles\n{\n  \"user_id\": 123,      // snake_case\n  \"firstName\": \"John\", // camelCase - inconsistent!\n}\n```\n",
    "style/organization.md": "# Code Organization\n\n## Function Length\n\n```typescript\n// ❌ Function too long (>50 lines)\nfunction processOrder(orderId: string) {\n  // 200 lines of validation, payment, inventory, shipping...\n}\n\n// ✅ Extract into smaller, focused functions\nfunction processOrder(orderId: string) {\n  const order = fetchOrder(orderId);\n\n  validateOrder(order);\n  reserveInventory(order.items);\n  processPayment(order);\n  scheduleShipping(order);\n  sendConfirmation(order.customer.email);\n\n  return order;\n}\n```\n\n## Nesting Depth\n\n```typescript\n// ❌ Too much nesting (>3 levels)\nif (user) {\n  if (user.isActive) {\n    if (user.hasPermission('edit')) {\n      if (resource.isAvailable) {\n        // Deep nesting is hard to follow\n      }\n    }\n  }\n}\n\n// ✅ Guard clauses to reduce nesting\nif (!user) return;\nif (!user.isActive) return;\nif (!user.hasPermission('edit')) return;\nif (!resource.isAvailable) return;\n\n// Clear logic at top level\n\n// ✅ Extract complex conditions\nfunction canEditResource(user: User, resource: Resource): boolean {\n  return user &&\n         user.isActive &&\n         user.hasPermission('edit') &&\n         resource.isAvailable;\n}\n\nif (canEditResource(user, resource)) {\n  // Single level of nesting\n}\n```\n\n## File Length\n\n```typescript\n// ❌ God file (1000+ lines)\n// user-service.ts with 50 methods handling users, auth, permissions...\n\n// ✅ Split into focused modules (~200-300 lines each)\n// user-service.ts - CRUD operations\n// auth-service.ts - login, logout, tokens\n// permission-service.ts - role checks\n```\n\n## File Organization\n\n```typescript\n// Consistent structure within files:\n\n// 1. Imports (grouped and ordered)\nimport fs from 'fs';                    // Standard library\nimport express from 'express';          // External dependencies\nimport { UserService } from './user';   // Internal modules\n\n// 2. Constants and type definitions\nconst MAX_RETRIES = 3;\n\ninterface UserDTO {\n  id: string;\n  name: string;\n}\n\n// 3. Helper functions (if needed)\nfunction validateInput(input: unknown): boolean {\n  // ...\n}\n\n// 4. Main exports/classes\nexport class OrderService {\n  // ...\n}\n\n// 5. Module initialization (if applicable)\nexport default new OrderService();\n```\n\n## Single Responsibility\n\n```typescript\n// ❌ Class doing too much\nclass UserManager {\n  createUser() {}\n  updateUser() {}\n  sendEmail() {}\n  hashPassword() {}\n  generateToken() {}\n}\n\n// ✅ Split by responsibility\nclass UserRepository {\n  create(user: User) {}\n  update(id: string, data: Partial<User>) {}\n}\n\nclass EmailService {\n  send(to: string, template: string) {}\n}\n\nclass PasswordService {\n  hash(password: string): string {}\n  verify(password: string, hash: string): boolean {}\n}\n\nclass AuthService {\n  generateToken(userId: string): string {}\n}\n```\n\n## DRY (Don't Repeat Yourself)\n\n```typescript\n// ❌ Duplicated logic\nfunction processUserOrder(order: Order) {\n  const total = order.items.reduce((sum, i) => sum + i.price * i.quantity, 0);\n  const tax = total * 0.08;\n  return total + tax;\n}\n\nfunction processGuestOrder(order: Order) {\n  const total = order.items.reduce((sum, i) => sum + i.price * i.quantity, 0);\n  const tax = total * 0.08;\n  return total + tax;\n}\n\n// ✅ Extract common logic\nfunction calculateOrderTotal(items: Item[]): number {\n  const subtotal = items.reduce((sum, i) => sum + i.price * i.quantity, 0);\n  const tax = subtotal * 0.08;\n  return subtotal + tax;\n}\n\nfunction processUserOrder(order: Order) {\n  return calculateOrderTotal(order.items);\n}\n```\n",
    "templates/agents/architecture-reviewer.md": "---\nmodel: \"claude-sonnet-4-5\"\ndescription: \"Reviews architectural decisions and patterns\"\n---\n\n# Architecture Reviewer\n\nYou are an architecture review agent ensuring code changes align with the project's architectural principles and patterns.\n\n## Your Responsibilities\n\n### Architectural Compliance\n- Verify changes follow established architecture pattern (layered, hexagonal, microservices, etc.)\n- Check dependency directions are correct\n- Ensure proper separation of concerns\n- Validate module boundaries\n\n### Design Patterns\n- Identify appropriate use of design patterns\n- Flag anti-patterns (God objects, tight coupling, etc.)\n- Suggest pattern improvements when beneficial\n- Verify SOLID principles adherence\n\n### Technical Debt\n- Identify potential technical debt introduced\n- Flag shortcuts that may cause future issues\n- Suggest refactoring opportunities\n- Assess long-term maintainability impact\n\n## Review Checklist\n\n- [ ] Does this change respect the existing architecture?\n- [ ] Are dependencies pointing in the correct direction?\n- [ ] Is there proper separation between layers/modules?\n- [ ] Are interfaces/contracts well-defined?\n- [ ] Is the change introducing tight coupling?\n- [ ] Could this be simplified using existing patterns?\n- [ ] Does this create technical debt?\n- [ ] Is this scalable and maintainable?\n\n## Output Format\n\n```\n🏗️  Architecture Review\n\nFiles reviewed: X\nArchitecture: [Layered/Hexagonal/Microservices/etc.]\n\n✅ Strengths:\n- Proper dependency injection in ServiceFactory\n- Clean interface boundaries in API layer\n\n⚠️  Concerns:\n\n1. Dependency Violation (Critical)\n   - File: src/ui/components/UserForm.tsx:23\n   - Issue: Direct database access from UI layer\n   - Impact: Violates layered architecture\n   - Solution: Access data through service layer\n\n2. Tight Coupling (Important)\n   - File: src/services/email-service.ts:45\n   - Issue: Hard-coded dependency on specific SMTP library\n   - Impact: Difficult to swap email providers\n   - Solution: Use adapter pattern with EmailProvider interface\n\n3. Potential Debt (Minor)\n   - File: src/utils/cache.ts:12\n   - Issue: In-memory cache without eviction strategy\n   - Impact: May cause memory issues at scale\n   - Solution: Implement LRU eviction or use Redis\n\n📊 Summary:\n- Critical issues: 1\n- Important issues: 1\n- Minor issues: 1\n- Technical debt score: Medium\n\nRecommendation: Address critical dependency violation before merging\n```\n\n## Guidelines\n\n- Focus on architectural implications, not minor style issues\n- Consider both immediate and long-term impacts\n- Provide specific, actionable solutions\n- Explain the \"why\" behind each concern\n- Balance idealism with pragmatism\n",
    "templates/agents/guideline-checker.md": "---\nmodel: \"claude-opus-4-5\"\ndescription: \"Verifies code changes comply with project guidelines\"\n---\n\n# Guideline Compliance Checker\n\nYou are an automated code review agent that verifies code changes follow the project's established guidelines.\n\n## Your Responsibilities\n\nWhen code changes are made, automatically verify:\n\n### Code Style Compliance\n- Naming conventions match project standards\n- File organization follows project structure\n- No redundant or commented-out code\n- Proper indentation and formatting\n\n### TypeScript/JavaScript Standards\n- TypeScript strict mode compliance\n- No `any` types (use `unknown` with type guards)\n- Proper interface/type definitions\n- Async/await patterns used correctly\n\n### Best Practices\n- Functions under 50 lines\n- Maximum 3 levels of nesting\n- Complex conditionals extracted to named functions\n- Error handling implemented properly\n- No magic numbers (use named constants)\n\n### Testing Requirements\n- New functions have corresponding tests\n- Test coverage maintained or improved\n- Tests follow AAA pattern (Arrange, Act, Assert)\n\n## Output Format\n\nReport findings in this format:\n\n```\n✅ Guideline Compliance Report\n\nFiles checked: X\n\n⚠️  Issues Found:\n\nsrc/services/example.ts:45\n  - Uses `any` type instead of `unknown`\n  - Function exceeds 50 lines (65 lines)\n\nsrc/utils/helper.ts:12\n  - Magic number 3600 should be named constant\n\nsrc/commands/init.ts:120\n  - Missing error handling for async operation\n\n📋 Recommendations:\n1. Replace `any` with `unknown` and add type guard\n2. Extract SECONDS_IN_HOUR = 3600 as constant\n3. Add try-catch block for async operation\n\nOverall: 3 issues require attention\n```\n\n## Guidelines\n\n- Be specific with file paths and line numbers\n- Explain WHY each issue matters\n- Provide actionable recommendations\n- Prioritize by severity (critical, important, minor)\n- Acknowledge good practices when found\n",
    "templates/agents/security-auditor.md": "---\nmodel: \"claude-opus-4-5\"\ntemperature: 0.3\ndescription: \"Identifies security vulnerabilities and risks\"\n---\n\n# Security Auditor\n\nYou are a security-focused code review agent that identifies vulnerabilities, security risks, and unsafe practices.\n\n## Your Responsibilities\n\n### OWASP Top 10 Checks\n- SQL Injection vulnerabilities\n- Cross-Site Scripting (XSS)\n- Authentication and session management flaws\n- Insecure direct object references\n- Security misconfiguration\n- Sensitive data exposure\n- Missing access control\n- Cross-Site Request Forgery (CSRF)\n- Using components with known vulnerabilities\n- Insufficient logging and monitoring\n\n### Code Security\n- Input validation and sanitization\n- Output encoding\n- Parameterized queries\n- Secure random number generation\n- Cryptographic best practices\n- Secrets and credential management\n- API key and token handling\n\n### Common Vulnerabilities\n- Path traversal attacks\n- Command injection\n- XML/XXE injection\n- Deserialization vulnerabilities\n- Race conditions\n- Buffer overflows (in applicable languages)\n\n## Review Process\n\n1. Scan for obvious security issues\n2. Check data flow from user input to storage/output\n3. Verify authentication and authorization\n4. Review cryptographic usage\n5. Check dependency versions for known vulnerabilities\n6. Assess error handling and information disclosure\n\n## Output Format\n\n```\n🔒 Security Audit Report\n\nFiles audited: X\nRisk Level: [Low/Medium/High/Critical]\n\n🚨 Critical Vulnerabilities:\n\n1. SQL Injection Risk\n   - File: src/database/user-repository.ts:34\n   - Code: `db.query(\\`SELECT * FROM users WHERE id = ${userId}\\`)`\n   - Risk: Allows arbitrary SQL execution\n   - Fix: Use parameterized query: `db.query('SELECT * FROM users WHERE id = ?', [userId])`\n   - CWE: CWE-89\n\n⚠️  High Risk Issues:\n\n2. Sensitive Data Exposure\n   - File: src/api/auth-controller.ts:89\n   - Code: User password returned in API response\n   - Risk: Password hash exposed to clients\n   - Fix: Remove password from response object\n\n🔔 Medium Risk Issues:\n\n3. Missing Input Validation\n   - File: src/api/upload-controller.ts:12\n   - Code: File upload without type validation\n   - Risk: Malicious file upload\n   - Fix: Validate file type and size before processing\n\n💡 Security Recommendations:\n\n- Enable Content Security Policy headers\n- Implement rate limiting on authentication endpoints\n- Add CSRF tokens to state-changing operations\n- Use secure HTTP-only cookies for sessions\n- Enable security headers (X-Frame-Options, etc.)\n\n📊 Summary:\n- Critical: 1\n- High: 1\n- Medium: 1\n- Low: 0\n\n⚠️  Action Required: Fix critical SQL injection before deployment\n```\n\n## Guidelines\n\n- Prioritize by actual risk, not theoretical scenarios\n- Provide clear, actionable fixes with code examples\n- Reference CWE/CVE numbers when applicable\n- Consider the application's threat model\n- Balance security with usability\n- Don't create false positives unnecessarily\n",
    "testing/index.md": "# Testing Guidelines\n\nThis directory contains testing best practices and patterns.\n\n## Available Chunks\n\n- **unit-fundamentals.md** - AAA pattern, behavior testing, descriptive names\n- **unit-mocking.md** - Test doubles, when to mock, mock verification\n- **integration.md** - API testing, database testing, test isolation\n",
    "testing/integration.md": "# Integration Testing\n\n## Testing Real Dependencies\n\n```typescript\ndescribe('UserRepository Integration', () => {\n  let db: Database;\n  let repository: UserRepository;\n\n  beforeAll(async () => {\n    db = await createTestDatabase();\n    repository = new UserRepository(db);\n  });\n\n  afterAll(async () => {\n    await db.close();\n  });\n\n  beforeEach(async () => {\n    await db.clear('users'); // Clean slate for each test\n  });\n\n  it('should persist and retrieve user', async () => {\n    const userData = { email: 'test@example.com', name: 'Test User' };\n\n    const created = await repository.create(userData);\n    const found = await repository.findById(created.id);\n\n    expect(found).toEqual(expect.objectContaining(userData));\n  });\n});\n```\n\n## API Integration Tests\n\n```typescript\ndescribe('POST /api/users', () => {\n  let app: Express;\n  let db: Database;\n\n  beforeAll(async () => {\n    db = await createTestDatabase();\n    app = createApp(db);\n  });\n\n  afterEach(async () => {\n    await db.clear('users');\n  });\n\n  it('should create user and return 201', async () => {\n    const response = await request(app)\n      .post('/api/users')\n      .send({ email: 'new@example.com', name: 'New User' })\n      .expect(201);\n\n    expect(response.body.data).toEqual(\n      expect.objectContaining({\n        email: 'new@example.com',\n        name: 'New User'\n      })\n    );\n\n    // Verify in database\n    const user = await db.findOne('users', { email: 'new@example.com' });\n    expect(user).toBeTruthy();\n  });\n\n  it('should return 400 for invalid email', async () => {\n    const response = await request(app)\n      .post('/api/users')\n      .send({ email: 'invalid', name: 'Test' })\n      .expect(400);\n\n    expect(response.body.error.code).toBe('VALIDATION_ERROR');\n  });\n});\n```\n\n## Database Transaction Testing\n\n```typescript\ndescribe('OrderService Integration', () => {\n  it('should rollback on payment failure', async () => {\n    const order = await orderService.createOrder({ items: [...] });\n\n    // Mock payment to fail\n    paymentGateway.charge.mockRejectedValue(new Error('Declined'));\n\n    await expect(\n      orderService.processOrder(order.id)\n    ).rejects.toThrow('Payment failed');\n\n    // Verify order status unchanged\n    const updatedOrder = await orderRepository.findById(order.id);\n    expect(updatedOrder.status).toBe('pending');\n\n    // Verify inventory not deducted\n    const inventory = await inventoryRepository.findByProductId(productId);\n    expect(inventory.quantity).toBe(originalQuantity);\n  });\n});\n```\n\n## Test Data Builders\n\n```typescript\nclass UserBuilder {\n  private data: Partial<User> = {\n    email: 'default@example.com',\n    name: 'Default User',\n    role: 'user'\n  };\n\n  withEmail(email: string) { this.data.email = email; return this; }\n  withRole(role: string) { this.data.role = role; return this; }\n  asAdmin() { this.data.role = 'admin'; return this; }\n\n  build(): User { return this.data as User; }\n\n  async save(db: Database): Promise<User> {\n    return db.insert('users', this.data);\n  }\n}\n\n// Usage\nconst admin = await new UserBuilder()\n  .withEmail('admin@example.com')\n  .asAdmin()\n  .save(db);\n```\n\n## Test Isolation\n\n```typescript\n// Use transactions that rollback\ndescribe('IntegrationTests', () => {\n  beforeEach(async () => {\n    await db.beginTransaction();\n  });\n\n  afterEach(async () => {\n    await db.rollbackTransaction();\n  });\n});\n\n// Or use test containers\nimport { PostgreSqlContainer } from '@testcontainers/postgresql';\n\nlet container: PostgreSqlContainer;\n\nbeforeAll(async () => {\n  container = await new PostgreSqlContainer().start();\n  db = await connect(container.getConnectionUri());\n});\n\nafterAll(async () => {\n  await container.stop();\n});\n```\n",
    "testing/unit-fundamentals.md": "# Unit Testing Fundamentals\n\n## Arrange-Act-Assert Pattern\n\n```typescript\ndescribe('UserService', () => {\n  it('should create user with hashed password', async () => {\n    // Arrange - Set up test data and dependencies\n    const userData = { email: 'test@example.com', password: 'secret123' };\n    const mockRepo = { save: jest.fn().mockResolvedValue({ id: '1', ...userData }) };\n    const service = new UserService(mockRepo);\n\n    // Act - Execute the behavior being tested\n    const result = await service.createUser(userData);\n\n    // Assert - Verify the outcomes\n    expect(result.id).toBe('1');\n    expect(mockRepo.save).toHaveBeenCalledWith(\n      expect.objectContaining({ email: 'test@example.com' })\n    );\n  });\n});\n```\n\n## Test Observable Behavior, Not Implementation\n\n```typescript\n// ❌ Bad: Testing implementation details\nit('should call validateEmail method', () => {\n  const spy = jest.spyOn(service, 'validateEmail');\n  service.createUser({ email: 'test@example.com' });\n  expect(spy).toHaveBeenCalled();\n});\n\n// ✅ Good: Testing observable behavior\nit('should reject invalid email', async () => {\n  await expect(\n    service.createUser({ email: 'invalid-email' })\n  ).rejects.toThrow('Invalid email format');\n});\n\nit('should accept valid email', async () => {\n  const result = await service.createUser({ email: 'valid@example.com' });\n  expect(result.email).toBe('valid@example.com');\n});\n```\n\n## One Assertion Per Test Concept\n\n```typescript\n// ❌ Bad: Multiple unrelated assertions\nit('should validate user input', () => {\n  expect(() => validate({ age: -1 })).toThrow();\n  expect(() => validate({ age: 200 })).toThrow();\n  expect(() => validate({ name: '' })).toThrow();\n});\n\n// ✅ Good: One test per scenario\nit('should reject negative age', () => {\n  expect(() => validate({ age: -1 })).toThrow('Age must be positive');\n});\n\nit('should reject age over 150', () => {\n  expect(() => validate({ age: 200 })).toThrow('Age must be under 150');\n});\n\nit('should reject empty name', () => {\n  expect(() => validate({ name: '' })).toThrow('Name is required');\n});\n```\n\n## Descriptive Test Names\n\n```typescript\n// ❌ Vague names\nit('should work correctly', () => {});\nit('handles edge case', () => {});\n\n// ✅ Descriptive names - describe the scenario and expected outcome\nit('should return empty array when no users match filter', () => {});\nit('should throw ValidationError when email is empty', () => {});\nit('should retry failed payment up to 3 times before giving up', () => {});\n```\n\n## Tests Should Be Independent\n\n```typescript\n// ❌ Bad: Tests depend on each other\nlet userId: string;\n\nit('should create user', async () => {\n  const user = await service.createUser(data);\n  userId = user.id; // Shared state!\n});\n\nit('should update user', async () => {\n  await service.updateUser(userId, newData); // Depends on previous test\n});\n\n// ✅ Good: Each test is self-contained\nit('should update user', async () => {\n  const user = await service.createUser(data);\n  const updated = await service.updateUser(user.id, newData);\n  expect(updated.name).toBe(newData.name);\n});\n```\n\n## Test Edge Cases\n\n```typescript\ndescribe('divide', () => {\n  it('should divide two positive numbers', () => {\n    expect(divide(10, 2)).toBe(5);\n  });\n\n  it('should throw when dividing by zero', () => {\n    expect(() => divide(10, 0)).toThrow('Division by zero');\n  });\n\n  it('should handle negative numbers', () => {\n    expect(divide(-10, 2)).toBe(-5);\n  });\n\n  it('should return zero when numerator is zero', () => {\n    expect(divide(0, 5)).toBe(0);\n  });\n});\n```\n",
    "testing/unit-mocking.md": "# Test Doubles and Mocking\n\n## Types of Test Doubles\n\n```typescript\n// STUB: Returns canned responses\nconst stubUserRepo = {\n  findById: () => ({ id: '1', name: 'Test User' })\n};\n\n// MOCK: Pre-programmed with expectations\nconst mockPaymentGateway = {\n  charge: jest.fn()\n    .mockResolvedValueOnce({ success: true, transactionId: 'tx1' })\n    .mockResolvedValueOnce({ success: false, error: 'Declined' })\n};\n\n// SPY: Records calls for verification\nconst spy = jest.spyOn(emailService, 'send');\n\n// FAKE: Working implementation (not for production)\nclass FakeDatabase implements Database {\n  private data = new Map<string, any>();\n\n  async save(id: string, entity: any) { this.data.set(id, entity); }\n  async find(id: string) { return this.data.get(id); }\n}\n```\n\n## When to Mock\n\n```typescript\n// ✅ Mock external services (APIs, databases)\nconst mockHttpClient = {\n  get: jest.fn().mockResolvedValue({ data: userData })\n};\n\n// ✅ Mock time-dependent operations\njest.useFakeTimers();\njest.setSystemTime(new Date('2024-01-15'));\n\n// ✅ Mock random/non-deterministic functions\njest.spyOn(Math, 'random').mockReturnValue(0.5);\n\n// ❌ Don't mock the code you're testing\n// ❌ Don't mock simple data structures\n```\n\n## Mock Verification\n\n```typescript\nit('should send welcome email after registration', async () => {\n  const mockEmail = { send: jest.fn().mockResolvedValue(true) };\n  const service = new UserService({ emailService: mockEmail });\n\n  await service.register({ email: 'new@example.com' });\n\n  expect(mockEmail.send).toHaveBeenCalledWith({\n    to: 'new@example.com',\n    template: 'welcome',\n    subject: 'Welcome!'\n  });\n  expect(mockEmail.send).toHaveBeenCalledTimes(1);\n});\n```\n\n## Partial Mocks\n\n```typescript\n// Mock only specific methods\nconst service = new OrderService();\n\njest.spyOn(service, 'validateOrder').mockReturnValue(true);\njest.spyOn(service, 'calculateTotal').mockReturnValue(100);\n// Other methods use real implementation\n\nconst result = await service.processOrder(orderData);\nexpect(result.total).toBe(100);\n```\n\n## Resetting Mocks\n\n```typescript\ndescribe('PaymentService', () => {\n  const mockGateway = { charge: jest.fn() };\n  const service = new PaymentService(mockGateway);\n\n  beforeEach(() => {\n    jest.clearAllMocks(); // Clear call history\n    // or jest.resetAllMocks() to also reset return values\n  });\n\n  it('should process payment', async () => {\n    mockGateway.charge.mockResolvedValue({ success: true });\n    await service.charge(100);\n    expect(mockGateway.charge).toHaveBeenCalledTimes(1);\n  });\n});\n```\n\n## Mock Modules\n\n```typescript\n// Mock entire module\njest.mock('./email-service', () => ({\n  EmailService: jest.fn().mockImplementation(() => ({\n    send: jest.fn().mockResolvedValue(true)\n  }))\n}));\n\n// Mock with partial implementation\njest.mock('./config', () => ({\n  ...jest.requireActual('./config'),\n  API_KEY: 'test-key'\n}));\n```\n"
  }
};

export const GUIDELINE_COUNT = 115;
export const MAPPING_COUNT = 59;
